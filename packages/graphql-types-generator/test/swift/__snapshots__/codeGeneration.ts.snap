// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Swift code generation #classDeclarationForOperation() should generate a class declaration for a mutation with variables 1`] = `
"public final class CreateReviewMutation: GraphQLMutation {
  public static let operationString =
    \\"mutation CreateReview($episode: Episode) {\\\\n  createReview(episode: $episode, review: {stars: 5, commentary: \\\\\\"Wow!\\\\\\"}) {\\\\n    stars\\\\n    commentary\\\\n  }\\\\n}\\"

  public var episode: Episode?

  public init(episode: Episode? = nil) {
    self.episode = episode
  }

  public var variables: GraphQLMap? {
    return [\\"episode\\": episode]
  }

  public struct Data: GraphQLSelectionSet {
    public static let possibleTypes = [\\"Mutation\\"]

    public static let selections: [GraphQLSelection] = [
      GraphQLField(\\"createReview\\", arguments: [\\"episode\\": GraphQLVariable(\\"episode\\"), \\"review\\": [\\"stars\\": 5, \\"commentary\\": \\"Wow!\\"]], type: .object(CreateReview.selections)),
    ]

    public var snapshot: Snapshot

    public init(snapshot: Snapshot) {
      self.snapshot = snapshot
    }

    public init(createReview: CreateReview? = nil) {
      self.init(snapshot: [\\"__typename\\": \\"Mutation\\", \\"createReview\\": createReview.flatMap { $0.snapshot }])
    }

    public var createReview: CreateReview? {
      get {
        return (snapshot[\\"createReview\\"] as? Snapshot).flatMap { CreateReview(snapshot: $0) }
      }
      set {
        snapshot.updateValue(newValue?.snapshot, forKey: \\"createReview\\")
      }
    }

    public struct CreateReview: GraphQLSelectionSet {
      public static let possibleTypes = [\\"Review\\"]

      public static let selections: [GraphQLSelection] = [
        GraphQLField(\\"stars\\", type: .nonNull(.scalar(Int.self))),
        GraphQLField(\\"commentary\\", type: .scalar(String.self)),
      ]

      public var snapshot: Snapshot

      public init(snapshot: Snapshot) {
        self.snapshot = snapshot
      }

      public init(stars: Int, commentary: String? = nil) {
        self.init(snapshot: [\\"__typename\\": \\"Review\\", \\"stars\\": stars, \\"commentary\\": commentary])
      }

      /// The number of stars this review gave, 1-5
      public var stars: Int {
        get {
          return snapshot[\\"stars\\"]! as! Int
        }
        set {
          snapshot.updateValue(newValue, forKey: \\"stars\\")
        }
      }

      /// Comment about the movie
      public var commentary: String? {
        get {
          return snapshot[\\"commentary\\"] as? String
        }
        set {
          snapshot.updateValue(newValue, forKey: \\"commentary\\")
        }
      }
    }
  }
}"
`;

exports[`Swift code generation #classDeclarationForOperation() should generate a class declaration for a query with a fragment spread nested in an inline fragment 1`] = `
"public final class HeroQuery: GraphQLQuery {
  public static let operationString =
    \\"query Hero {\\\\n  hero {\\\\n    ... on Droid {\\\\n      ...HeroDetails\\\\n    }\\\\n  }\\\\n}\\"

  public static var requestString: String { return operationString.appending(HeroDetails.fragmentString) }

  public init() {
  }

  public struct Data: GraphQLSelectionSet {
    public static let possibleTypes = [\\"Query\\"]

    public static let selections: [GraphQLSelection] = [
      GraphQLField(\\"hero\\", type: .object(Hero.selections)),
    ]

    public var snapshot: Snapshot

    public init(snapshot: Snapshot) {
      self.snapshot = snapshot
    }

    public init(hero: Hero? = nil) {
      self.init(snapshot: [\\"__typename\\": \\"Query\\", \\"hero\\": hero.flatMap { $0.snapshot }])
    }

    public var hero: Hero? {
      get {
        return (snapshot[\\"hero\\"] as? Snapshot).flatMap { Hero(snapshot: $0) }
      }
      set {
        snapshot.updateValue(newValue?.snapshot, forKey: \\"hero\\")
      }
    }

    public struct Hero: GraphQLSelectionSet {
      public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

      public static let selections: [GraphQLSelection] = [
        GraphQLTypeCase(
          variants: [\\"Droid\\": AsDroid.selections],
          default: [
          ]
        )
      ]

      public var snapshot: Snapshot

      public init(snapshot: Snapshot) {
        self.snapshot = snapshot
      }

      public static func makeHuman() -> Hero {
        return Hero(snapshot: [\\"__typename\\": \\"Human\\"])
      }

      public static func makeDroid(name: String) -> Hero {
        return Hero(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
      }

      public var asDroid: AsDroid? {
        get {
          if !AsDroid.possibleTypes.contains(__typename) { return nil }
          return AsDroid(snapshot: snapshot)
        }
        set {
          guard let newValue = newValue else { return }
          snapshot = newValue.snapshot
        }
      }

      public struct AsDroid: GraphQLSelectionSet {
        public static let possibleTypes = [\\"Droid\\"]

        public static let selections: [GraphQLSelection] = [
          GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
        ]

        public var snapshot: Snapshot

        public init(snapshot: Snapshot) {
          self.snapshot = snapshot
        }

        public init(name: String) {
          self.init(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
        }

        /// What others call this droid
        public var name: String {
          get {
            return snapshot[\\"name\\"]! as! String
          }
          set {
            snapshot.updateValue(newValue, forKey: \\"name\\")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(snapshot: snapshot)
          }
          set {
            snapshot += newValue.snapshot
          }
        }

        public struct Fragments {
          public var snapshot: Snapshot

          public var heroDetails: HeroDetails {
            get {
              return HeroDetails(snapshot: snapshot)
            }
            set {
              snapshot += newValue.snapshot
            }
          }
        }
      }
    }
  }
}"
`;

exports[`Swift code generation #classDeclarationForOperation() should generate a class declaration for a query with conditional fragment spreads 1`] = `
"public final class HeroQuery: GraphQLQuery {
  public static let operationString =
    \\"query Hero {\\\\n  hero {\\\\n    ...DroidDetails\\\\n  }\\\\n}\\"

  public static var requestString: String { return operationString.appending(DroidDetails.fragmentString) }

  public init() {
  }

  public struct Data: GraphQLSelectionSet {
    public static let possibleTypes = [\\"Query\\"]

    public static let selections: [GraphQLSelection] = [
      GraphQLField(\\"hero\\", type: .object(Hero.selections)),
    ]

    public var snapshot: Snapshot

    public init(snapshot: Snapshot) {
      self.snapshot = snapshot
    }

    public init(hero: Hero? = nil) {
      self.init(snapshot: [\\"__typename\\": \\"Query\\", \\"hero\\": hero.flatMap { $0.snapshot }])
    }

    public var hero: Hero? {
      get {
        return (snapshot[\\"hero\\"] as? Snapshot).flatMap { Hero(snapshot: $0) }
      }
      set {
        snapshot.updateValue(newValue?.snapshot, forKey: \\"hero\\")
      }
    }

    public struct Hero: GraphQLSelectionSet {
      public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

      public static let selections: [GraphQLSelection] = [
        GraphQLTypeCase(
          variants: [\\"Droid\\": AsDroid.selections],
          default: [
          ]
        )
      ]

      public var snapshot: Snapshot

      public init(snapshot: Snapshot) {
        self.snapshot = snapshot
      }

      public static func makeHuman() -> Hero {
        return Hero(snapshot: [\\"__typename\\": \\"Human\\"])
      }

      public static func makeDroid(primaryFunction: String? = nil) -> Hero {
        return Hero(snapshot: [\\"__typename\\": \\"Droid\\", \\"primaryFunction\\": primaryFunction])
      }

      public var fragments: Fragments {
        get {
          return Fragments(snapshot: snapshot)
        }
        set {
          snapshot += newValue.snapshot
        }
      }

      public struct Fragments {
        public var snapshot: Snapshot

        public var droidDetails: DroidDetails? {
          get {
            if !DroidDetails.possibleTypes.contains(snapshot[\\"__typename\\"]! as! String) { return nil }
            return DroidDetails(snapshot: snapshot)
          }
          set {
            guard let newValue = newValue else { return }
            snapshot += newValue.snapshot
          }
        }
      }

      public var asDroid: AsDroid? {
        get {
          if !AsDroid.possibleTypes.contains(__typename) { return nil }
          return AsDroid(snapshot: snapshot)
        }
        set {
          guard let newValue = newValue else { return }
          snapshot = newValue.snapshot
        }
      }

      public struct AsDroid: GraphQLSelectionSet {
        public static let possibleTypes = [\\"Droid\\"]

        public static let selections: [GraphQLSelection] = [
          GraphQLField(\\"primaryFunction\\", type: .scalar(String.self)),
        ]

        public var snapshot: Snapshot

        public init(snapshot: Snapshot) {
          self.snapshot = snapshot
        }

        public init(primaryFunction: String? = nil) {
          self.init(snapshot: [\\"__typename\\": \\"Droid\\", \\"primaryFunction\\": primaryFunction])
        }

        /// This droid's primary function
        public var primaryFunction: String? {
          get {
            return snapshot[\\"primaryFunction\\"] as? String
          }
          set {
            snapshot.updateValue(newValue, forKey: \\"primaryFunction\\")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(snapshot: snapshot)
          }
          set {
            snapshot += newValue.snapshot
          }
        }

        public struct Fragments {
          public var snapshot: Snapshot

          public var droidDetails: DroidDetails {
            get {
              return DroidDetails(snapshot: snapshot)
            }
            set {
              snapshot += newValue.snapshot
            }
          }
        }
      }
    }
  }
}"
`;

exports[`Swift code generation #classDeclarationForOperation() should generate a class declaration for a query with fragment spreads 1`] = `
"public final class HeroQuery: GraphQLQuery {
  public static let operationString =
    \\"query Hero {\\\\n  hero {\\\\n    ...HeroDetails\\\\n  }\\\\n}\\"

  public static var requestString: String { return operationString.appending(HeroDetails.fragmentString) }

  public init() {
  }

  public struct Data: GraphQLSelectionSet {
    public static let possibleTypes = [\\"Query\\"]

    public static let selections: [GraphQLSelection] = [
      GraphQLField(\\"hero\\", type: .object(Hero.selections)),
    ]

    public var snapshot: Snapshot

    public init(snapshot: Snapshot) {
      self.snapshot = snapshot
    }

    public init(hero: Hero? = nil) {
      self.init(snapshot: [\\"__typename\\": \\"Query\\", \\"hero\\": hero.flatMap { $0.snapshot }])
    }

    public var hero: Hero? {
      get {
        return (snapshot[\\"hero\\"] as? Snapshot).flatMap { Hero(snapshot: $0) }
      }
      set {
        snapshot.updateValue(newValue?.snapshot, forKey: \\"hero\\")
      }
    }

    public struct Hero: GraphQLSelectionSet {
      public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

      public static let selections: [GraphQLSelection] = [
        GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
      ]

      public var snapshot: Snapshot

      public init(snapshot: Snapshot) {
        self.snapshot = snapshot
      }

      public static func makeHuman(name: String) -> Hero {
        return Hero(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name])
      }

      public static func makeDroid(name: String) -> Hero {
        return Hero(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
      }

      /// The name of the character
      public var name: String {
        get {
          return snapshot[\\"name\\"]! as! String
        }
        set {
          snapshot.updateValue(newValue, forKey: \\"name\\")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(snapshot: snapshot)
        }
        set {
          snapshot += newValue.snapshot
        }
      }

      public struct Fragments {
        public var snapshot: Snapshot

        public var heroDetails: HeroDetails {
          get {
            return HeroDetails(snapshot: snapshot)
          }
          set {
            snapshot += newValue.snapshot
          }
        }
      }
    }
  }
}"
`;

exports[`Swift code generation #classDeclarationForOperation() should generate a class declaration for a query with variables 1`] = `
"public final class HeroNameQuery: GraphQLQuery {
  public static let operationString =
    \\"query HeroName($episode: Episode) {\\\\n  hero(episode: $episode) {\\\\n    name\\\\n  }\\\\n}\\"

  public var episode: Episode?

  public init(episode: Episode? = nil) {
    self.episode = episode
  }

  public var variables: GraphQLMap? {
    return [\\"episode\\": episode]
  }

  public struct Data: GraphQLSelectionSet {
    public static let possibleTypes = [\\"Query\\"]

    public static let selections: [GraphQLSelection] = [
      GraphQLField(\\"hero\\", arguments: [\\"episode\\": GraphQLVariable(\\"episode\\")], type: .object(Hero.selections)),
    ]

    public var snapshot: Snapshot

    public init(snapshot: Snapshot) {
      self.snapshot = snapshot
    }

    public init(hero: Hero? = nil) {
      self.init(snapshot: [\\"__typename\\": \\"Query\\", \\"hero\\": hero.flatMap { $0.snapshot }])
    }

    public var hero: Hero? {
      get {
        return (snapshot[\\"hero\\"] as? Snapshot).flatMap { Hero(snapshot: $0) }
      }
      set {
        snapshot.updateValue(newValue?.snapshot, forKey: \\"hero\\")
      }
    }

    public struct Hero: GraphQLSelectionSet {
      public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

      public static let selections: [GraphQLSelection] = [
        GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
      ]

      public var snapshot: Snapshot

      public init(snapshot: Snapshot) {
        self.snapshot = snapshot
      }

      public static func makeHuman(name: String) -> Hero {
        return Hero(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name])
      }

      public static func makeDroid(name: String) -> Hero {
        return Hero(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
      }

      /// The name of the character
      public var name: String {
        get {
          return snapshot[\\"name\\"]! as! String
        }
        set {
          snapshot.updateValue(newValue, forKey: \\"name\\")
        }
      }
    }
  }
}"
`;

exports[`Swift code generation #classDeclarationForOperation() should generate a class declaration with an operationIdentifier property when generateOperationIds is specified 1`] = `
"public final class HeroQuery: GraphQLQuery {
  public static let operationString =
    \\"query Hero {\\\\n  hero {\\\\n    ...HeroDetails\\\\n  }\\\\n}\\"

  public static let operationIdentifier: String? = \\"90d0d674eb6a7b33776f63200d6cec3d09f881247c360a2ac9a29037a02210c4\\"

  public static var requestString: String { return operationString.appending(HeroDetails.fragmentString) }

  public init() {
  }

  public struct Data: GraphQLSelectionSet {
    public static let possibleTypes = [\\"Query\\"]

    public static let selections: [GraphQLSelection] = [
      GraphQLField(\\"hero\\", type: .object(Hero.selections)),
    ]

    public var snapshot: Snapshot

    public init(snapshot: Snapshot) {
      self.snapshot = snapshot
    }

    public init(hero: Hero? = nil) {
      self.init(snapshot: [\\"__typename\\": \\"Query\\", \\"hero\\": hero.flatMap { $0.snapshot }])
    }

    public var hero: Hero? {
      get {
        return (snapshot[\\"hero\\"] as? Snapshot).flatMap { Hero(snapshot: $0) }
      }
      set {
        snapshot.updateValue(newValue?.snapshot, forKey: \\"hero\\")
      }
    }

    public struct Hero: GraphQLSelectionSet {
      public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

      public static let selections: [GraphQLSelection] = [
        GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
      ]

      public var snapshot: Snapshot

      public init(snapshot: Snapshot) {
        self.snapshot = snapshot
      }

      public static func makeHuman(name: String) -> Hero {
        return Hero(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name])
      }

      public static func makeDroid(name: String) -> Hero {
        return Hero(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
      }

      /// The name of the character
      public var name: String {
        get {
          return snapshot[\\"name\\"]! as! String
        }
        set {
          snapshot.updateValue(newValue, forKey: \\"name\\")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(snapshot: snapshot)
        }
        set {
          snapshot += newValue.snapshot
        }
      }

      public struct Fragments {
        public var snapshot: Snapshot

        public var heroDetails: HeroDetails {
          get {
            return HeroDetails(snapshot: snapshot)
          }
          set {
            snapshot += newValue.snapshot
          }
        }
      }
    }
  }
}"
`;

exports[`Swift code generation #fileHeader should generate a file header 1`] = `
"//  This file was automatically generated and should not be edited.

#if canImport(AWSAPIPlugin)
import Foundation

public protocol GraphQLInputValue {
}

public struct GraphQLVariable {
  let name: String
  
  public init(_ name: String) {
    self.name = name
  }
}

extension GraphQLVariable: GraphQLInputValue {
}

extension JSONEncodable {
  public func evaluate(with variables: [String: JSONEncodable]?) throws -> Any {
    return jsonValue
  }
}

public typealias GraphQLMap = [String: JSONEncodable?]

extension Dictionary where Key == String, Value == JSONEncodable? {
  public var withNilValuesRemoved: Dictionary<String, JSONEncodable> {
    var filtered = Dictionary<String, JSONEncodable>(minimumCapacity: count)
    for (key, value) in self {
      if value != nil {
        filtered[key] = value
      }
    }
    return filtered
  }
}

public protocol GraphQLMapConvertible: JSONEncodable {
  var graphQLMap: GraphQLMap { get }
}

public extension GraphQLMapConvertible {
  var jsonValue: Any {
    return graphQLMap.withNilValuesRemoved.jsonValue
  }
}

public typealias GraphQLID = String

public protocol APISwiftGraphQLOperation: AnyObject {
  
  static var operationString: String { get }
  static var requestString: String { get }
  static var operationIdentifier: String? { get }
  
  var variables: GraphQLMap? { get }
  
  associatedtype Data: GraphQLSelectionSet
}

public extension APISwiftGraphQLOperation {
  static var requestString: String {
    return operationString
  }

  static var operationIdentifier: String? {
    return nil
  }

  var variables: GraphQLMap? {
    return nil
  }
}

public protocol GraphQLQuery: APISwiftGraphQLOperation {}

public protocol GraphQLMutation: APISwiftGraphQLOperation {}

public protocol GraphQLSubscription: APISwiftGraphQLOperation {}

public protocol GraphQLFragment: GraphQLSelectionSet {
  static var possibleTypes: [String] { get }
}

public typealias Snapshot = [String: Any?]

public protocol GraphQLSelectionSet: Decodable {
  static var selections: [GraphQLSelection] { get }
  
  var snapshot: Snapshot { get }
  init(snapshot: Snapshot)
}

extension GraphQLSelectionSet {
    public init(from decoder: Decoder) throws {
        if let jsonObject = try? APISwiftJSONValue(from: decoder) {
            let encoder = JSONEncoder()
            let jsonData = try encoder.encode(jsonObject)
            let decodedDictionary = try JSONSerialization.jsonObject(with: jsonData, options: []) as! [String: Any]
            let optionalDictionary = decodedDictionary.mapValues { $0 as Any? }

            self.init(snapshot: optionalDictionary)
        } else {
            self.init(snapshot: [:])
        }
    }
}

enum APISwiftJSONValue: Codable {
    case array([APISwiftJSONValue])
    case boolean(Bool)
    case number(Double)
    case object([String: APISwiftJSONValue])
    case string(String)
    case null
    
    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        
        if let value = try? container.decode([String: APISwiftJSONValue].self) {
            self = .object(value)
        } else if let value = try? container.decode([APISwiftJSONValue].self) {
            self = .array(value)
        } else if let value = try? container.decode(Double.self) {
            self = .number(value)
        } else if let value = try? container.decode(Bool.self) {
            self = .boolean(value)
        } else if let value = try? container.decode(String.self) {
            self = .string(value)
        } else {
            self = .null
        }
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        
        switch self {
        case .array(let value):
            try container.encode(value)
        case .boolean(let value):
            try container.encode(value)
        case .number(let value):
            try container.encode(value)
        case .object(let value):
            try container.encode(value)
        case .string(let value):
            try container.encode(value)
        case .null:
            try container.encodeNil()
        }
    }
}

public protocol GraphQLSelection {
}

public struct GraphQLField: GraphQLSelection {
  let name: String
  let alias: String?
  let arguments: [String: GraphQLInputValue]?
  
  var responseKey: String {
    return alias ?? name
  }
  
  let type: GraphQLOutputType
  
  public init(_ name: String, alias: String? = nil, arguments: [String: GraphQLInputValue]? = nil, type: GraphQLOutputType) {
    self.name = name
    self.alias = alias
    
    self.arguments = arguments
    
    self.type = type
  }
}

public indirect enum GraphQLOutputType {
  case scalar(JSONDecodable.Type)
  case object([GraphQLSelection])
  case nonNull(GraphQLOutputType)
  case list(GraphQLOutputType)
  
  var namedType: GraphQLOutputType {
    switch self {
    case .nonNull(let innerType), .list(let innerType):
      return innerType.namedType
    case .scalar, .object:
      return self
    }
  }
}

public struct GraphQLBooleanCondition: GraphQLSelection {
  let variableName: String
  let inverted: Bool
  let selections: [GraphQLSelection]
  
  public init(variableName: String, inverted: Bool, selections: [GraphQLSelection]) {
    self.variableName = variableName
    self.inverted = inverted;
    self.selections = selections;
  }
}

public struct GraphQLTypeCondition: GraphQLSelection {
  let possibleTypes: [String]
  let selections: [GraphQLSelection]
  
  public init(possibleTypes: [String], selections: [GraphQLSelection]) {
    self.possibleTypes = possibleTypes
    self.selections = selections;
  }
}

public struct GraphQLFragmentSpread: GraphQLSelection {
  let fragment: GraphQLFragment.Type
  
  public init(_ fragment: GraphQLFragment.Type) {
    self.fragment = fragment
  }
}

public struct GraphQLTypeCase: GraphQLSelection {
  let variants: [String: [GraphQLSelection]]
  let \`default\`: [GraphQLSelection]
  
  public init(variants: [String: [GraphQLSelection]], default: [GraphQLSelection]) {
    self.variants = variants
    self.default = \`default\`;
  }
}

public typealias JSONObject = [String: Any]

public protocol JSONDecodable {
  init(jsonValue value: Any) throws
}

public protocol JSONEncodable: GraphQLInputValue {
  var jsonValue: Any { get }
}

public enum JSONDecodingError: Error, LocalizedError {
  case missingValue
  case nullValue
  case wrongType
  case couldNotConvert(value: Any, to: Any.Type)
  
  public var errorDescription: String? {
    switch self {
    case .missingValue:
      return \\"Missing value\\"
    case .nullValue:
      return \\"Unexpected null value\\"
    case .wrongType:
      return \\"Wrong type\\"
    case .couldNotConvert(let value, let expectedType):
      return \\"Could not convert \\\\\\"\\\\(value)\\\\\\" to \\\\(expectedType)\\"
    }
  }
}

extension String: JSONDecodable, JSONEncodable {
  public init(jsonValue value: Any) throws {
    guard let string = value as? String else {
      throw JSONDecodingError.couldNotConvert(value: value, to: String.self)
    }
    self = string
  }

  public var jsonValue: Any {
    return self
  }
}

extension Int: JSONDecodable, JSONEncodable {
  public init(jsonValue value: Any) throws {
    guard let number = value as? NSNumber else {
      throw JSONDecodingError.couldNotConvert(value: value, to: Int.self)
    }
    self = number.intValue
  }

  public var jsonValue: Any {
    return self
  }
}

extension Float: JSONDecodable, JSONEncodable {
  public init(jsonValue value: Any) throws {
    guard let number = value as? NSNumber else {
      throw JSONDecodingError.couldNotConvert(value: value, to: Float.self)
    }
    self = number.floatValue
  }

  public var jsonValue: Any {
    return self
  }
}

extension Double: JSONDecodable, JSONEncodable {
  public init(jsonValue value: Any) throws {
    guard let number = value as? NSNumber else {
      throw JSONDecodingError.couldNotConvert(value: value, to: Double.self)
    }
    self = number.doubleValue
  }

  public var jsonValue: Any {
    return self
  }
}

extension Bool: JSONDecodable, JSONEncodable {
  public init(jsonValue value: Any) throws {
    guard let bool = value as? Bool else {
        throw JSONDecodingError.couldNotConvert(value: value, to: Bool.self)
    }
    self = bool
  }

  public var jsonValue: Any {
    return self
  }
}

extension RawRepresentable where RawValue: JSONDecodable {
  public init(jsonValue value: Any) throws {
    let rawValue = try RawValue(jsonValue: value)
    if let tempSelf = Self(rawValue: rawValue) {
      self = tempSelf
    } else {
      throw JSONDecodingError.couldNotConvert(value: value, to: Self.self)
    }
  }
}

extension RawRepresentable where RawValue: JSONEncodable {
  public var jsonValue: Any {
    return rawValue.jsonValue
  }
}

extension Optional where Wrapped: JSONDecodable {
  public init(jsonValue value: Any) throws {
    if value is NSNull {
      self = .none
    } else {
      self = .some(try Wrapped(jsonValue: value))
    }
  }
}

extension Optional: JSONEncodable {
  public var jsonValue: Any {
    switch self {
    case .none:
      return NSNull()
    case .some(let wrapped as JSONEncodable):
      return wrapped.jsonValue
    default:
      fatalError(\\"Optional is only JSONEncodable if Wrapped is\\")
    }
  }
}

extension Dictionary: JSONEncodable {
  public var jsonValue: Any {
    return jsonObject
  }
  
  public var jsonObject: JSONObject {
    var jsonObject = JSONObject(minimumCapacity: count)
    for (key, value) in self {
      if case let (key as String, value as JSONEncodable) = (key, value) {
        jsonObject[key] = value.jsonValue
      } else {
        fatalError(\\"Dictionary is only JSONEncodable if Value is (and if Key is String)\\")
      }
    }
    return jsonObject
  }
}

extension Array: JSONEncodable {
  public var jsonValue: Any {
    return map() { element -> (Any) in
      if case let element as JSONEncodable = element {
        return element.jsonValue
      } else {
        fatalError(\\"Array is only JSONEncodable if Element is\\")
      }
    }
  }
}

extension URL: JSONDecodable, JSONEncodable {
  public init(jsonValue value: Any) throws {
    guard let string = value as? String else {
      throw JSONDecodingError.couldNotConvert(value: value, to: URL.self)
    }
    self.init(string: string)!
  }

  public var jsonValue: Any {
    return self.absoluteString
  }
}

extension Dictionary {
  static func += (lhs: inout Dictionary, rhs: Dictionary) {
    lhs.merge(rhs) { (_, new) in new }
  }
}

#elseif canImport(AWSAppSync)
import AWSAppSync
#endif"
`;

exports[`Swift code generation #initializerDeclarationForProperties() should generate initializer for a property 1`] = `
"public init(episode: Episode) {
  self.episode = episode
}"
`;

exports[`Swift code generation #initializerDeclarationForProperties() should generate initializer for an optional property 1`] = `
"public init(episode: Episode? = nil) {
  self.episode = episode
}"
`;

exports[`Swift code generation #initializerDeclarationForProperties() should generate initializer for multiple properties 1`] = `
"public init(episode: Episode? = nil, scene: String? = nil) {
  self.episode = episode
  self.scene = scene
}"
`;

exports[`Swift code generation #structDeclarationForFragment() should generate a struct declaration for a fragment that includes a fragment spread 1`] = `
"public struct HeroDetails: GraphQLFragment {
  public static let fragmentString =
    \\"fragment HeroDetails on Character {\\\\n  name\\\\n  ...MoreHeroDetails\\\\n}\\"

  public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

  public static let selections: [GraphQLSelection] = [
    GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
    GraphQLField(\\"appearsIn\\", type: .nonNull(.list(.scalar(Episode.self)))),
  ]

  public var snapshot: Snapshot

  public init(snapshot: Snapshot) {
    self.snapshot = snapshot
  }

  public static func makeHuman(name: String, appearsIn: [Episode?]) -> HeroDetails {
    return HeroDetails(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name, \\"appearsIn\\": appearsIn])
  }

  public static func makeDroid(name: String, appearsIn: [Episode?]) -> HeroDetails {
    return HeroDetails(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name, \\"appearsIn\\": appearsIn])
  }

  /// The name of the character
  public var name: String {
    get {
      return snapshot[\\"name\\"]! as! String
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"name\\")
    }
  }

  /// The movies this character appears in
  public var appearsIn: [Episode?] {
    get {
      return snapshot[\\"appearsIn\\"]! as! [Episode?]
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"appearsIn\\")
    }
  }

  public var fragments: Fragments {
    get {
      return Fragments(snapshot: snapshot)
    }
    set {
      snapshot += newValue.snapshot
    }
  }

  public struct Fragments {
    public var snapshot: Snapshot

    public var moreHeroDetails: MoreHeroDetails {
      get {
        return MoreHeroDetails(snapshot: snapshot)
      }
      set {
        snapshot += newValue.snapshot
      }
    }
  }
}"
`;

exports[`Swift code generation #structDeclarationForFragment() should generate a struct declaration for a fragment with a concrete type condition 1`] = `
"public struct DroidDetails: GraphQLFragment {
  public static let fragmentString =
    \\"fragment DroidDetails on Droid {\\\\n  name\\\\n  primaryFunction\\\\n}\\"

  public static let possibleTypes = [\\"Droid\\"]

  public static let selections: [GraphQLSelection] = [
    GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
    GraphQLField(\\"primaryFunction\\", type: .scalar(String.self)),
  ]

  public var snapshot: Snapshot

  public init(snapshot: Snapshot) {
    self.snapshot = snapshot
  }

  public init(name: String, primaryFunction: String? = nil) {
    self.init(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name, \\"primaryFunction\\": primaryFunction])
  }

  /// What others call this droid
  public var name: String {
    get {
      return snapshot[\\"name\\"]! as! String
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"name\\")
    }
  }

  /// This droid's primary function
  public var primaryFunction: String? {
    get {
      return snapshot[\\"primaryFunction\\"] as? String
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"primaryFunction\\")
    }
  }
}"
`;

exports[`Swift code generation #structDeclarationForFragment() should generate a struct declaration for a fragment with a subselection 1`] = `
"public struct HeroDetails: GraphQLFragment {
  public static let fragmentString =
    \\"fragment HeroDetails on Character {\\\\n  name\\\\n  friends {\\\\n    name\\\\n  }\\\\n}\\"

  public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

  public static let selections: [GraphQLSelection] = [
    GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
    GraphQLField(\\"friends\\", type: .list(.object(Friend.selections))),
  ]

  public var snapshot: Snapshot

  public init(snapshot: Snapshot) {
    self.snapshot = snapshot
  }

  public static func makeHuman(name: String, friends: [Friend?]? = nil) -> HeroDetails {
    return HeroDetails(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name, \\"friends\\": friends.flatMap { $0.map { $0.flatMap { $0.snapshot } } }])
  }

  public static func makeDroid(name: String, friends: [Friend?]? = nil) -> HeroDetails {
    return HeroDetails(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name, \\"friends\\": friends.flatMap { $0.map { $0.flatMap { $0.snapshot } } }])
  }

  /// The name of the character
  public var name: String {
    get {
      return snapshot[\\"name\\"]! as! String
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"name\\")
    }
  }

  /// The friends of the character, or an empty list if they have none
  public var friends: [Friend?]? {
    get {
      return (snapshot[\\"friends\\"] as? [Snapshot?]).flatMap { $0.map { $0.flatMap { Friend(snapshot: $0) } } }
    }
    set {
      snapshot.updateValue(newValue.flatMap { $0.map { $0.flatMap { $0.snapshot } } }, forKey: \\"friends\\")
    }
  }

  public struct Friend: GraphQLSelectionSet {
    public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

    public static let selections: [GraphQLSelection] = [
      GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
    ]

    public var snapshot: Snapshot

    public init(snapshot: Snapshot) {
      self.snapshot = snapshot
    }

    public static func makeHuman(name: String) -> Friend {
      return Friend(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name])
    }

    public static func makeDroid(name: String) -> Friend {
      return Friend(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
    }

    /// The name of the character
    public var name: String {
      get {
        return snapshot[\\"name\\"]! as! String
      }
      set {
        snapshot.updateValue(newValue, forKey: \\"name\\")
      }
    }
  }
}"
`;

exports[`Swift code generation #structDeclarationForFragment() should generate a struct declaration for a fragment with an abstract type condition 1`] = `
"public struct HeroDetails: GraphQLFragment {
  public static let fragmentString =
    \\"fragment HeroDetails on Character {\\\\n  name\\\\n  appearsIn\\\\n}\\"

  public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

  public static let selections: [GraphQLSelection] = [
    GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
    GraphQLField(\\"appearsIn\\", type: .nonNull(.list(.scalar(Episode.self)))),
  ]

  public var snapshot: Snapshot

  public init(snapshot: Snapshot) {
    self.snapshot = snapshot
  }

  public static func makeHuman(name: String, appearsIn: [Episode?]) -> HeroDetails {
    return HeroDetails(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name, \\"appearsIn\\": appearsIn])
  }

  public static func makeDroid(name: String, appearsIn: [Episode?]) -> HeroDetails {
    return HeroDetails(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name, \\"appearsIn\\": appearsIn])
  }

  /// The name of the character
  public var name: String {
    get {
      return snapshot[\\"name\\"]! as! String
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"name\\")
    }
  }

  /// The movies this character appears in
  public var appearsIn: [Episode?] {
    get {
      return snapshot[\\"appearsIn\\"]! as! [Episode?]
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"appearsIn\\")
    }
  }
}"
`;

exports[`Swift code generation #structDeclarationForSelectionSet() should escape reserved keywords in a struct declaration for a selection set 1`] = `
"public struct Hero: GraphQLSelectionSet {
  public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

  public static let selections: [GraphQLSelection] = [
    GraphQLField(\\"name\\", alias: \\"private\\", type: .nonNull(.scalar(String.self))),
  ]

  public var snapshot: Snapshot

  public init(snapshot: Snapshot) {
    self.snapshot = snapshot
  }

  public static func makeHuman(\`private\`: String) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Human\\", \\"private\\": \`private\`])
  }

  public static func makeDroid(\`private\`: String) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Droid\\", \\"private\\": \`private\`])
  }

  /// The name of the character
  public var \`private\`: String {
    get {
      return snapshot[\\"private\\"]! as! String
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"private\\")
    }
  }
}"
`;

exports[`Swift code generation #structDeclarationForSelectionSet() should generate a nested struct declaration for a selection set with subselections 1`] = `
"public struct Hero: GraphQLSelectionSet {
  public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

  public static let selections: [GraphQLSelection] = [
    GraphQLField(\\"friends\\", type: .list(.object(Friend.selections))),
  ]

  public var snapshot: Snapshot

  public init(snapshot: Snapshot) {
    self.snapshot = snapshot
  }

  public static func makeHuman(friends: [Friend?]? = nil) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Human\\", \\"friends\\": friends.flatMap { $0.map { $0.flatMap { $0.snapshot } } }])
  }

  public static func makeDroid(friends: [Friend?]? = nil) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Droid\\", \\"friends\\": friends.flatMap { $0.map { $0.flatMap { $0.snapshot } } }])
  }

  /// The friends of the character, or an empty list if they have none
  public var friends: [Friend?]? {
    get {
      return (snapshot[\\"friends\\"] as? [Snapshot?]).flatMap { $0.map { $0.flatMap { Friend(snapshot: $0) } } }
    }
    set {
      snapshot.updateValue(newValue.flatMap { $0.map { $0.flatMap { $0.snapshot } } }, forKey: \\"friends\\")
    }
  }

  public struct Friend: GraphQLSelectionSet {
    public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

    public static let selections: [GraphQLSelection] = [
      GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
    ]

    public var snapshot: Snapshot

    public init(snapshot: Snapshot) {
      self.snapshot = snapshot
    }

    public static func makeHuman(name: String) -> Friend {
      return Friend(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name])
    }

    public static func makeDroid(name: String) -> Friend {
      return Friend(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
    }

    /// The name of the character
    public var name: String {
      get {
        return snapshot[\\"name\\"]! as! String
      }
      set {
        snapshot.updateValue(newValue, forKey: \\"name\\")
      }
    }
  }
}"
`;

exports[`Swift code generation #structDeclarationForSelectionSet() should generate a struct declaration for a fragment spread nested in an inline fragment 1`] = `
"public struct Hero: GraphQLSelectionSet {
  public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

  public static let selections: [GraphQLSelection] = [
    GraphQLTypeCase(
      variants: [\\"Droid\\": AsDroid.selections],
      default: [
        GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
      ]
    )
  ]

  public var snapshot: Snapshot

  public init(snapshot: Snapshot) {
    self.snapshot = snapshot
  }

  public static func makeHuman(name: String) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name])
  }

  public static func makeDroid(name: String) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
  }

  /// The name of the character
  public var name: String {
    get {
      return snapshot[\\"name\\"]! as! String
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"name\\")
    }
  }

  public var asDroid: AsDroid? {
    get {
      if !AsDroid.possibleTypes.contains(__typename) { return nil }
      return AsDroid(snapshot: snapshot)
    }
    set {
      guard let newValue = newValue else { return }
      snapshot = newValue.snapshot
    }
  }

  public struct AsDroid: GraphQLSelectionSet {
    public static let possibleTypes = [\\"Droid\\"]

    public static let selections: [GraphQLSelection] = [
      GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
      GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
    ]

    public var snapshot: Snapshot

    public init(snapshot: Snapshot) {
      self.snapshot = snapshot
    }

    public init(name: String) {
      self.init(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
    }

    /// What others call this droid
    public var name: String {
      get {
        return snapshot[\\"name\\"]! as! String
      }
      set {
        snapshot.updateValue(newValue, forKey: \\"name\\")
      }
    }

    public var fragments: Fragments {
      get {
        return Fragments(snapshot: snapshot)
      }
      set {
        snapshot += newValue.snapshot
      }
    }

    public struct Fragments {
      public var snapshot: Snapshot

      public var heroDetails: HeroDetails {
        get {
          return HeroDetails(snapshot: snapshot)
        }
        set {
          snapshot += newValue.snapshot
        }
      }
    }
  }
}"
`;

exports[`Swift code generation #structDeclarationForSelectionSet() should generate a struct declaration for a selection set 1`] = `
"public struct Hero: GraphQLSelectionSet {
  public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

  public static let selections: [GraphQLSelection] = [
    GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
  ]

  public var snapshot: Snapshot

  public init(snapshot: Snapshot) {
    self.snapshot = snapshot
  }

  public static func makeHuman(name: String) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name])
  }

  public static func makeDroid(name: String) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
  }

  /// The name of the character
  public var name: String {
    get {
      return snapshot[\\"name\\"]! as! String
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"name\\")
    }
  }
}"
`;

exports[`Swift code generation #structDeclarationForSelectionSet() should generate a struct declaration for a selection set with a conditional field 1`] = `
"public struct Hero: GraphQLSelectionSet {
  public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

  public static let selections: [GraphQLSelection] = [
    GraphQLBooleanCondition(variableName: \\"includeName\\", inverted: false, selections: [
      GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
    ]),
  ]

  public var snapshot: Snapshot

  public init(snapshot: Snapshot) {
    self.snapshot = snapshot
  }

  public static func makeHuman(name: String? = nil) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name])
  }

  public static func makeDroid(name: String? = nil) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
  }

  /// The name of the character
  public var name: String? {
    get {
      return snapshot[\\"name\\"] as? String
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"name\\")
    }
  }
}"
`;

exports[`Swift code generation #structDeclarationForSelectionSet() should generate a struct declaration for a selection set with a fragment spread that matches the parent type 1`] = `
"public struct Hero: GraphQLSelectionSet {
  public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

  public static let selections: [GraphQLSelection] = [
    GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
    GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
  ]

  public var snapshot: Snapshot

  public init(snapshot: Snapshot) {
    self.snapshot = snapshot
  }

  public static func makeHuman(name: String) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name])
  }

  public static func makeDroid(name: String) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
  }

  /// The name of the character
  public var name: String {
    get {
      return snapshot[\\"name\\"]! as! String
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"name\\")
    }
  }

  public var fragments: Fragments {
    get {
      return Fragments(snapshot: snapshot)
    }
    set {
      snapshot += newValue.snapshot
    }
  }

  public struct Fragments {
    public var snapshot: Snapshot

    public var heroDetails: HeroDetails {
      get {
        return HeroDetails(snapshot: snapshot)
      }
      set {
        snapshot += newValue.snapshot
      }
    }
  }
}"
`;

exports[`Swift code generation #structDeclarationForSelectionSet() should generate a struct declaration for a selection set with a fragment spread with a more specific type condition 1`] = `
"public struct Hero: GraphQLSelectionSet {
  public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

  public static let selections: [GraphQLSelection] = [
    GraphQLTypeCase(
      variants: [\\"Droid\\": AsDroid.selections],
      default: [
        GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
      ]
    )
  ]

  public var snapshot: Snapshot

  public init(snapshot: Snapshot) {
    self.snapshot = snapshot
  }

  public static func makeHuman(name: String) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name])
  }

  public static func makeDroid(name: String) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
  }

  /// The name of the character
  public var name: String {
    get {
      return snapshot[\\"name\\"]! as! String
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"name\\")
    }
  }

  public var fragments: Fragments {
    get {
      return Fragments(snapshot: snapshot)
    }
    set {
      snapshot += newValue.snapshot
    }
  }

  public struct Fragments {
    public var snapshot: Snapshot

    public var droidDetails: DroidDetails? {
      get {
        if !DroidDetails.possibleTypes.contains(snapshot[\\"__typename\\"]! as! String) { return nil }
        return DroidDetails(snapshot: snapshot)
      }
      set {
        guard let newValue = newValue else { return }
        snapshot += newValue.snapshot
      }
    }
  }

  public var asDroid: AsDroid? {
    get {
      if !AsDroid.possibleTypes.contains(__typename) { return nil }
      return AsDroid(snapshot: snapshot)
    }
    set {
      guard let newValue = newValue else { return }
      snapshot = newValue.snapshot
    }
  }

  public struct AsDroid: GraphQLSelectionSet {
    public static let possibleTypes = [\\"Droid\\"]

    public static let selections: [GraphQLSelection] = [
      GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
      GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
    ]

    public var snapshot: Snapshot

    public init(snapshot: Snapshot) {
      self.snapshot = snapshot
    }

    public init(name: String) {
      self.init(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name])
    }

    /// What others call this droid
    public var name: String {
      get {
        return snapshot[\\"name\\"]! as! String
      }
      set {
        snapshot.updateValue(newValue, forKey: \\"name\\")
      }
    }

    public var fragments: Fragments {
      get {
        return Fragments(snapshot: snapshot)
      }
      set {
        snapshot += newValue.snapshot
      }
    }

    public struct Fragments {
      public var snapshot: Snapshot

      public var droidDetails: DroidDetails {
        get {
          return DroidDetails(snapshot: snapshot)
        }
        set {
          snapshot += newValue.snapshot
        }
      }
    }
  }
}"
`;

exports[`Swift code generation #structDeclarationForSelectionSet() should generate a struct declaration for a selection set with an inline fragment 1`] = `
"public struct Hero: GraphQLSelectionSet {
  public static let possibleTypes = [\\"Human\\", \\"Droid\\"]

  public static let selections: [GraphQLSelection] = [
    GraphQLTypeCase(
      variants: [\\"Droid\\": AsDroid.selections],
      default: [
        GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
      ]
    )
  ]

  public var snapshot: Snapshot

  public init(snapshot: Snapshot) {
    self.snapshot = snapshot
  }

  public static func makeHuman(name: String) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Human\\", \\"name\\": name])
  }

  public static func makeDroid(name: String, primaryFunction: String? = nil) -> Hero {
    return Hero(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name, \\"primaryFunction\\": primaryFunction])
  }

  /// The name of the character
  public var name: String {
    get {
      return snapshot[\\"name\\"]! as! String
    }
    set {
      snapshot.updateValue(newValue, forKey: \\"name\\")
    }
  }

  public var asDroid: AsDroid? {
    get {
      if !AsDroid.possibleTypes.contains(__typename) { return nil }
      return AsDroid(snapshot: snapshot)
    }
    set {
      guard let newValue = newValue else { return }
      snapshot = newValue.snapshot
    }
  }

  public struct AsDroid: GraphQLSelectionSet {
    public static let possibleTypes = [\\"Droid\\"]

    public static let selections: [GraphQLSelection] = [
      GraphQLField(\\"name\\", type: .nonNull(.scalar(String.self))),
      GraphQLField(\\"primaryFunction\\", type: .scalar(String.self)),
    ]

    public var snapshot: Snapshot

    public init(snapshot: Snapshot) {
      self.snapshot = snapshot
    }

    public init(name: String, primaryFunction: String? = nil) {
      self.init(snapshot: [\\"__typename\\": \\"Droid\\", \\"name\\": name, \\"primaryFunction\\": primaryFunction])
    }

    /// What others call this droid
    public var name: String {
      get {
        return snapshot[\\"name\\"]! as! String
      }
      set {
        snapshot.updateValue(newValue, forKey: \\"name\\")
      }
    }

    /// This droid's primary function
    public var primaryFunction: String? {
      get {
        return snapshot[\\"primaryFunction\\"] as? String
      }
      set {
        snapshot.updateValue(newValue, forKey: \\"primaryFunction\\")
      }
    }
  }
}"
`;

exports[`Swift code generation #typeDeclarationForGraphQLType() should escape identifiers in cases of enum declaration for a GraphQLEnumType 1`] = `
"public enum AlbumPrivacies: RawRepresentable, Equatable, JSONDecodable, JSONEncodable {
  public typealias RawValue = String
  case \`public\`
  case \`private\`
  /// Auto generated constant for unknown enum values
  case unknown(RawValue)

  public init?(rawValue: RawValue) {
    switch rawValue {
      case \\"PUBLIC\\": self = .public
      case \\"PRIVATE\\": self = .private
      default: self = .unknown(rawValue)
    }
  }

  public var rawValue: RawValue {
    switch self {
      case .public: return \\"PUBLIC\\"
      case .private: return \\"PRIVATE\\"
      case .unknown(let value): return value
    }
  }

  public static func == (lhs: AlbumPrivacies, rhs: AlbumPrivacies) -> Bool {
    switch (lhs, rhs) {
      case (.public, .public): return true
      case (.private, .private): return true
      case (.unknown(let lhsValue), .unknown(let rhsValue)): return lhsValue == rhsValue
      default: return false
    }
  }
}"
`;

exports[`Swift code generation #typeDeclarationForGraphQLType() should generate a struct declaration for a GraphQLInputObjectType 1`] = `
"/// The input object sent when someone is creating a new review
public struct ReviewInput: GraphQLMapConvertible {
  public var graphQLMap: GraphQLMap

  public init(stars: Int, commentary: String? = nil, favoriteColor: ColorInput? = nil) {
    graphQLMap = [\\"stars\\": stars, \\"commentary\\": commentary, \\"favorite_color\\": favoriteColor]
  }

  /// 0-5 stars
  public var stars: Int {
    get {
      return graphQLMap[\\"stars\\"] as! Int
    }
    set {
      graphQLMap.updateValue(newValue, forKey: \\"stars\\")
    }
  }

  /// Comment about the movie, optional
  public var commentary: String? {
    get {
      return graphQLMap[\\"commentary\\"] as! String?
    }
    set {
      graphQLMap.updateValue(newValue, forKey: \\"commentary\\")
    }
  }

  /// Favorite color, optional
  public var favoriteColor: ColorInput? {
    get {
      return graphQLMap[\\"favorite_color\\"] as! ColorInput?
    }
    set {
      graphQLMap.updateValue(newValue, forKey: \\"favorite_color\\")
    }
  }
}"
`;

exports[`Swift code generation #typeDeclarationForGraphQLType() should generate an enum declaration for a GraphQLEnumType 1`] = `
"/// The episodes in the Star Wars trilogy
public enum Episode: RawRepresentable, Equatable, JSONDecodable, JSONEncodable {
  public typealias RawValue = String
  /// Star Wars Episode IV: A New Hope, released in 1977.
  case newhope
  /// Star Wars Episode V: The Empire Strikes Back, released in 1980.
  case empire
  /// Star Wars Episode VI: Return of the Jedi, released in 1983.
  case jedi
  /// Auto generated constant for unknown enum values
  case unknown(RawValue)

  public init?(rawValue: RawValue) {
    switch rawValue {
      case \\"NEWHOPE\\": self = .newhope
      case \\"EMPIRE\\": self = .empire
      case \\"JEDI\\": self = .jedi
      default: self = .unknown(rawValue)
    }
  }

  public var rawValue: RawValue {
    switch self {
      case .newhope: return \\"NEWHOPE\\"
      case .empire: return \\"EMPIRE\\"
      case .jedi: return \\"JEDI\\"
      case .unknown(let value): return value
    }
  }

  public static func == (lhs: Episode, rhs: Episode) -> Bool {
    switch (lhs, rhs) {
      case (.newhope, .newhope): return true
      case (.empire, .empire): return true
      case (.jedi, .jedi): return true
      case (.unknown(let lhsValue), .unknown(let rhsValue)): return lhsValue == rhsValue
      default: return false
    }
  }
}"
`;
