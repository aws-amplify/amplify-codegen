// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AppSyncModelVisitor Model with Auth should generate class with custom claims 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.AuthStrategy;
import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.ModelOperation;
import com.amplifyframework.core.model.annotations.AuthRule;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the customClaim type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"customClaims\\", authRules = {
  @AuthRule(allow = AuthStrategy.OWNER, ownerField = \\"owner\\", identityClaim = \\"user_id\\", operations = { ModelOperation.CREATE, ModelOperation.UPDATE, ModelOperation.DELETE, ModelOperation.READ })
})
public final class customClaim implements Model {
  public static final QueryField ID = field(\\"customClaim\\", \\"id\\");
  public static final QueryField NAME = field(\\"customClaim\\", \\"name\\");
  public static final QueryField BAR = field(\\"customClaim\\", \\"bar\\");
  public static final QueryField CREATED_AT = field(\\"customClaim\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"customClaim\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String name;
  private final @ModelField(targetType=\\"String\\") String bar;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public String getBar() {
      return bar;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private customClaim(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.bar = bar;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      customClaim customClaim = (customClaim) obj;
      return ObjectsCompat.equals(getId(), customClaim.getId()) &&
              ObjectsCompat.equals(getName(), customClaim.getName()) &&
              ObjectsCompat.equals(getBar(), customClaim.getBar()) &&
              ObjectsCompat.equals(getCreatedAt(), customClaim.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), customClaim.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getBar())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"customClaim {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"bar=\\" + String.valueOf(getBar()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static customClaim justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new customClaim(
      id,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      bar,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    customClaim build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep name(String name);
    BuildStep bar(String bar);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String name;
    private String bar;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public customClaim build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new customClaim(
          id,
          name,
          bar,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep name(String name) {
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep bar(String bar) {
        this.bar = bar;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .bar(bar)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder bar(String bar) {
      return (CopyOfBuilder) super.bar(bar);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Model with Auth should generate class with custom group claims 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.AuthStrategy;
import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.ModelOperation;
import com.amplifyframework.core.model.annotations.AuthRule;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the customClaim type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"customClaims\\", authRules = {
  @AuthRule(allow = AuthStrategy.GROUPS, groupClaim = \\"user_groups\\", groups = { \\"Moderator\\" }, operations = { ModelOperation.CREATE, ModelOperation.UPDATE, ModelOperation.DELETE, ModelOperation.READ })
})
public final class customClaim implements Model {
  public static final QueryField ID = field(\\"customClaim\\", \\"id\\");
  public static final QueryField NAME = field(\\"customClaim\\", \\"name\\");
  public static final QueryField BAR = field(\\"customClaim\\", \\"bar\\");
  public static final QueryField CREATED_AT = field(\\"customClaim\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"customClaim\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String name;
  private final @ModelField(targetType=\\"String\\") String bar;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public String getBar() {
      return bar;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private customClaim(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.bar = bar;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      customClaim customClaim = (customClaim) obj;
      return ObjectsCompat.equals(getId(), customClaim.getId()) &&
              ObjectsCompat.equals(getName(), customClaim.getName()) &&
              ObjectsCompat.equals(getBar(), customClaim.getBar()) &&
              ObjectsCompat.equals(getCreatedAt(), customClaim.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), customClaim.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getBar())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"customClaim {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"bar=\\" + String.valueOf(getBar()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static customClaim justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new customClaim(
      id,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      bar,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    customClaim build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep name(String name);
    BuildStep bar(String bar);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String name;
    private String bar;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public customClaim build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new customClaim(
          id,
          name,
          bar,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep name(String name) {
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep bar(String bar) {
        this.bar = bar;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .bar(bar)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder bar(String bar) {
      return (CopyOfBuilder) super.bar(bar);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Model with Auth should generate class with default field auth 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.AuthStrategy;
import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.ModelOperation;
import com.amplifyframework.core.model.annotations.AuthRule;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the Employee type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"Employees\\", authRules = {
  @AuthRule(allow = AuthStrategy.OWNER, ownerField = \\"owner\\", identityClaim = \\"cognito:username\\", operations = { ModelOperation.CREATE, ModelOperation.UPDATE, ModelOperation.DELETE, ModelOperation.READ }),
  @AuthRule(allow = AuthStrategy.GROUPS, groupClaim = \\"cognito:groups\\", groups = { \\"Admins\\" }, operations = { ModelOperation.CREATE, ModelOperation.UPDATE, ModelOperation.DELETE, ModelOperation.READ })
})
public final class Employee implements Model {
  public static final QueryField ID = field(\\"Employee\\", \\"id\\");
  public static final QueryField NAME = field(\\"Employee\\", \\"name\\");
  public static final QueryField ADDRESS = field(\\"Employee\\", \\"address\\");
  public static final QueryField SSN = field(\\"Employee\\", \\"ssn\\");
  public static final QueryField CREATED_AT = field(\\"Employee\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"Employee\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\", isRequired = true) String name;
  private final @ModelField(targetType=\\"String\\", isRequired = true) String address;
  private final @ModelField(targetType=\\"String\\", authRules = {
    @AuthRule(allow = AuthStrategy.OWNER, ownerField = \\"owner\\", identityClaim = \\"cognito:username\\", operations = { ModelOperation.CREATE, ModelOperation.UPDATE, ModelOperation.DELETE, ModelOperation.READ })
  }) String ssn;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public String getAddress() {
      return address;
  }
  
  public String getSsn() {
      return ssn;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private Employee(String id, String name, String address, String ssn, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.address = address;
    this.ssn = ssn;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      Employee employee = (Employee) obj;
      return ObjectsCompat.equals(getId(), employee.getId()) &&
              ObjectsCompat.equals(getName(), employee.getName()) &&
              ObjectsCompat.equals(getAddress(), employee.getAddress()) &&
              ObjectsCompat.equals(getSsn(), employee.getSsn()) &&
              ObjectsCompat.equals(getCreatedAt(), employee.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), employee.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getAddress())
      .append(getSsn())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"Employee {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"address=\\" + String.valueOf(getAddress()) + \\", \\")
      .append(\\"ssn=\\" + String.valueOf(getSsn()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static NameStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static Employee justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new Employee(
      id,
      null,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      address,
      ssn,
      createdAt,
      updatedAt);
  }
  public interface NameStep {
    AddressStep name(String name);
  }
  

  public interface AddressStep {
    BuildStep address(String address);
  }
  

  public interface BuildStep {
    Employee build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep ssn(String ssn);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements NameStep, AddressStep, BuildStep {
    private String id;
    private String name;
    private String address;
    private String ssn;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public Employee build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new Employee(
          id,
          name,
          address,
          ssn,
          createdAt,
          updatedAt);
    }
    
    @Override
     public AddressStep name(String name) {
        Objects.requireNonNull(name);
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep address(String address) {
        Objects.requireNonNull(address);
        this.address = address;
        return this;
    }
    
    @Override
     public BuildStep ssn(String ssn) {
        this.ssn = ssn;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, String address, String ssn, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .address(address)
        .ssn(ssn)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder address(String address) {
      return (CopyOfBuilder) super.address(address);
    }
    
    @Override
     public CopyOfBuilder ssn(String ssn) {
      return (CopyOfBuilder) super.ssn(ssn);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Model with Auth should generate class with dynamic groups 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.AuthStrategy;
import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.ModelOperation;
import com.amplifyframework.core.model.annotations.AuthRule;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the dynamicGroups type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"dynamicGroups\\", authRules = {
  @AuthRule(allow = AuthStrategy.GROUPS, groupClaim = \\"cognito:groups\\", groupsField = \\"groups\\", operations = { ModelOperation.CREATE, ModelOperation.UPDATE, ModelOperation.DELETE, ModelOperation.READ })
})
public final class dynamicGroups implements Model {
  public static final QueryField ID = field(\\"dynamicGroups\\", \\"id\\");
  public static final QueryField NAME = field(\\"dynamicGroups\\", \\"name\\");
  public static final QueryField BAR = field(\\"dynamicGroups\\", \\"bar\\");
  public static final QueryField CREATED_AT = field(\\"dynamicGroups\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"dynamicGroups\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String name;
  private final @ModelField(targetType=\\"String\\") String bar;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public String getBar() {
      return bar;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private dynamicGroups(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.bar = bar;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      dynamicGroups dynamicGroups = (dynamicGroups) obj;
      return ObjectsCompat.equals(getId(), dynamicGroups.getId()) &&
              ObjectsCompat.equals(getName(), dynamicGroups.getName()) &&
              ObjectsCompat.equals(getBar(), dynamicGroups.getBar()) &&
              ObjectsCompat.equals(getCreatedAt(), dynamicGroups.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), dynamicGroups.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getBar())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"dynamicGroups {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"bar=\\" + String.valueOf(getBar()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static dynamicGroups justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new dynamicGroups(
      id,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      bar,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    dynamicGroups build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep name(String name);
    BuildStep bar(String bar);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String name;
    private String bar;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public dynamicGroups build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new dynamicGroups(
          id,
          name,
          bar,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep name(String name) {
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep bar(String bar) {
        this.bar = bar;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .bar(bar)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder bar(String bar) {
      return (CopyOfBuilder) super.bar(bar);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Model with Auth should generate class with owner auth 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.AuthStrategy;
import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.ModelOperation;
import com.amplifyframework.core.model.annotations.AuthRule;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the simpleOwnerAuth type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"simpleOwnerAuths\\", authRules = {
  @AuthRule(allow = AuthStrategy.OWNER, ownerField = \\"owner\\", identityClaim = \\"cognito:username\\", operations = { ModelOperation.CREATE, ModelOperation.UPDATE, ModelOperation.DELETE, ModelOperation.READ })
})
public final class simpleOwnerAuth implements Model {
  public static final QueryField ID = field(\\"simpleOwnerAuth\\", \\"id\\");
  public static final QueryField NAME = field(\\"simpleOwnerAuth\\", \\"name\\");
  public static final QueryField BAR = field(\\"simpleOwnerAuth\\", \\"bar\\");
  public static final QueryField CREATED_AT = field(\\"simpleOwnerAuth\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"simpleOwnerAuth\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String name;
  private final @ModelField(targetType=\\"String\\") String bar;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public String getBar() {
      return bar;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private simpleOwnerAuth(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.bar = bar;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      simpleOwnerAuth simpleOwnerAuth = (simpleOwnerAuth) obj;
      return ObjectsCompat.equals(getId(), simpleOwnerAuth.getId()) &&
              ObjectsCompat.equals(getName(), simpleOwnerAuth.getName()) &&
              ObjectsCompat.equals(getBar(), simpleOwnerAuth.getBar()) &&
              ObjectsCompat.equals(getCreatedAt(), simpleOwnerAuth.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), simpleOwnerAuth.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getBar())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"simpleOwnerAuth {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"bar=\\" + String.valueOf(getBar()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static simpleOwnerAuth justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new simpleOwnerAuth(
      id,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      bar,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    simpleOwnerAuth build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep name(String name);
    BuildStep bar(String bar);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String name;
    private String bar;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public simpleOwnerAuth build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new simpleOwnerAuth(
          id,
          name,
          bar,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep name(String name) {
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep bar(String bar) {
        this.bar = bar;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .bar(bar)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder bar(String bar) {
      return (CopyOfBuilder) super.bar(bar);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Model with Auth should generate class with owner auth allowing others to read 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.AuthStrategy;
import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.ModelOperation;
import com.amplifyframework.core.model.annotations.AuthRule;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the allowRead type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"allowReads\\", authRules = {
  @AuthRule(allow = AuthStrategy.OWNER, ownerField = \\"owner\\", identityClaim = \\"cognito:username\\", operations = { ModelOperation.CREATE, ModelOperation.DELETE, ModelOperation.UPDATE })
})
public final class allowRead implements Model {
  public static final QueryField ID = field(\\"allowRead\\", \\"id\\");
  public static final QueryField NAME = field(\\"allowRead\\", \\"name\\");
  public static final QueryField BAR = field(\\"allowRead\\", \\"bar\\");
  public static final QueryField CREATED_AT = field(\\"allowRead\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"allowRead\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String name;
  private final @ModelField(targetType=\\"String\\") String bar;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public String getBar() {
      return bar;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private allowRead(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.bar = bar;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      allowRead allowRead = (allowRead) obj;
      return ObjectsCompat.equals(getId(), allowRead.getId()) &&
              ObjectsCompat.equals(getName(), allowRead.getName()) &&
              ObjectsCompat.equals(getBar(), allowRead.getBar()) &&
              ObjectsCompat.equals(getCreatedAt(), allowRead.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), allowRead.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getBar())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"allowRead {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"bar=\\" + String.valueOf(getBar()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static allowRead justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new allowRead(
      id,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      bar,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    allowRead build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep name(String name);
    BuildStep bar(String bar);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String name;
    private String bar;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public allowRead build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new allowRead(
          id,
          name,
          bar,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep name(String name) {
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep bar(String bar) {
        this.bar = bar;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .bar(bar)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder bar(String bar) {
      return (CopyOfBuilder) super.bar(bar);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Model with Auth should generate class with private authorization 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.AuthStrategy;
import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.ModelOperation;
import com.amplifyframework.core.model.annotations.AuthRule;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the privateType type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"privateTypes\\", authRules = {
  @AuthRule(allow = AuthStrategy.PRIVATE, operations = { ModelOperation.CREATE, ModelOperation.UPDATE, ModelOperation.DELETE, ModelOperation.READ })
})
public final class privateType implements Model {
  public static final QueryField ID = field(\\"privateType\\", \\"id\\");
  public static final QueryField NAME = field(\\"privateType\\", \\"name\\");
  public static final QueryField BAR = field(\\"privateType\\", \\"bar\\");
  public static final QueryField CREATED_AT = field(\\"privateType\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"privateType\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String name;
  private final @ModelField(targetType=\\"String\\") String bar;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public String getBar() {
      return bar;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private privateType(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.bar = bar;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      privateType privateType = (privateType) obj;
      return ObjectsCompat.equals(getId(), privateType.getId()) &&
              ObjectsCompat.equals(getName(), privateType.getName()) &&
              ObjectsCompat.equals(getBar(), privateType.getBar()) &&
              ObjectsCompat.equals(getCreatedAt(), privateType.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), privateType.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getBar())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"privateType {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"bar=\\" + String.valueOf(getBar()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static privateType justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new privateType(
      id,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      bar,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    privateType build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep name(String name);
    BuildStep bar(String bar);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String name;
    private String bar;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public privateType build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new privateType(
          id,
          name,
          bar,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep name(String name) {
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep bar(String bar) {
        this.bar = bar;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .bar(bar)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder bar(String bar) {
      return (CopyOfBuilder) super.bar(bar);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Model with Auth should generate class with private authorization and field auth 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.AuthStrategy;
import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.ModelOperation;
import com.amplifyframework.core.model.annotations.AuthRule;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the privateType type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"privateTypes\\", authRules = {
  @AuthRule(allow = AuthStrategy.PRIVATE, operations = { ModelOperation.CREATE, ModelOperation.UPDATE, ModelOperation.DELETE, ModelOperation.READ })
})
public final class privateType implements Model {
  public static final QueryField ID = field(\\"privateType\\", \\"id\\");
  public static final QueryField NAME = field(\\"privateType\\", \\"name\\");
  public static final QueryField BAR = field(\\"privateType\\", \\"bar\\");
  public static final QueryField CREATED_AT = field(\\"privateType\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"privateType\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String name;
  private final @ModelField(targetType=\\"String\\", authRules = {
    @AuthRule(allow = AuthStrategy.PRIVATE, operations = { ModelOperation.CREATE, ModelOperation.UPDATE })
  }) String bar;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public String getBar() {
      return bar;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private privateType(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.bar = bar;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      privateType privateType = (privateType) obj;
      return ObjectsCompat.equals(getId(), privateType.getId()) &&
              ObjectsCompat.equals(getName(), privateType.getName()) &&
              ObjectsCompat.equals(getBar(), privateType.getBar()) &&
              ObjectsCompat.equals(getCreatedAt(), privateType.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), privateType.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getBar())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"privateType {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"bar=\\" + String.valueOf(getBar()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static privateType justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new privateType(
      id,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      bar,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    privateType build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep name(String name);
    BuildStep bar(String bar);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String name;
    private String bar;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public privateType build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new privateType(
          id,
          name,
          bar,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep name(String name) {
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep bar(String bar) {
        this.bar = bar;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .bar(bar)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder bar(String bar) {
      return (CopyOfBuilder) super.bar(bar);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Model with Auth should generate class with public authorization 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.AuthStrategy;
import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.ModelOperation;
import com.amplifyframework.core.model.annotations.AuthRule;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the publicType type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"publicTypes\\", authRules = {
  @AuthRule(allow = AuthStrategy.PUBLIC, operations = { ModelOperation.CREATE, ModelOperation.UPDATE, ModelOperation.DELETE, ModelOperation.READ })
})
public final class publicType implements Model {
  public static final QueryField ID = field(\\"publicType\\", \\"id\\");
  public static final QueryField NAME = field(\\"publicType\\", \\"name\\");
  public static final QueryField BAR = field(\\"publicType\\", \\"bar\\");
  public static final QueryField CREATED_AT = field(\\"publicType\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"publicType\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String name;
  private final @ModelField(targetType=\\"String\\") String bar;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public String getBar() {
      return bar;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private publicType(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.bar = bar;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      publicType publicType = (publicType) obj;
      return ObjectsCompat.equals(getId(), publicType.getId()) &&
              ObjectsCompat.equals(getName(), publicType.getName()) &&
              ObjectsCompat.equals(getBar(), publicType.getBar()) &&
              ObjectsCompat.equals(getCreatedAt(), publicType.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), publicType.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getBar())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"publicType {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"bar=\\" + String.valueOf(getBar()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static publicType justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new publicType(
      id,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      bar,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    publicType build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep name(String name);
    BuildStep bar(String bar);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String name;
    private String bar;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public publicType build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new publicType(
          id,
          name,
          bar,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep name(String name) {
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep bar(String bar) {
        this.bar = bar;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .bar(bar)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder bar(String bar) {
      return (CopyOfBuilder) super.bar(bar);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Model with Auth should generate class with static groups 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.AuthStrategy;
import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.ModelOperation;
import com.amplifyframework.core.model.annotations.AuthRule;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the staticGroups type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"staticGroups\\", authRules = {
  @AuthRule(allow = AuthStrategy.GROUPS, groupClaim = \\"cognito:groups\\", groups = { \\"Admin\\" }, operations = { ModelOperation.CREATE, ModelOperation.UPDATE, ModelOperation.DELETE, ModelOperation.READ })
})
public final class staticGroups implements Model {
  public static final QueryField ID = field(\\"staticGroups\\", \\"id\\");
  public static final QueryField NAME = field(\\"staticGroups\\", \\"name\\");
  public static final QueryField BAR = field(\\"staticGroups\\", \\"bar\\");
  public static final QueryField CREATED_AT = field(\\"staticGroups\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"staticGroups\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String name;
  private final @ModelField(targetType=\\"String\\") String bar;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public String getBar() {
      return bar;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private staticGroups(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.bar = bar;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      staticGroups staticGroups = (staticGroups) obj;
      return ObjectsCompat.equals(getId(), staticGroups.getId()) &&
              ObjectsCompat.equals(getName(), staticGroups.getName()) &&
              ObjectsCompat.equals(getBar(), staticGroups.getBar()) &&
              ObjectsCompat.equals(getCreatedAt(), staticGroups.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), staticGroups.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getBar())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"staticGroups {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"bar=\\" + String.valueOf(getBar()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static staticGroups justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new staticGroups(
      id,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      bar,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    staticGroups build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep name(String name);
    BuildStep bar(String bar);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String name;
    private String bar;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public staticGroups build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new staticGroups(
          id,
          name,
          bar,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep name(String name) {
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep bar(String bar) {
        this.bar = bar;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .bar(bar)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder bar(String bar) {
      return (CopyOfBuilder) super.bar(bar);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Non model type should generate class for model types with non model fields 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the Landmark type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"Landmarks\\")
public final class Landmark implements Model {
  public static final QueryField ID = field(\\"Landmark\\", \\"id\\");
  public static final QueryField NAME = field(\\"Landmark\\", \\"name\\");
  public static final QueryField RATING = field(\\"Landmark\\", \\"rating\\");
  public static final QueryField LOCATION = field(\\"Landmark\\", \\"location\\");
  public static final QueryField PARKING = field(\\"Landmark\\", \\"parking\\");
  public static final QueryField CREATED_AT = field(\\"Landmark\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"Landmark\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\", isRequired = true) String name;
  private final @ModelField(targetType=\\"Int\\", isRequired = true) Integer rating;
  private final @ModelField(targetType=\\"Location\\", isRequired = true) Location location;
  private final @ModelField(targetType=\\"Location\\") Location parking;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public Integer getRating() {
      return rating;
  }
  
  public Location getLocation() {
      return location;
  }
  
  public Location getParking() {
      return parking;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private Landmark(String id, String name, Integer rating, Location location, Location parking, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.rating = rating;
    this.location = location;
    this.parking = parking;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      Landmark landmark = (Landmark) obj;
      return ObjectsCompat.equals(getId(), landmark.getId()) &&
              ObjectsCompat.equals(getName(), landmark.getName()) &&
              ObjectsCompat.equals(getRating(), landmark.getRating()) &&
              ObjectsCompat.equals(getLocation(), landmark.getLocation()) &&
              ObjectsCompat.equals(getParking(), landmark.getParking()) &&
              ObjectsCompat.equals(getCreatedAt(), landmark.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), landmark.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getRating())
      .append(getLocation())
      .append(getParking())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"Landmark {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"rating=\\" + String.valueOf(getRating()) + \\", \\")
      .append(\\"location=\\" + String.valueOf(getLocation()) + \\", \\")
      .append(\\"parking=\\" + String.valueOf(getParking()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static NameStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static Landmark justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new Landmark(
      id,
      null,
      null,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      rating,
      location,
      parking,
      createdAt,
      updatedAt);
  }
  public interface NameStep {
    RatingStep name(String name);
  }
  

  public interface RatingStep {
    LocationStep rating(Integer rating);
  }
  

  public interface LocationStep {
    BuildStep location(Location location);
  }
  

  public interface BuildStep {
    Landmark build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep parking(Location parking);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements NameStep, RatingStep, LocationStep, BuildStep {
    private String id;
    private String name;
    private Integer rating;
    private Location location;
    private Location parking;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public Landmark build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new Landmark(
          id,
          name,
          rating,
          location,
          parking,
          createdAt,
          updatedAt);
    }
    
    @Override
     public RatingStep name(String name) {
        Objects.requireNonNull(name);
        this.name = name;
        return this;
    }
    
    @Override
     public LocationStep rating(Integer rating) {
        Objects.requireNonNull(rating);
        this.rating = rating;
        return this;
    }
    
    @Override
     public BuildStep location(Location location) {
        Objects.requireNonNull(location);
        this.location = location;
        return this;
    }
    
    @Override
     public BuildStep parking(Location parking) {
        this.parking = parking;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, Integer rating, Location location, Location parking, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .rating(rating)
        .location(location)
        .parking(parking)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder rating(Integer rating) {
      return (CopyOfBuilder) super.rating(rating);
    }
    
    @Override
     public CopyOfBuilder location(Location location) {
      return (CopyOfBuilder) super.location(location);
    }
    
    @Override
     public CopyOfBuilder parking(Location parking) {
      return (CopyOfBuilder) super.parking(parking);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Non model type should generate class for non model types 1`] = `
"package com.amplifyframework.datastore.generated.model;


import androidx.core.util.ObjectsCompat;

import java.util.Objects;
import java.util.List;

/** This is an auto generated class representing the Location type in your schema. */
public final class Location {
  private final String lat;
  private final String lang;
  public String getLat() {
      return lat;
  }
  
  public String getLang() {
      return lang;
  }
  
  private Location(String lat, String lang) {
    this.lat = lat;
    this.lang = lang;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      Location location = (Location) obj;
      return ObjectsCompat.equals(getLat(), location.getLat()) &&
              ObjectsCompat.equals(getLang(), location.getLang());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getLat())
      .append(getLang())
      .toString()
      .hashCode();
  }
  
  public static LatStep builder() {
      return new Builder();
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(lat,
      lang);
  }
  public interface LatStep {
    LangStep lat(String lat);
  }
  

  public interface LangStep {
    BuildStep lang(String lang);
  }
  

  public interface BuildStep {
    Location build();
  }
  

  public static class Builder implements LatStep, LangStep, BuildStep {
    private String lat;
    private String lang;
    @Override
     public Location build() {
        
        return new Location(
          lat,
          lang);
    }
    
    @Override
     public LangStep lat(String lat) {
        Objects.requireNonNull(lat);
        this.lat = lat;
        return this;
    }
    
    @Override
     public BuildStep lang(String lang) {
        Objects.requireNonNull(lang);
        this.lang = lang;
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String lat, String lang) {
      super.lat(lat)
        .lang(lang);
    }
    
    @Override
     public CopyOfBuilder lat(String lat) {
      return (CopyOfBuilder) super.lat(lat);
    }
    
    @Override
     public CopyOfBuilder lang(String lang) {
      return (CopyOfBuilder) super.lang(lang);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor One to Many connection with no nullable and non nullable fields should generate class for many side of the connection 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.annotations.BelongsTo;
import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the task type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"tasks\\")
public final class task implements Model {
  public static final QueryField ID = field(\\"task\\", \\"id\\");
  public static final QueryField TODO = field(\\"task\\", \\"taskTodoId\\");
  public static final QueryField TIME = field(\\"task\\", \\"time\\");
  public static final QueryField CREATED_ON = field(\\"task\\", \\"createdOn\\");
  public static final QueryField CREATED_AT = field(\\"task\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"task\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"Todo\\") @BelongsTo(targetName = \\"taskTodoId\\", type = Todo.class) Todo todo;
  private final @ModelField(targetType=\\"AWSTime\\") Temporal.Time time;
  private final @ModelField(targetType=\\"AWSDate\\") Temporal.Date createdOn;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public Todo getTodo() {
      return todo;
  }
  
  public Temporal.Time getTime() {
      return time;
  }
  
  public Temporal.Date getCreatedOn() {
      return createdOn;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private task(String id, Todo todo, Temporal.Time time, Temporal.Date createdOn, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.todo = todo;
    this.time = time;
    this.createdOn = createdOn;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      task task = (task) obj;
      return ObjectsCompat.equals(getId(), task.getId()) &&
              ObjectsCompat.equals(getTodo(), task.getTodo()) &&
              ObjectsCompat.equals(getTime(), task.getTime()) &&
              ObjectsCompat.equals(getCreatedOn(), task.getCreatedOn()) &&
              ObjectsCompat.equals(getCreatedAt(), task.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), task.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getTodo())
      .append(getTime())
      .append(getCreatedOn())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"task {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"todo=\\" + String.valueOf(getTodo()) + \\", \\")
      .append(\\"time=\\" + String.valueOf(getTime()) + \\", \\")
      .append(\\"createdOn=\\" + String.valueOf(getCreatedOn()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static task justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new task(
      id,
      null,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      todo,
      time,
      createdOn,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    task build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep todo(Todo todo);
    BuildStep time(Temporal.Time time);
    BuildStep createdOn(Temporal.Date createdOn);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private Todo todo;
    private Temporal.Time time;
    private Temporal.Date createdOn;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public task build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new task(
          id,
          todo,
          time,
          createdOn,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep todo(Todo todo) {
        this.todo = todo;
        return this;
    }
    
    @Override
     public BuildStep time(Temporal.Time time) {
        this.time = time;
        return this;
    }
    
    @Override
     public BuildStep createdOn(Temporal.Date createdOn) {
        this.createdOn = createdOn;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, Todo todo, Temporal.Time time, Temporal.Date createdOn, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.todo(todo)
        .time(time)
        .createdOn(createdOn)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder todo(Todo todo) {
      return (CopyOfBuilder) super.todo(todo);
    }
    
    @Override
     public CopyOfBuilder time(Temporal.Time time) {
      return (CopyOfBuilder) super.time(time);
    }
    
    @Override
     public CopyOfBuilder createdOn(Temporal.Date createdOn) {
      return (CopyOfBuilder) super.createdOn(createdOn);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor One to Many connection with no nullable and non nullable fields should generate class for one side of the connection 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.annotations.HasMany;
import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the Todo type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"Todos\\")
public final class Todo implements Model {
  public static final QueryField ID = field(\\"Todo\\", \\"id\\");
  public static final QueryField CREATED_AT = field(\\"Todo\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"Todo\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"task\\") @HasMany(associatedWith = \\"todo\\", type = task.class) List<task> tasks = null;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public List<task> getTasks() {
      return tasks;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private Todo(String id, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      Todo todo = (Todo) obj;
      return ObjectsCompat.equals(getId(), todo.getId()) &&
              ObjectsCompat.equals(getCreatedAt(), todo.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), todo.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"Todo {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static Todo justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new Todo(
      id,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    Todo build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public Todo build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new Todo(
          id,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Should generate a class a model with all optional fields 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the SimpleModel type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"SimpleModels\\")
public final class SimpleModel implements Model {
  public static final QueryField ID = field(\\"SimpleModel\\", \\"id\\");
  public static final QueryField NAME = field(\\"SimpleModel\\", \\"name\\");
  public static final QueryField BAR = field(\\"SimpleModel\\", \\"bar\\");
  public static final QueryField CREATED_AT = field(\\"SimpleModel\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"SimpleModel\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String name;
  private final @ModelField(targetType=\\"String\\") String bar;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public String getBar() {
      return bar;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private SimpleModel(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.bar = bar;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      SimpleModel simpleModel = (SimpleModel) obj;
      return ObjectsCompat.equals(getId(), simpleModel.getId()) &&
              ObjectsCompat.equals(getName(), simpleModel.getName()) &&
              ObjectsCompat.equals(getBar(), simpleModel.getBar()) &&
              ObjectsCompat.equals(getCreatedAt(), simpleModel.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), simpleModel.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getBar())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"SimpleModel {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"bar=\\" + String.valueOf(getBar()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static SimpleModel justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new SimpleModel(
      id,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      bar,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    SimpleModel build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep name(String name);
    BuildStep bar(String bar);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String name;
    private String bar;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public SimpleModel build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new SimpleModel(
          id,
          name,
          bar,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep name(String name) {
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep bar(String bar) {
        this.bar = bar;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .bar(bar)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder bar(String bar) {
      return (CopyOfBuilder) super.bar(bar);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Should generate a class for a Model 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the SimpleModel type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"SimpleModels\\")
public final class SimpleModel implements Model {
  public static final QueryField ID = field(\\"SimpleModel\\", \\"id\\");
  public static final QueryField NAME = field(\\"SimpleModel\\", \\"name\\");
  public static final QueryField BAR = field(\\"SimpleModel\\", \\"bar\\");
  public static final QueryField CREATED_AT = field(\\"SimpleModel\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"SimpleModel\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String name;
  private final @ModelField(targetType=\\"String\\") String bar;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public String getBar() {
      return bar;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private SimpleModel(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.bar = bar;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      SimpleModel simpleModel = (SimpleModel) obj;
      return ObjectsCompat.equals(getId(), simpleModel.getId()) &&
              ObjectsCompat.equals(getName(), simpleModel.getName()) &&
              ObjectsCompat.equals(getBar(), simpleModel.getBar()) &&
              ObjectsCompat.equals(getCreatedAt(), simpleModel.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), simpleModel.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getBar())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"SimpleModel {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"bar=\\" + String.valueOf(getBar()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static SimpleModel justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new SimpleModel(
      id,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      bar,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    SimpleModel build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep name(String name);
    BuildStep bar(String bar);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String name;
    private String bar;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public SimpleModel build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new SimpleModel(
          id,
          name,
          bar,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep name(String name) {
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep bar(String bar) {
        this.bar = bar;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .bar(bar)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder bar(String bar) {
      return (CopyOfBuilder) super.bar(bar);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor Should generate a class for a Model 2`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the SimpleModel type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"SimpleModels\\")
public final class SimpleModel implements Model {
  public static final QueryField ID = field(\\"SimpleModel\\", \\"id\\");
  public static final QueryField NAME = field(\\"SimpleModel\\", \\"name\\");
  public static final QueryField BAR = field(\\"SimpleModel\\", \\"bar\\");
  public static final QueryField CREATED_AT = field(\\"SimpleModel\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"SimpleModel\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String name;
  private final @ModelField(targetType=\\"String\\") String bar;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public String getBar() {
      return bar;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private SimpleModel(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.bar = bar;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      SimpleModel simpleModel = (SimpleModel) obj;
      return ObjectsCompat.equals(getId(), simpleModel.getId()) &&
              ObjectsCompat.equals(getName(), simpleModel.getName()) &&
              ObjectsCompat.equals(getBar(), simpleModel.getBar()) &&
              ObjectsCompat.equals(getCreatedAt(), simpleModel.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), simpleModel.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getBar())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"SimpleModel {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"bar=\\" + String.valueOf(getBar()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static SimpleModel justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new SimpleModel(
      id,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      bar,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    SimpleModel build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep name(String name);
    BuildStep bar(String bar);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String name;
    private String bar;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public SimpleModel build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new SimpleModel(
          id,
          name,
          bar,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep name(String name) {
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep bar(String bar) {
        this.bar = bar;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, String bar, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .bar(bar)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder bar(String bar) {
      return (CopyOfBuilder) super.bar(bar);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor connection One to Many connection should generate many side of the connection 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.annotations.BelongsTo;
import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the task type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"tasks\\")
public final class task implements Model {
  public static final QueryField ID = field(\\"task\\", \\"id\\");
  public static final QueryField TITLE = field(\\"task\\", \\"title\\");
  public static final QueryField DONE = field(\\"task\\", \\"done\\");
  public static final QueryField TODO = field(\\"task\\", \\"taskTodoId\\");
  public static final QueryField TIME = field(\\"task\\", \\"time\\");
  public static final QueryField CREATED_ON = field(\\"task\\", \\"createdOn\\");
  public static final QueryField CREATED_AT = field(\\"task\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"task\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\", isRequired = true) String title;
  private final @ModelField(targetType=\\"Boolean\\", isRequired = true) Boolean done;
  private final @ModelField(targetType=\\"Todo\\") @BelongsTo(targetName = \\"taskTodoId\\", type = Todo.class) Todo todo;
  private final @ModelField(targetType=\\"AWSTime\\") Temporal.Time time;
  private final @ModelField(targetType=\\"AWSDate\\") Temporal.Date createdOn;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getTitle() {
      return title;
  }
  
  public Boolean getDone() {
      return done;
  }
  
  public Todo getTodo() {
      return todo;
  }
  
  public Temporal.Time getTime() {
      return time;
  }
  
  public Temporal.Date getCreatedOn() {
      return createdOn;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private task(String id, String title, Boolean done, Todo todo, Temporal.Time time, Temporal.Date createdOn, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.title = title;
    this.done = done;
    this.todo = todo;
    this.time = time;
    this.createdOn = createdOn;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      task task = (task) obj;
      return ObjectsCompat.equals(getId(), task.getId()) &&
              ObjectsCompat.equals(getTitle(), task.getTitle()) &&
              ObjectsCompat.equals(getDone(), task.getDone()) &&
              ObjectsCompat.equals(getTodo(), task.getTodo()) &&
              ObjectsCompat.equals(getTime(), task.getTime()) &&
              ObjectsCompat.equals(getCreatedOn(), task.getCreatedOn()) &&
              ObjectsCompat.equals(getCreatedAt(), task.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), task.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getTitle())
      .append(getDone())
      .append(getTodo())
      .append(getTime())
      .append(getCreatedOn())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"task {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"title=\\" + String.valueOf(getTitle()) + \\", \\")
      .append(\\"done=\\" + String.valueOf(getDone()) + \\", \\")
      .append(\\"todo=\\" + String.valueOf(getTodo()) + \\", \\")
      .append(\\"time=\\" + String.valueOf(getTime()) + \\", \\")
      .append(\\"createdOn=\\" + String.valueOf(getCreatedOn()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static TitleStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static task justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new task(
      id,
      null,
      null,
      null,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      title,
      done,
      todo,
      time,
      createdOn,
      createdAt,
      updatedAt);
  }
  public interface TitleStep {
    DoneStep title(String title);
  }
  

  public interface DoneStep {
    BuildStep done(Boolean done);
  }
  

  public interface BuildStep {
    task build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep todo(Todo todo);
    BuildStep time(Temporal.Time time);
    BuildStep createdOn(Temporal.Date createdOn);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements TitleStep, DoneStep, BuildStep {
    private String id;
    private String title;
    private Boolean done;
    private Todo todo;
    private Temporal.Time time;
    private Temporal.Date createdOn;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public task build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new task(
          id,
          title,
          done,
          todo,
          time,
          createdOn,
          createdAt,
          updatedAt);
    }
    
    @Override
     public DoneStep title(String title) {
        Objects.requireNonNull(title);
        this.title = title;
        return this;
    }
    
    @Override
     public BuildStep done(Boolean done) {
        Objects.requireNonNull(done);
        this.done = done;
        return this;
    }
    
    @Override
     public BuildStep todo(Todo todo) {
        this.todo = todo;
        return this;
    }
    
    @Override
     public BuildStep time(Temporal.Time time) {
        this.time = time;
        return this;
    }
    
    @Override
     public BuildStep createdOn(Temporal.Date createdOn) {
        this.createdOn = createdOn;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String title, Boolean done, Todo todo, Temporal.Time time, Temporal.Date createdOn, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.title(title)
        .done(done)
        .todo(todo)
        .time(time)
        .createdOn(createdOn)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder title(String title) {
      return (CopyOfBuilder) super.title(title);
    }
    
    @Override
     public CopyOfBuilder done(Boolean done) {
      return (CopyOfBuilder) super.done(done);
    }
    
    @Override
     public CopyOfBuilder todo(Todo todo) {
      return (CopyOfBuilder) super.todo(todo);
    }
    
    @Override
     public CopyOfBuilder time(Temporal.Time time) {
      return (CopyOfBuilder) super.time(time);
    }
    
    @Override
     public CopyOfBuilder createdOn(Temporal.Date createdOn) {
      return (CopyOfBuilder) super.createdOn(createdOn);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor connection One to Many connection should generate one side of the connection 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.annotations.HasMany;
import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the Todo type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"Todos\\")
public final class Todo implements Model {
  public static final QueryField ID = field(\\"Todo\\", \\"id\\");
  public static final QueryField TITLE = field(\\"Todo\\", \\"title\\");
  public static final QueryField DONE = field(\\"Todo\\", \\"done\\");
  public static final QueryField DESCRIPTION = field(\\"Todo\\", \\"description\\");
  public static final QueryField DUE_DATE = field(\\"Todo\\", \\"due_date\\");
  public static final QueryField VERSION = field(\\"Todo\\", \\"version\\");
  public static final QueryField VALUE = field(\\"Todo\\", \\"value\\");
  public static final QueryField CREATED_AT = field(\\"Todo\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"Todo\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\", isRequired = true) String title;
  private final @ModelField(targetType=\\"Boolean\\", isRequired = true) Boolean done;
  private final @ModelField(targetType=\\"String\\") String description;
  private final @ModelField(targetType=\\"String\\") String due_date;
  private final @ModelField(targetType=\\"Int\\", isRequired = true) Integer version;
  private final @ModelField(targetType=\\"Float\\") Double value;
  private final @ModelField(targetType=\\"task\\") @HasMany(associatedWith = \\"todo\\", type = task.class) List<task> tasks = null;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getTitle() {
      return title;
  }
  
  public Boolean getDone() {
      return done;
  }
  
  public String getDescription() {
      return description;
  }
  
  public String getDueDate() {
      return due_date;
  }
  
  public Integer getVersion() {
      return version;
  }
  
  public Double getValue() {
      return value;
  }
  
  public List<task> getTasks() {
      return tasks;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private Todo(String id, String title, Boolean done, String description, String due_date, Integer version, Double value, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.title = title;
    this.done = done;
    this.description = description;
    this.due_date = due_date;
    this.version = version;
    this.value = value;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      Todo todo = (Todo) obj;
      return ObjectsCompat.equals(getId(), todo.getId()) &&
              ObjectsCompat.equals(getTitle(), todo.getTitle()) &&
              ObjectsCompat.equals(getDone(), todo.getDone()) &&
              ObjectsCompat.equals(getDescription(), todo.getDescription()) &&
              ObjectsCompat.equals(getDueDate(), todo.getDueDate()) &&
              ObjectsCompat.equals(getVersion(), todo.getVersion()) &&
              ObjectsCompat.equals(getValue(), todo.getValue()) &&
              ObjectsCompat.equals(getCreatedAt(), todo.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), todo.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getTitle())
      .append(getDone())
      .append(getDescription())
      .append(getDueDate())
      .append(getVersion())
      .append(getValue())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"Todo {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"title=\\" + String.valueOf(getTitle()) + \\", \\")
      .append(\\"done=\\" + String.valueOf(getDone()) + \\", \\")
      .append(\\"description=\\" + String.valueOf(getDescription()) + \\", \\")
      .append(\\"due_date=\\" + String.valueOf(getDueDate()) + \\", \\")
      .append(\\"version=\\" + String.valueOf(getVersion()) + \\", \\")
      .append(\\"value=\\" + String.valueOf(getValue()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static TitleStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static Todo justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new Todo(
      id,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      title,
      done,
      description,
      due_date,
      version,
      value,
      createdAt,
      updatedAt);
  }
  public interface TitleStep {
    DoneStep title(String title);
  }
  

  public interface DoneStep {
    VersionStep done(Boolean done);
  }
  

  public interface VersionStep {
    BuildStep version(Integer version);
  }
  

  public interface BuildStep {
    Todo build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep description(String description);
    BuildStep dueDate(String dueDate);
    BuildStep value(Double value);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements TitleStep, DoneStep, VersionStep, BuildStep {
    private String id;
    private String title;
    private Boolean done;
    private Integer version;
    private String description;
    private String due_date;
    private Double value;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public Todo build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new Todo(
          id,
          title,
          done,
          description,
          due_date,
          version,
          value,
          createdAt,
          updatedAt);
    }
    
    @Override
     public DoneStep title(String title) {
        Objects.requireNonNull(title);
        this.title = title;
        return this;
    }
    
    @Override
     public VersionStep done(Boolean done) {
        Objects.requireNonNull(done);
        this.done = done;
        return this;
    }
    
    @Override
     public BuildStep version(Integer version) {
        Objects.requireNonNull(version);
        this.version = version;
        return this;
    }
    
    @Override
     public BuildStep description(String description) {
        this.description = description;
        return this;
    }
    
    @Override
     public BuildStep dueDate(String dueDate) {
        this.due_date = dueDate;
        return this;
    }
    
    @Override
     public BuildStep value(Double value) {
        this.value = value;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String title, Boolean done, String description, String dueDate, Integer version, Double value, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.title(title)
        .done(done)
        .version(version)
        .description(description)
        .dueDate(dueDate)
        .value(value)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder title(String title) {
      return (CopyOfBuilder) super.title(title);
    }
    
    @Override
     public CopyOfBuilder done(Boolean done) {
      return (CopyOfBuilder) super.done(done);
    }
    
    @Override
     public CopyOfBuilder version(Integer version) {
      return (CopyOfBuilder) super.version(version);
    }
    
    @Override
     public CopyOfBuilder description(String description) {
      return (CopyOfBuilder) super.description(description);
    }
    
    @Override
     public CopyOfBuilder dueDate(String dueDate) {
      return (CopyOfBuilder) super.dueDate(dueDate);
    }
    
    @Override
     public CopyOfBuilder value(Double value) {
      return (CopyOfBuilder) super.value(value);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor should generate Temporal type for AWSDate* scalars 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the TypeWithAWSDateScalars type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"TypeWithAWSDateScalars\\")
public final class TypeWithAWSDateScalars implements Model {
  public static final QueryField ID = field(\\"TypeWithAWSDateScalars\\", \\"id\\");
  public static final QueryField DATE = field(\\"TypeWithAWSDateScalars\\", \\"date\\");
  public static final QueryField CREATED_AT = field(\\"TypeWithAWSDateScalars\\", \\"createdAt\\");
  public static final QueryField TIME = field(\\"TypeWithAWSDateScalars\\", \\"time\\");
  public static final QueryField TIMESTAMP = field(\\"TypeWithAWSDateScalars\\", \\"timestamp\\");
  public static final QueryField UPDATED_AT = field(\\"TypeWithAWSDateScalars\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"AWSDate\\") Temporal.Date date;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSTime\\") Temporal.Time time;
  private final @ModelField(targetType=\\"AWSTimestamp\\") Temporal.Timestamp timestamp;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public Temporal.Date getDate() {
      return date;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.Time getTime() {
      return time;
  }
  
  public Temporal.Timestamp getTimestamp() {
      return timestamp;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private TypeWithAWSDateScalars(String id, Temporal.Date date, Temporal.DateTime createdAt, Temporal.Time time, Temporal.Timestamp timestamp, Temporal.DateTime updatedAt) {
    this.id = id;
    this.date = date;
    this.createdAt = createdAt;
    this.time = time;
    this.timestamp = timestamp;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      TypeWithAWSDateScalars typeWithAwsDateScalars = (TypeWithAWSDateScalars) obj;
      return ObjectsCompat.equals(getId(), typeWithAwsDateScalars.getId()) &&
              ObjectsCompat.equals(getDate(), typeWithAwsDateScalars.getDate()) &&
              ObjectsCompat.equals(getCreatedAt(), typeWithAwsDateScalars.getCreatedAt()) &&
              ObjectsCompat.equals(getTime(), typeWithAwsDateScalars.getTime()) &&
              ObjectsCompat.equals(getTimestamp(), typeWithAwsDateScalars.getTimestamp()) &&
              ObjectsCompat.equals(getUpdatedAt(), typeWithAwsDateScalars.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getDate())
      .append(getCreatedAt())
      .append(getTime())
      .append(getTimestamp())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"TypeWithAWSDateScalars {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"date=\\" + String.valueOf(getDate()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"time=\\" + String.valueOf(getTime()) + \\", \\")
      .append(\\"timestamp=\\" + String.valueOf(getTimestamp()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static TypeWithAWSDateScalars justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new TypeWithAWSDateScalars(
      id,
      null,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      date,
      createdAt,
      time,
      timestamp,
      updatedAt);
  }
  public interface BuildStep {
    TypeWithAWSDateScalars build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep date(Temporal.Date date);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep time(Temporal.Time time);
    BuildStep timestamp(Temporal.Timestamp timestamp);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private Temporal.Date date;
    private Temporal.DateTime createdAt;
    private Temporal.Time time;
    private Temporal.Timestamp timestamp;
    private Temporal.DateTime updatedAt;
    @Override
     public TypeWithAWSDateScalars build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new TypeWithAWSDateScalars(
          id,
          date,
          createdAt,
          time,
          timestamp,
          updatedAt);
    }
    
    @Override
     public BuildStep date(Temporal.Date date) {
        this.date = date;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep time(Temporal.Time time) {
        this.time = time;
        return this;
    }
    
    @Override
     public BuildStep timestamp(Temporal.Timestamp timestamp) {
        this.timestamp = timestamp;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, Temporal.Date date, Temporal.DateTime createdAt, Temporal.Time time, Temporal.Timestamp timestamp, Temporal.DateTime updatedAt) {
      super.id(id);
      super.date(date)
        .createdAt(createdAt)
        .time(time)
        .timestamp(timestamp)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder date(Temporal.Date date) {
      return (CopyOfBuilder) super.date(date);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder time(Temporal.Time time) {
      return (CopyOfBuilder) super.time(time);
    }
    
    @Override
     public CopyOfBuilder timestamp(Temporal.Timestamp timestamp) {
      return (CopyOfBuilder) super.timestamp(timestamp);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor should generate an enum for enum type 1`] = `
"package com.amplifyframework.datastore.generated.model;
/** Auto generated enum from GraphQL schema. */
@SuppressWarnings(\\"all\\")
public enum Status {
  pending,
  done
}
"
`;

exports[`AppSyncModelVisitor should generate model with key directive 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the authorBook type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"authorBooks\\")
@Index(name = \\"byAuthor\\", fields = {\\"author_id\\"})
@Index(name = \\"byBook\\", fields = {\\"book_id\\"})
public final class authorBook implements Model {
  public static final QueryField ID = field(\\"authorBook\\", \\"id\\");
  public static final QueryField AUTHOR_ID = field(\\"authorBook\\", \\"author_id\\");
  public static final QueryField BOOK_ID = field(\\"authorBook\\", \\"book_id\\");
  public static final QueryField AUTHOR = field(\\"authorBook\\", \\"author\\");
  public static final QueryField BOOK = field(\\"authorBook\\", \\"book\\");
  public static final QueryField CREATED_AT = field(\\"authorBook\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"authorBook\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String author_id;
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String book_id;
  private final @ModelField(targetType=\\"String\\") String author;
  private final @ModelField(targetType=\\"String\\") String book;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getAuthorId() {
      return author_id;
  }
  
  public String getBookId() {
      return book_id;
  }
  
  public String getAuthor() {
      return author;
  }
  
  public String getBook() {
      return book;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private authorBook(String id, String author_id, String book_id, String author, String book, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.author_id = author_id;
    this.book_id = book_id;
    this.author = author;
    this.book = book;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      authorBook authorBook = (authorBook) obj;
      return ObjectsCompat.equals(getId(), authorBook.getId()) &&
              ObjectsCompat.equals(getAuthorId(), authorBook.getAuthorId()) &&
              ObjectsCompat.equals(getBookId(), authorBook.getBookId()) &&
              ObjectsCompat.equals(getAuthor(), authorBook.getAuthor()) &&
              ObjectsCompat.equals(getBook(), authorBook.getBook()) &&
              ObjectsCompat.equals(getCreatedAt(), authorBook.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), authorBook.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getAuthorId())
      .append(getBookId())
      .append(getAuthor())
      .append(getBook())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"authorBook {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"author_id=\\" + String.valueOf(getAuthorId()) + \\", \\")
      .append(\\"book_id=\\" + String.valueOf(getBookId()) + \\", \\")
      .append(\\"author=\\" + String.valueOf(getAuthor()) + \\", \\")
      .append(\\"book=\\" + String.valueOf(getBook()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static AuthorIdStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static authorBook justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new authorBook(
      id,
      null,
      null,
      null,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      author_id,
      book_id,
      author,
      book,
      createdAt,
      updatedAt);
  }
  public interface AuthorIdStep {
    BookIdStep authorId(String authorId);
  }
  

  public interface BookIdStep {
    BuildStep bookId(String bookId);
  }
  

  public interface BuildStep {
    authorBook build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep author(String author);
    BuildStep book(String book);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements AuthorIdStep, BookIdStep, BuildStep {
    private String id;
    private String author_id;
    private String book_id;
    private String author;
    private String book;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public authorBook build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new authorBook(
          id,
          author_id,
          book_id,
          author,
          book,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BookIdStep authorId(String authorId) {
        Objects.requireNonNull(authorId);
        this.author_id = authorId;
        return this;
    }
    
    @Override
     public BuildStep bookId(String bookId) {
        Objects.requireNonNull(bookId);
        this.book_id = bookId;
        return this;
    }
    
    @Override
     public BuildStep author(String author) {
        this.author = author;
        return this;
    }
    
    @Override
     public BuildStep book(String book) {
        this.book = book;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String authorId, String bookId, String author, String book, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.authorId(authorId)
        .bookId(bookId)
        .author(author)
        .book(book)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder authorId(String authorId) {
      return (CopyOfBuilder) super.authorId(authorId);
    }
    
    @Override
     public CopyOfBuilder bookId(String bookId) {
      return (CopyOfBuilder) super.bookId(bookId);
    }
    
    @Override
     public CopyOfBuilder author(String author) {
      return (CopyOfBuilder) super.author(author);
    }
    
    @Override
     public CopyOfBuilder book(String book) {
      return (CopyOfBuilder) super.book(book);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor should generate model with non-camel case field 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the NonCamelCaseField type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"NonCamelCaseFields\\")
public final class NonCamelCaseField implements Model {
  public static final QueryField ID = field(\\"NonCamelCaseField\\", \\"id\\");
  public static final QueryField EMPLOYEE_PID = field(\\"NonCamelCaseField\\", \\"employeePID\\");
  public static final QueryField CREATED_AT = field(\\"NonCamelCaseField\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"NonCamelCaseField\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String employeePID;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getEmployeePid() {
      return employeePID;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private NonCamelCaseField(String id, String employeePID, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.employeePID = employeePID;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      NonCamelCaseField nonCamelCaseField = (NonCamelCaseField) obj;
      return ObjectsCompat.equals(getId(), nonCamelCaseField.getId()) &&
              ObjectsCompat.equals(getEmployeePid(), nonCamelCaseField.getEmployeePid()) &&
              ObjectsCompat.equals(getCreatedAt(), nonCamelCaseField.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), nonCamelCaseField.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getEmployeePid())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"NonCamelCaseField {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"employeePID=\\" + String.valueOf(getEmployeePid()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static NonCamelCaseField justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new NonCamelCaseField(
      id,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      employeePID,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    NonCamelCaseField build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep employeePid(String employeePid);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String employeePID;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public NonCamelCaseField build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new NonCamelCaseField(
          id,
          employeePID,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep employeePid(String employeePid) {
        this.employeePID = employeePid;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String employeePid, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.employeePid(employeePid)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder employeePid(String employeePid) {
      return (CopyOfBuilder) super.employeePid(employeePid);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor should generate model with snake case 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the snake_case type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"snake_cases\\")
public final class snake_case implements Model {
  public static final QueryField ID = field(\\"snake_case\\", \\"id\\");
  public static final QueryField NAME = field(\\"snake_case\\", \\"name\\");
  public static final QueryField CREATED_AT = field(\\"snake_case\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"snake_case\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String name;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getName() {
      return name;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private snake_case(String id, String name, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.name = name;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      snake_case snakeCase = (snake_case) obj;
      return ObjectsCompat.equals(getId(), snakeCase.getId()) &&
              ObjectsCompat.equals(getName(), snakeCase.getName()) &&
              ObjectsCompat.equals(getCreatedAt(), snakeCase.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), snakeCase.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getName())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"snake_case {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"name=\\" + String.valueOf(getName()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static snake_case justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new snake_case(
      id,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      name,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    snake_case build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep name(String name);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String name;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public snake_case build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new snake_case(
          id,
          name,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep name(String name) {
        this.name = name;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String name, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.name(name)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder name(String name) {
      return (CopyOfBuilder) super.name(name);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor should generate model with with snake_case field 1`] = `
"package com.amplifyframework.datastore.generated.model;

import com.amplifyframework.core.model.temporal.Temporal;

import java.util.List;
import java.util.UUID;
import java.util.Objects;

import androidx.core.util.ObjectsCompat;

import com.amplifyframework.core.model.Model;
import com.amplifyframework.core.model.annotations.Index;
import com.amplifyframework.core.model.annotations.ModelConfig;
import com.amplifyframework.core.model.annotations.ModelField;
import com.amplifyframework.core.model.query.predicate.QueryField;

import static com.amplifyframework.core.model.query.predicate.QueryField.field;

/** This is an auto generated class representing the SnakeCaseField type in your schema. */
@SuppressWarnings(\\"all\\")
@ModelConfig(pluralName = \\"SnakeCaseFields\\")
public final class SnakeCaseField implements Model {
  public static final QueryField ID = field(\\"SnakeCaseField\\", \\"id\\");
  public static final QueryField FIRST_NAME = field(\\"SnakeCaseField\\", \\"first_name\\");
  public static final QueryField CREATED_AT = field(\\"SnakeCaseField\\", \\"createdAt\\");
  public static final QueryField UPDATED_AT = field(\\"SnakeCaseField\\", \\"updatedAt\\");
  private final @ModelField(targetType=\\"ID\\", isRequired = true) String id;
  private final @ModelField(targetType=\\"String\\") String first_name;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime createdAt;
  private final @ModelField(targetType=\\"AWSDateTime\\") Temporal.DateTime updatedAt;
  public String getId() {
      return id;
  }
  
  public String getFirstName() {
      return first_name;
  }
  
  public Temporal.DateTime getCreatedAt() {
      return createdAt;
  }
  
  public Temporal.DateTime getUpdatedAt() {
      return updatedAt;
  }
  
  private SnakeCaseField(String id, String first_name, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
    this.id = id;
    this.first_name = first_name;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  
  @Override
   public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if(obj == null || getClass() != obj.getClass()) {
        return false;
      } else {
      SnakeCaseField snakeCaseField = (SnakeCaseField) obj;
      return ObjectsCompat.equals(getId(), snakeCaseField.getId()) &&
              ObjectsCompat.equals(getFirstName(), snakeCaseField.getFirstName()) &&
              ObjectsCompat.equals(getCreatedAt(), snakeCaseField.getCreatedAt()) &&
              ObjectsCompat.equals(getUpdatedAt(), snakeCaseField.getUpdatedAt());
      }
  }
  
  @Override
   public int hashCode() {
    return new StringBuilder()
      .append(getId())
      .append(getFirstName())
      .append(getCreatedAt())
      .append(getUpdatedAt())
      .toString()
      .hashCode();
  }
  
  @Override
   public String toString() {
    return new StringBuilder()
      .append(\\"SnakeCaseField {\\")
      .append(\\"id=\\" + String.valueOf(getId()) + \\", \\")
      .append(\\"first_name=\\" + String.valueOf(getFirstName()) + \\", \\")
      .append(\\"createdAt=\\" + String.valueOf(getCreatedAt()) + \\", \\")
      .append(\\"updatedAt=\\" + String.valueOf(getUpdatedAt()))
      .append(\\"}\\")
      .toString();
  }
  
  public static BuildStep builder() {
      return new Builder();
  }
  
  /** 
   * WARNING: This method should not be used to build an instance of this object for a CREATE mutation.
   * This is a convenience method to return an instance of the object with only its ID populated
   * to be used in the context of a parameter in a delete mutation or referencing a foreign key
   * in a relationship.
   * @param id the id of the existing item this instance will represent
   * @return an instance of this model with only ID populated
   * @throws IllegalArgumentException Checks that ID is in the proper format
   */
  public static SnakeCaseField justId(String id) {
    try {
      UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
    } catch (Exception exception) {
      throw new IllegalArgumentException(
              \\"Model IDs must be unique in the format of UUID. This method is for creating instances \\" +
              \\"of an existing object with only its ID field for sending as a mutation parameter. When \\" +
              \\"creating a new object, use the standard builder method and leave the ID field blank.\\"
      );
    }
    return new SnakeCaseField(
      id,
      null,
      null,
      null
    );
  }
  
  public CopyOfBuilder copyOfBuilder() {
    return new CopyOfBuilder(id,
      first_name,
      createdAt,
      updatedAt);
  }
  public interface BuildStep {
    SnakeCaseField build();
    BuildStep id(String id) throws IllegalArgumentException;
    BuildStep firstName(String firstName);
    BuildStep createdAt(Temporal.DateTime createdAt);
    BuildStep updatedAt(Temporal.DateTime updatedAt);
  }
  

  public static class Builder implements BuildStep {
    private String id;
    private String first_name;
    private Temporal.DateTime createdAt;
    private Temporal.DateTime updatedAt;
    @Override
     public SnakeCaseField build() {
        String id = this.id != null ? this.id : UUID.randomUUID().toString();
        
        return new SnakeCaseField(
          id,
          first_name,
          createdAt,
          updatedAt);
    }
    
    @Override
     public BuildStep firstName(String firstName) {
        this.first_name = firstName;
        return this;
    }
    
    @Override
     public BuildStep createdAt(Temporal.DateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    @Override
     public BuildStep updatedAt(Temporal.DateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }
    
    /** 
     * WARNING: Do not set ID when creating a new object. Leave this blank and one will be auto generated for you.
     * This should only be set when referring to an already existing object.
     * @param id id
     * @return Current Builder instance, for fluent method chaining
     * @throws IllegalArgumentException Checks that ID is in the proper format
     */
    public BuildStep id(String id) throws IllegalArgumentException {
        this.id = id;
        
        try {
            UUID.fromString(id); // Check that ID is in the UUID format - if not an exception is thrown
        } catch (Exception exception) {
          throw new IllegalArgumentException(\\"Model IDs must be unique in the format of UUID.\\",
                    exception);
        }
        
        return this;
    }
  }
  

  public final class CopyOfBuilder extends Builder {
    private CopyOfBuilder(String id, String firstName, Temporal.DateTime createdAt, Temporal.DateTime updatedAt) {
      super.id(id);
      super.firstName(firstName)
        .createdAt(createdAt)
        .updatedAt(updatedAt);
    }
    
    @Override
     public CopyOfBuilder firstName(String firstName) {
      return (CopyOfBuilder) super.firstName(firstName);
    }
    
    @Override
     public CopyOfBuilder createdAt(Temporal.DateTime createdAt) {
      return (CopyOfBuilder) super.createdAt(createdAt);
    }
    
    @Override
     public CopyOfBuilder updatedAt(Temporal.DateTime updatedAt) {
      return (CopyOfBuilder) super.updatedAt(updatedAt);
    }
  }
  
}
"
`;

exports[`AppSyncModelVisitor should throw error if two fields have the same camel field 1`] = `"Fields \\"subject_name\\" and \\"subjectName\\" in sameCamelCaseField cannot be used at the same time which will result in the duplicate builder method."`;
