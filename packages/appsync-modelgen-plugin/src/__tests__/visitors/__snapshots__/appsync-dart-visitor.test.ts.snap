// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AppSync Dart Visitor Amplify Core dependency used in imports Should use the amplify_core dependency if dartUpdateAmplifyCoreDependency is true 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_core/amplify_core.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final int? _rating;
  final PostStatus? _status;
  final List<Comment>? _comments;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new AmplifyCodeGenModelException(
          AmplifyExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            AmplifyExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  int get rating {
    try {
      return _rating!;
    } catch(e) {
      throw new AmplifyCodeGenModelException(
          AmplifyExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            AmplifyExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  PostStatus get status {
    try {
      return _status!;
    } catch(e) {
      throw new AmplifyCodeGenModelException(
          AmplifyExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            AmplifyExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Comment>? get comments {
    return _comments;
  }
  
  const Post._internal({required this.id, required title, required rating, required status, comments}): _title = title, _rating = rating, _status = status, _comments = comments;
  
  factory Post({String? id, required String title, required int rating, required PostStatus status, List<Comment>? comments}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      rating: rating,
      status: status,
      comments: comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      _rating == other._rating &&
      _status == other._status &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"rating=\\" + (_rating != null ? _rating!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"status=\\" + (_status != null ? enumToString(_status)! : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, int? rating, PostStatus? status, List<Comment>? comments}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      rating: rating ?? this.rating,
      status: status ?? this.status,
      comments: comments ?? this.comments);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _rating = (json['rating'] as num?)?.toInt(),
      _status = enumFromString<PostStatus>(json['status'], PostStatus.values),
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'rating': _rating, 'status': enumToString(_status), 'comments': _comments?.map((Comment? e) => e?.toJson()).toList()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'title': _title,
    'rating': _rating,
    'status': _status,
    'comments': _comments
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField RATING = QueryField(fieldName: \\"rating\\");
  static final QueryField STATUS = QueryField(fieldName: \\"status\\");
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Comment'));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.RATING,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.STATUS,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.COMMENTS,
      isRequired: false,
      ofModelName: 'Comment',
      associatedKey: Comment.POST
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Post';
  }
}

/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final Post? _post;
  final String? _content;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  Post get post {
    try {
      return _post!;
    } catch(e) {
      throw new AmplifyCodeGenModelException(
          AmplifyExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            AmplifyExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get content {
    try {
      return _content!;
    } catch(e) {
      throw new AmplifyCodeGenModelException(
          AmplifyExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            AmplifyExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Comment._internal({required this.id, required post, required content}): _post = post, _content = content;
  
  factory Comment({String? id, required Post post, required String content}) {
    return Comment._internal(
      id: id == null ? UUID.getUUID() : id,
      post: post,
      content: content);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
      id == other.id &&
      _post == other._post &&
      _content == other._content;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (_post != null ? _post!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment copyWith({String? id, Post? post, String? content}) {
    return Comment(
      id: id ?? this.id,
      post: post ?? this.post,
      content: content ?? this.content);
  }
  
  Comment.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _post = json['post']?['serializedData'] != null
        ? Post.fromJson(new Map<String, dynamic>.from(json['post']['serializedData']))
        : null,
      _content = json['content'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'post': _post?.toJson(), 'content': _content
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'post': _post,
    'content': _content
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField POST = QueryField(
    fieldName: \\"post\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Post'));
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"postID\\", \\"content\\"], name: \\"byPost\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Comment.POST,
      isRequired: true,
      targetName: 'postID',
      ofModelName: 'Post'
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.CONTENT,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();
  
  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Comment';
  }
}"
`;

exports[`AppSync Dart Visitor Amplify Core dependency used in imports Should use the older flutter datastore interface dependency if dartUpdateAmplifyCoreDependency is false 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final int? _rating;
  final PostStatus? _status;
  final List<Comment>? _comments;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  int get rating {
    try {
      return _rating!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  PostStatus get status {
    try {
      return _status!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Comment>? get comments {
    return _comments;
  }
  
  const Post._internal({required this.id, required title, required rating, required status, comments}): _title = title, _rating = rating, _status = status, _comments = comments;
  
  factory Post({String? id, required String title, required int rating, required PostStatus status, List<Comment>? comments}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      rating: rating,
      status: status,
      comments: comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      _rating == other._rating &&
      _status == other._status &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"rating=\\" + (_rating != null ? _rating!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"status=\\" + (_status != null ? enumToString(_status)! : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, int? rating, PostStatus? status, List<Comment>? comments}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      rating: rating ?? this.rating,
      status: status ?? this.status,
      comments: comments ?? this.comments);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _rating = (json['rating'] as num?)?.toInt(),
      _status = enumFromString<PostStatus>(json['status'], PostStatus.values),
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'rating': _rating, 'status': enumToString(_status), 'comments': _comments?.map((Comment? e) => e?.toJson()).toList()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'title': _title,
    'rating': _rating,
    'status': _status,
    'comments': _comments
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField RATING = QueryField(fieldName: \\"rating\\");
  static final QueryField STATUS = QueryField(fieldName: \\"status\\");
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Comment'));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.RATING,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.STATUS,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.COMMENTS,
      isRequired: false,
      ofModelName: 'Comment',
      associatedKey: Comment.POST
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Post';
  }
}

/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final Post? _post;
  final String? _content;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  Post get post {
    try {
      return _post!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get content {
    try {
      return _content!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Comment._internal({required this.id, required post, required content}): _post = post, _content = content;
  
  factory Comment({String? id, required Post post, required String content}) {
    return Comment._internal(
      id: id == null ? UUID.getUUID() : id,
      post: post,
      content: content);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
      id == other.id &&
      _post == other._post &&
      _content == other._content;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (_post != null ? _post!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment copyWith({String? id, Post? post, String? content}) {
    return Comment(
      id: id ?? this.id,
      post: post ?? this.post,
      content: content ?? this.content);
  }
  
  Comment.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _post = json['post']?['serializedData'] != null
        ? Post.fromJson(new Map<String, dynamic>.from(json['post']['serializedData']))
        : null,
      _content = json['content'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'post': _post?.toJson(), 'content': _content
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'post': _post,
    'content': _content
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField POST = QueryField(
    fieldName: \\"post\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Post'));
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"postID\\", \\"content\\"], name: \\"byPost\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Comment.POST,
      isRequired: true,
      targetName: 'postID',
      ofModelName: 'Post'
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.CONTENT,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();
  
  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Comment';
  }
}"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generate correct dart class for Address with nullsafety 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Address type in your schema. */
@immutable
class Address {
  final String? _line1;
  final String? _line2;
  final String? _city;
  final String? _state;
  final String? _postalCode;

  String get line1 {
    try {
      return _line1!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String? get line2 {
    return _line2;
  }
  
  String get city {
    try {
      return _city!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get state {
    try {
      return _state!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get postalCode {
    try {
      return _postalCode!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Address._internal({required line1, line2, required city, required state, required postalCode}): _line1 = line1, _line2 = line2, _city = city, _state = state, _postalCode = postalCode;
  
  factory Address({required String line1, String? line2, required String city, required String state, required String postalCode}) {
    return Address._internal(
      line1: line1,
      line2: line2,
      city: city,
      state: state,
      postalCode: postalCode);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Address &&
      _line1 == other._line1 &&
      _line2 == other._line2 &&
      _city == other._city &&
      _state == other._state &&
      _postalCode == other._postalCode;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Address {\\");
    buffer.write(\\"line1=\\" + \\"$_line1\\" + \\", \\");
    buffer.write(\\"line2=\\" + \\"$_line2\\" + \\", \\");
    buffer.write(\\"city=\\" + \\"$_city\\" + \\", \\");
    buffer.write(\\"state=\\" + \\"$_state\\" + \\", \\");
    buffer.write(\\"postalCode=\\" + \\"$_postalCode\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Address copyWith({String? line1, String? line2, String? city, String? state, String? postalCode}) {
    return Address(
      line1: line1 ?? this.line1,
      line2: line2 ?? this.line2,
      city: city ?? this.city,
      state: state ?? this.state,
      postalCode: postalCode ?? this.postalCode);
  }
  
  Address.fromJson(Map<String, dynamic> json)  
    : _line1 = json['line1'],
      _line2 = json['line2'],
      _city = json['city'],
      _state = json['state'],
      _postalCode = json['postalCode'];
  
  Map<String, dynamic> toJson() => {
    'line1': _line1, 'line2': _line2, 'city': _city, 'state': _state, 'postalCode': _postalCode
  };
  
  Map<String, Object?> toMap() => {
    'line1': _line1,
    'line2': _line2,
    'city': _city,
    'state': _state,
    'postalCode': _postalCode
  };

  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Address\\";
    modelSchemaDefinition.pluralName = \\"Addresses\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'line1',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'line2',
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'city',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'state',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'postalCode',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generate correct dart class for Contact with nullsafety 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Contact type in your schema. */
@immutable
class Contact {
  final String? _contactName;
  final Phone? _phone;
  final List<Address>? _mailingAddresses;

  String get contactName {
    try {
      return _contactName!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Phone get phone {
    try {
      return _phone!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Address>? get mailingAddresses {
    return _mailingAddresses;
  }
  
  const Contact._internal({required contactName, required phone, mailingAddresses}): _contactName = contactName, _phone = phone, _mailingAddresses = mailingAddresses;
  
  factory Contact({required String contactName, required Phone phone, List<Address>? mailingAddresses}) {
    return Contact._internal(
      contactName: contactName,
      phone: phone,
      mailingAddresses: mailingAddresses != null ? List<Address>.unmodifiable(mailingAddresses) : mailingAddresses);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Contact &&
      _contactName == other._contactName &&
      _phone == other._phone &&
      DeepCollectionEquality().equals(_mailingAddresses, other._mailingAddresses);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Contact {\\");
    buffer.write(\\"contactName=\\" + \\"$_contactName\\" + \\", \\");
    buffer.write(\\"phone=\\" + (_phone != null ? _phone!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"mailingAddresses=\\" + (_mailingAddresses != null ? _mailingAddresses!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Contact copyWith({String? contactName, Phone? phone, List<Address>? mailingAddresses}) {
    return Contact(
      contactName: contactName ?? this.contactName,
      phone: phone ?? this.phone,
      mailingAddresses: mailingAddresses ?? this.mailingAddresses);
  }
  
  Contact.fromJson(Map<String, dynamic> json)  
    : _contactName = json['contactName'],
      _phone = json['phone']?['serializedData'] != null
        ? Phone.fromJson(new Map<String, dynamic>.from(json['phone']['serializedData']))
        : null,
      _mailingAddresses = json['mailingAddresses'] is List
        ? (json['mailingAddresses'] as List)
          .where((e) => e != null)
          .map((e) => Address.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'contactName': _contactName, 'phone': _phone?.toJson(), 'mailingAddresses': _mailingAddresses?.map((Address? e) => e?.toJson()).toList()
  };
  
  Map<String, Object?> toMap() => {
    'contactName': _contactName,
    'phone': _phone,
    'mailingAddresses': _mailingAddresses
  };

  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Contact\\";
    modelSchemaDefinition.pluralName = \\"Contacts\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'contactName',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
      fieldName: 'phone',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.embedded, ofCustomTypeName: 'Phone')
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
      fieldName: 'mailingAddresses',
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.embeddedCollection, ofCustomTypeName: 'Address')
    ));
  });
}"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generate correct dart class for ModelProvider with nullsafety 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'Person.dart';
import 'Address.dart';
import 'Contact.dart';
import 'Phone.dart';

export 'Address.dart';
export 'Contact.dart';
export 'Person.dart';
export 'Phone.dart';

class ModelProvider implements ModelProviderInterface {
  @override
  String version = \\"b65f704d832381d9985dd162ae40c075\\";
  @override
  List<ModelSchema> modelSchemas = [Person.schema];
  static final ModelProvider _instance = ModelProvider();
  @override
  List<ModelSchema> customTypeSchemas = [Address.schema, Contact.schema, Phone.schema];

  static ModelProvider get instance => _instance;
  
  ModelType getModelTypeByModelName(String modelName) {
    switch(modelName) {
      case \\"Person\\":
        return Person.classType;
      default:
        throw Exception(\\"Failed to find model in model provider for model name: \\" + modelName);
    }
  }
}"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generate correct dart class for Person with nullsafety 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Person type in your schema. */
@immutable
class Person extends Model {
  static const classType = const _PersonModelType();
  final String id;
  final String? _name;
  final Phone? _phone;
  final List<Address>? _mailingAddresses;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Phone get phone {
    try {
      return _phone!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Address>? get mailingAddresses {
    return _mailingAddresses;
  }
  
  const Person._internal({required this.id, required name, required phone, mailingAddresses}): _name = name, _phone = phone, _mailingAddresses = mailingAddresses;
  
  factory Person({String? id, required String name, required Phone phone, List<Address>? mailingAddresses}) {
    return Person._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      phone: phone,
      mailingAddresses: mailingAddresses != null ? List<Address>.unmodifiable(mailingAddresses) : mailingAddresses);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Person &&
      id == other.id &&
      _name == other._name &&
      _phone == other._phone &&
      DeepCollectionEquality().equals(_mailingAddresses, other._mailingAddresses);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Person {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"phone=\\" + (_phone != null ? _phone!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"mailingAddresses=\\" + (_mailingAddresses != null ? _mailingAddresses!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Person copyWith({String? id, String? name, Phone? phone, List<Address>? mailingAddresses}) {
    return Person(
      id: id ?? this.id,
      name: name ?? this.name,
      phone: phone ?? this.phone,
      mailingAddresses: mailingAddresses ?? this.mailingAddresses);
  }
  
  Person.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _phone = json['phone']?['serializedData'] != null
        ? Phone.fromJson(new Map<String, dynamic>.from(json['phone']['serializedData']))
        : null,
      _mailingAddresses = json['mailingAddresses'] is List
        ? (json['mailingAddresses'] as List)
          .where((e) => e != null)
          .map((e) => Address.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'phone': _phone?.toJson(), 'mailingAddresses': _mailingAddresses?.map((Address? e) => e?.toJson()).toList()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'phone': _phone,
    'mailingAddresses': _mailingAddresses
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField PHONE = QueryField(fieldName: \\"phone\\");
  static final QueryField MAILINGADDRESSES = QueryField(fieldName: \\"mailingAddresses\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Person\\";
    modelSchemaDefinition.pluralName = \\"People\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Person.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
      fieldName: 'phone',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.embedded, ofCustomTypeName: 'Phone')
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
      fieldName: 'mailingAddresses',
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.embeddedCollection, ofCustomTypeName: 'Address')
    ));
  });
}

class _PersonModelType extends ModelType<Person> {
  const _PersonModelType();
  
  @override
  Person fromJson(Map<String, dynamic> jsonData) {
    return Person.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Person';
  }
}"
`;

exports[`AppSync Dart Visitor Dart Specific Tests should generate the model provider 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'SimpleModel.dart';

export 'SimpleModel.dart';

class ModelProvider implements ModelProviderInterface {
  @override
  String version = \\"20078c21a81919792555926e238b194e\\";
  @override
  List<ModelSchema> modelSchemas = [SimpleModel.schema];
  static final ModelProvider _instance = ModelProvider();
  @override
  List<ModelSchema> customTypeSchemas = [];

  static ModelProvider get instance => _instance;
  
  ModelType getModelTypeByModelName(String modelName) {
    switch(modelName) {
      case \\"SimpleModel\\":
        return SimpleModel.classType;
      default:
        throw Exception(\\"Failed to find model in model provider for model name: \\" + modelName);
    }
  }
}"
`;

exports[`AppSync Dart Visitor Enum Generation should generate a class for enum type 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final Status? _status;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  Status? get status {
    return _status;
  }
  
  const SimpleModel._internal({required this.id, status}): _status = status;
  
  factory SimpleModel({String? id, Status? status}) {
    return SimpleModel._internal(
      id: id == null ? UUID.getUUID() : id,
      status: status);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel &&
      id == other.id &&
      _status == other._status;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"status=\\" + (_status != null ? enumToString(_status)! : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  SimpleModel copyWith({String? id, Status? status}) {
    return SimpleModel(
      id: id ?? this.id,
      status: status ?? this.status);
  }
  
  SimpleModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _status = enumFromString<Status>(json['status'], Status.values);
  
  Map<String, dynamic> toJson() => {
    'id': id, 'status': enumToString(_status)
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'status': _status
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField STATUS = QueryField(fieldName: \\"status\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: SimpleModel.STATUS,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)
    ));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();
  
  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'SimpleModel';
  }
}"
`;

exports[`AppSync Dart Visitor Enum Generation should generate a class for enum type 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

enum Status {
  yes,
  no,
  maybe
}"
`;

exports[`AppSync Dart Visitor Field tests should generate correct output for appsync scalar types of time and int 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TemporalTimeModel type in your schema. */
@immutable
class TemporalTimeModel extends Model {
  static const classType = const _TemporalTimeModelModelType();
  final String id;
  final TemporalDate? _date;
  final TemporalTime? _time;
  final TemporalDateTime? _dateTime;
  final TemporalTimestamp? _timestamp;
  final int? _intNum;
  final List<TemporalDate>? _dateList;
  final List<TemporalTime>? _timeList;
  final List<TemporalDateTime>? _dateTimeList;
  final List<TemporalTimestamp>? _timestampList;
  final List<int>? _intList;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  TemporalDate? get date {
    return _date;
  }
  
  TemporalTime? get time {
    return _time;
  }
  
  TemporalDateTime? get dateTime {
    return _dateTime;
  }
  
  TemporalTimestamp? get timestamp {
    return _timestamp;
  }
  
  int? get intNum {
    return _intNum;
  }
  
  List<TemporalDate>? get dateList {
    return _dateList;
  }
  
  List<TemporalTime>? get timeList {
    return _timeList;
  }
  
  List<TemporalDateTime>? get dateTimeList {
    return _dateTimeList;
  }
  
  List<TemporalTimestamp>? get timestampList {
    return _timestampList;
  }
  
  List<int>? get intList {
    return _intList;
  }
  
  const TemporalTimeModel._internal({required this.id, date, time, dateTime, timestamp, intNum, dateList, timeList, dateTimeList, timestampList, intList}): _date = date, _time = time, _dateTime = dateTime, _timestamp = timestamp, _intNum = intNum, _dateList = dateList, _timeList = timeList, _dateTimeList = dateTimeList, _timestampList = timestampList, _intList = intList;
  
  factory TemporalTimeModel({String? id, TemporalDate? date, TemporalTime? time, TemporalDateTime? dateTime, TemporalTimestamp? timestamp, int? intNum, List<TemporalDate>? dateList, List<TemporalTime>? timeList, List<TemporalDateTime>? dateTimeList, List<TemporalTimestamp>? timestampList, List<int>? intList}) {
    return TemporalTimeModel._internal(
      id: id == null ? UUID.getUUID() : id,
      date: date,
      time: time,
      dateTime: dateTime,
      timestamp: timestamp,
      intNum: intNum,
      dateList: dateList != null ? List<TemporalDate>.unmodifiable(dateList) : dateList,
      timeList: timeList != null ? List<TemporalTime>.unmodifiable(timeList) : timeList,
      dateTimeList: dateTimeList != null ? List<TemporalDateTime>.unmodifiable(dateTimeList) : dateTimeList,
      timestampList: timestampList != null ? List<TemporalTimestamp>.unmodifiable(timestampList) : timestampList,
      intList: intList != null ? List<int>.unmodifiable(intList) : intList);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TemporalTimeModel &&
      id == other.id &&
      _date == other._date &&
      _time == other._time &&
      _dateTime == other._dateTime &&
      _timestamp == other._timestamp &&
      _intNum == other._intNum &&
      DeepCollectionEquality().equals(_dateList, other._dateList) &&
      DeepCollectionEquality().equals(_timeList, other._timeList) &&
      DeepCollectionEquality().equals(_dateTimeList, other._dateTimeList) &&
      DeepCollectionEquality().equals(_timestampList, other._timestampList) &&
      DeepCollectionEquality().equals(_intList, other._intList);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TemporalTimeModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"date=\\" + (_date != null ? _date!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"time=\\" + (_time != null ? _time!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"dateTime=\\" + (_dateTime != null ? _dateTime!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"timestamp=\\" + (_timestamp != null ? _timestamp!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intNum=\\" + (_intNum != null ? _intNum!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"dateList=\\" + (_dateList != null ? _dateList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"timeList=\\" + (_timeList != null ? _timeList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"dateTimeList=\\" + (_dateTimeList != null ? _dateTimeList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"timestampList=\\" + (_timestampList != null ? _timestampList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intList=\\" + (_intList != null ? _intList!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TemporalTimeModel copyWith({String? id, TemporalDate? date, TemporalTime? time, TemporalDateTime? dateTime, TemporalTimestamp? timestamp, int? intNum, List<TemporalDate>? dateList, List<TemporalTime>? timeList, List<TemporalDateTime>? dateTimeList, List<TemporalTimestamp>? timestampList, List<int>? intList}) {
    return TemporalTimeModel(
      id: id ?? this.id,
      date: date ?? this.date,
      time: time ?? this.time,
      dateTime: dateTime ?? this.dateTime,
      timestamp: timestamp ?? this.timestamp,
      intNum: intNum ?? this.intNum,
      dateList: dateList ?? this.dateList,
      timeList: timeList ?? this.timeList,
      dateTimeList: dateTimeList ?? this.dateTimeList,
      timestampList: timestampList ?? this.timestampList,
      intList: intList ?? this.intList);
  }
  
  TemporalTimeModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _date = json['date'] != null ? TemporalDate.fromString(json['date']) : null,
      _time = json['time'] != null ? TemporalTime.fromString(json['time']) : null,
      _dateTime = json['dateTime'] != null ? TemporalDateTime.fromString(json['dateTime']) : null,
      _timestamp = json['timestamp'] != null ? TemporalTimestamp.fromSeconds(json['timestamp']) : null,
      _intNum = (json['intNum'] as num?)?.toInt(),
      _dateList = (json['dateList'] as List?)?.map((e) => TemporalDate.fromString(e)).toList(),
      _timeList = (json['timeList'] as List?)?.map((e) => TemporalTime.fromString(e)).toList(),
      _dateTimeList = (json['dateTimeList'] as List?)?.map((e) => TemporalDateTime.fromString(e)).toList(),
      _timestampList = (json['timestampList'] as List?)?.map((e) => TemporalTimestamp.fromSeconds(e)).toList(),
      _intList = (json['intList'] as List?)?.map((e) => (e as num).toInt()).toList();
  
  Map<String, dynamic> toJson() => {
    'id': id, 'date': _date?.format(), 'time': _time?.format(), 'dateTime': _dateTime?.format(), 'timestamp': _timestamp?.toSeconds(), 'intNum': _intNum, 'dateList': _dateList?.map((e) => e.format()).toList(), 'timeList': _timeList?.map((e) => e.format()).toList(), 'dateTimeList': _dateTimeList?.map((e) => e.format()).toList(), 'timestampList': _timestampList?.map((e) => e.toSeconds()).toList(), 'intList': _intList
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'date': _date,
    'time': _time,
    'dateTime': _dateTime,
    'timestamp': _timestamp,
    'intNum': _intNum,
    'dateList': _dateList,
    'timeList': _timeList,
    'dateTimeList': _dateTimeList,
    'timestampList': _timestampList,
    'intList': _intList
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField DATE = QueryField(fieldName: \\"date\\");
  static final QueryField TIME = QueryField(fieldName: \\"time\\");
  static final QueryField DATETIME = QueryField(fieldName: \\"dateTime\\");
  static final QueryField TIMESTAMP = QueryField(fieldName: \\"timestamp\\");
  static final QueryField INTNUM = QueryField(fieldName: \\"intNum\\");
  static final QueryField DATELIST = QueryField(fieldName: \\"dateList\\");
  static final QueryField TIMELIST = QueryField(fieldName: \\"timeList\\");
  static final QueryField DATETIMELIST = QueryField(fieldName: \\"dateTimeList\\");
  static final QueryField TIMESTAMPLIST = QueryField(fieldName: \\"timestampList\\");
  static final QueryField INTLIST = QueryField(fieldName: \\"intList\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TemporalTimeModel\\";
    modelSchemaDefinition.pluralName = \\"TemporalTimeModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TemporalTimeModel.DATE,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.date)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TemporalTimeModel.TIME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.time)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TemporalTimeModel.DATETIME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TemporalTimeModel.TIMESTAMP,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.timestamp)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TemporalTimeModel.INTNUM,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TemporalTimeModel.DATELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.date))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TemporalTimeModel.TIMELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.time))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TemporalTimeModel.DATETIMELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.dateTime))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TemporalTimeModel.TIMESTAMPLIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.timestamp))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TemporalTimeModel.INTLIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.int))
    ));
  });
}

class _TemporalTimeModelModelType extends ModelType<TemporalTimeModel> {
  const _TemporalTimeModelModelType();
  
  @override
  TemporalTimeModel fromJson(Map<String, dynamic> jsonData) {
    return TemporalTimeModel.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'TemporalTimeModel';
  }
}"
`;

exports[`AppSync Dart Visitor Field tests should generate correct output for enum field w/o list or nullable 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TestEnumModel type in your schema. */
@immutable
class TestEnumModel extends Model {
  static const classType = const _TestEnumModelModelType();
  final String id;
  final TestEnum? _enumVal;
  final TestEnum? _nullableEnumVal;
  final List<TestEnum>? _enumList;
  final List<TestEnum>? _enumNullableList;
  final List<TestEnum>? _nullableEnumList;
  final List<TestEnum>? _nullableEnumNullableList;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  TestEnum get enumVal {
    try {
      return _enumVal!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TestEnum? get nullableEnumVal {
    return _nullableEnumVal;
  }
  
  List<TestEnum> get enumList {
    try {
      return _enumList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<TestEnum>? get enumNullableList {
    return _enumNullableList;
  }
  
  List<TestEnum> get nullableEnumList {
    try {
      return _nullableEnumList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<TestEnum>? get nullableEnumNullableList {
    return _nullableEnumNullableList;
  }
  
  const TestEnumModel._internal({required this.id, required enumVal, nullableEnumVal, required enumList, enumNullableList, required nullableEnumList, nullableEnumNullableList}): _enumVal = enumVal, _nullableEnumVal = nullableEnumVal, _enumList = enumList, _enumNullableList = enumNullableList, _nullableEnumList = nullableEnumList, _nullableEnumNullableList = nullableEnumNullableList;
  
  factory TestEnumModel({String? id, required TestEnum enumVal, TestEnum? nullableEnumVal, required List<TestEnum> enumList, List<TestEnum>? enumNullableList, required List<TestEnum> nullableEnumList, List<TestEnum>? nullableEnumNullableList}) {
    return TestEnumModel._internal(
      id: id == null ? UUID.getUUID() : id,
      enumVal: enumVal,
      nullableEnumVal: nullableEnumVal,
      enumList: enumList != null ? List<TestEnum>.unmodifiable(enumList) : enumList,
      enumNullableList: enumNullableList != null ? List<TestEnum>.unmodifiable(enumNullableList) : enumNullableList,
      nullableEnumList: nullableEnumList != null ? List<TestEnum>.unmodifiable(nullableEnumList) : nullableEnumList,
      nullableEnumNullableList: nullableEnumNullableList != null ? List<TestEnum>.unmodifiable(nullableEnumNullableList) : nullableEnumNullableList);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestEnumModel &&
      id == other.id &&
      _enumVal == other._enumVal &&
      _nullableEnumVal == other._nullableEnumVal &&
      DeepCollectionEquality().equals(_enumList, other._enumList) &&
      DeepCollectionEquality().equals(_enumNullableList, other._enumNullableList) &&
      DeepCollectionEquality().equals(_nullableEnumList, other._nullableEnumList) &&
      DeepCollectionEquality().equals(_nullableEnumNullableList, other._nullableEnumNullableList);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TestEnumModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"enumVal=\\" + (_enumVal != null ? enumToString(_enumVal)! : \\"null\\") + \\", \\");
    buffer.write(\\"nullableEnumVal=\\" + (_nullableEnumVal != null ? enumToString(_nullableEnumVal)! : \\"null\\") + \\", \\");
    buffer.write(\\"enumList=\\" + (_enumList != null ? _enumList!.map((e) => enumToString(e)).toString() : \\"null\\") + \\", \\");
    buffer.write(\\"enumNullableList=\\" + (_enumNullableList != null ? _enumNullableList!.map((e) => enumToString(e)).toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableEnumList=\\" + (_nullableEnumList != null ? _nullableEnumList!.map((e) => enumToString(e)).toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableEnumNullableList=\\" + (_nullableEnumNullableList != null ? _nullableEnumNullableList!.map((e) => enumToString(e)).toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TestEnumModel copyWith({String? id, TestEnum? enumVal, TestEnum? nullableEnumVal, List<TestEnum>? enumList, List<TestEnum>? enumNullableList, List<TestEnum>? nullableEnumList, List<TestEnum>? nullableEnumNullableList}) {
    return TestEnumModel(
      id: id ?? this.id,
      enumVal: enumVal ?? this.enumVal,
      nullableEnumVal: nullableEnumVal ?? this.nullableEnumVal,
      enumList: enumList ?? this.enumList,
      enumNullableList: enumNullableList ?? this.enumNullableList,
      nullableEnumList: nullableEnumList ?? this.nullableEnumList,
      nullableEnumNullableList: nullableEnumNullableList ?? this.nullableEnumNullableList);
  }
  
  TestEnumModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _enumVal = enumFromString<TestEnum>(json['enumVal'], TestEnum.values),
      _nullableEnumVal = enumFromString<TestEnum>(json['nullableEnumVal'], TestEnum.values),
      _enumList = json['enumList'] is List
        ? (json['enumList'] as List)
          .map((e) => enumFromString<TestEnum>(e, TestEnum.values)!)
          .toList()
        : null,
      _enumNullableList = json['enumNullableList'] is List
        ? (json['enumNullableList'] as List)
          .map((e) => enumFromString<TestEnum>(e, TestEnum.values)!)
          .toList()
        : null,
      _nullableEnumList = json['nullableEnumList'] is List
        ? (json['nullableEnumList'] as List)
          .map((e) => enumFromString<TestEnum>(e, TestEnum.values)!)
          .toList()
        : null,
      _nullableEnumNullableList = json['nullableEnumNullableList'] is List
        ? (json['nullableEnumNullableList'] as List)
          .map((e) => enumFromString<TestEnum>(e, TestEnum.values)!)
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'enumVal': enumToString(_enumVal), 'nullableEnumVal': enumToString(_nullableEnumVal), 'enumList': _enumList?.map((e) => enumToString(e)).toList(), 'enumNullableList': _enumNullableList?.map((e) => enumToString(e)).toList(), 'nullableEnumList': _nullableEnumList?.map((e) => enumToString(e)).toList(), 'nullableEnumNullableList': _nullableEnumNullableList?.map((e) => enumToString(e)).toList()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'enumVal': _enumVal,
    'nullableEnumVal': _nullableEnumVal,
    'enumList': _enumList,
    'enumNullableList': _enumNullableList,
    'nullableEnumList': _nullableEnumList,
    'nullableEnumNullableList': _nullableEnumNullableList
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField ENUMVAL = QueryField(fieldName: \\"enumVal\\");
  static final QueryField NULLABLEENUMVAL = QueryField(fieldName: \\"nullableEnumVal\\");
  static final QueryField ENUMLIST = QueryField(fieldName: \\"enumList\\");
  static final QueryField ENUMNULLABLELIST = QueryField(fieldName: \\"enumNullableList\\");
  static final QueryField NULLABLEENUMLIST = QueryField(fieldName: \\"nullableEnumList\\");
  static final QueryField NULLABLEENUMNULLABLELIST = QueryField(fieldName: \\"nullableEnumNullableList\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestEnumModel\\";
    modelSchemaDefinition.pluralName = \\"TestEnumModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestEnumModel.ENUMVAL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestEnumModel.NULLABLEENUMVAL,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestEnumModel.ENUMLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestEnumModel.ENUMNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestEnumModel.NULLABLEENUMLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestEnumModel.NULLABLEENUMNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))
    ));
  });
}

class _TestEnumModelModelType extends ModelType<TestEnumModel> {
  const _TestEnumModelModelType();
  
  @override
  TestEnumModel fromJson(Map<String, dynamic> jsonData) {
    return TestEnumModel.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'TestEnumModel';
  }
}"
`;

exports[`AppSync Dart Visitor Field tests should generate correct output for regular field w/o list or nullable 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TestModel type in your schema. */
@immutable
class TestModel extends Model {
  static const classType = const _TestModelModelType();
  final String id;
  final double? _floatVal;
  final double? _floatNullableVal;
  final List<double>? _floatList;
  final List<double>? _floatNullableList;
  final List<double>? _nullableFloatList;
  final List<double>? _nullableFloatNullableList;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  double get floatVal {
    try {
      return _floatVal!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  double? get floatNullableVal {
    return _floatNullableVal;
  }
  
  List<double> get floatList {
    try {
      return _floatList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<double>? get floatNullableList {
    return _floatNullableList;
  }
  
  List<double> get nullableFloatList {
    try {
      return _nullableFloatList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<double>? get nullableFloatNullableList {
    return _nullableFloatNullableList;
  }
  
  const TestModel._internal({required this.id, required floatVal, floatNullableVal, required floatList, floatNullableList, required nullableFloatList, nullableFloatNullableList}): _floatVal = floatVal, _floatNullableVal = floatNullableVal, _floatList = floatList, _floatNullableList = floatNullableList, _nullableFloatList = nullableFloatList, _nullableFloatNullableList = nullableFloatNullableList;
  
  factory TestModel({String? id, required double floatVal, double? floatNullableVal, required List<double> floatList, List<double>? floatNullableList, required List<double> nullableFloatList, List<double>? nullableFloatNullableList}) {
    return TestModel._internal(
      id: id == null ? UUID.getUUID() : id,
      floatVal: floatVal,
      floatNullableVal: floatNullableVal,
      floatList: floatList != null ? List<double>.unmodifiable(floatList) : floatList,
      floatNullableList: floatNullableList != null ? List<double>.unmodifiable(floatNullableList) : floatNullableList,
      nullableFloatList: nullableFloatList != null ? List<double>.unmodifiable(nullableFloatList) : nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList != null ? List<double>.unmodifiable(nullableFloatNullableList) : nullableFloatNullableList);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestModel &&
      id == other.id &&
      _floatVal == other._floatVal &&
      _floatNullableVal == other._floatNullableVal &&
      DeepCollectionEquality().equals(_floatList, other._floatList) &&
      DeepCollectionEquality().equals(_floatNullableList, other._floatNullableList) &&
      DeepCollectionEquality().equals(_nullableFloatList, other._nullableFloatList) &&
      DeepCollectionEquality().equals(_nullableFloatNullableList, other._nullableFloatNullableList);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TestModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"floatVal=\\" + (_floatVal != null ? _floatVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableVal=\\" + (_floatNullableVal != null ? _floatNullableVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatList=\\" + (_floatList != null ? _floatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableList=\\" + (_floatNullableList != null ? _floatNullableList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatList=\\" + (_nullableFloatList != null ? _nullableFloatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatNullableList=\\" + (_nullableFloatNullableList != null ? _nullableFloatNullableList!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TestModel copyWith({String? id, double? floatVal, double? floatNullableVal, List<double>? floatList, List<double>? floatNullableList, List<double>? nullableFloatList, List<double>? nullableFloatNullableList}) {
    return TestModel(
      id: id ?? this.id,
      floatVal: floatVal ?? this.floatVal,
      floatNullableVal: floatNullableVal ?? this.floatNullableVal,
      floatList: floatList ?? this.floatList,
      floatNullableList: floatNullableList ?? this.floatNullableList,
      nullableFloatList: nullableFloatList ?? this.nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList ?? this.nullableFloatNullableList);
  }
  
  TestModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _floatVal = (json['floatVal'] as num?)?.toDouble(),
      _floatNullableVal = (json['floatNullableVal'] as num?)?.toDouble(),
      _floatList = (json['floatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _floatNullableList = (json['floatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatList = (json['nullableFloatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatNullableList = (json['nullableFloatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList();
  
  Map<String, dynamic> toJson() => {
    'id': id, 'floatVal': _floatVal, 'floatNullableVal': _floatNullableVal, 'floatList': _floatList, 'floatNullableList': _floatNullableList, 'nullableFloatList': _nullableFloatList, 'nullableFloatNullableList': _nullableFloatNullableList
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'floatVal': _floatVal,
    'floatNullableVal': _floatNullableVal,
    'floatList': _floatList,
    'floatNullableList': _floatNullableList,
    'nullableFloatList': _nullableFloatList,
    'nullableFloatNullableList': _nullableFloatNullableList
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField FLOATVAL = QueryField(fieldName: \\"floatVal\\");
  static final QueryField FLOATNULLABLEVAL = QueryField(fieldName: \\"floatNullableVal\\");
  static final QueryField FLOATLIST = QueryField(fieldName: \\"floatList\\");
  static final QueryField FLOATNULLABLELIST = QueryField(fieldName: \\"floatNullableList\\");
  static final QueryField NULLABLEFLOATLIST = QueryField(fieldName: \\"nullableFloatList\\");
  static final QueryField NULLABLEFLOATNULLABLELIST = QueryField(fieldName: \\"nullableFloatNullableList\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestModel\\";
    modelSchemaDefinition.pluralName = \\"TestModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATVAL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLEVAL,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
  });
}

class _TestModelModelType extends ModelType<TestModel> {
  const _TestModelModelType();
  
  @override
  TestModel fromJson(Map<String, dynamic> jsonData) {
    return TestModel.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'TestModel';
  }
}"
`;

exports[`AppSync Dart Visitor Many To Many V2 Tests Should generate the intermediate model successfully with nullsafety 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final String? _content;
  final List<PostTags>? _tags;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String? get content {
    return _content;
  }
  
  List<PostTags>? get tags {
    return _tags;
  }
  
  const Post._internal({required this.id, required title, content, tags}): _title = title, _content = content, _tags = tags;
  
  factory Post({String? id, required String title, String? content, List<PostTags>? tags}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      content: content,
      tags: tags != null ? List<PostTags>.unmodifiable(tags) : tags);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      _content == other._content &&
      DeepCollectionEquality().equals(_tags, other._tags);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, String? content, List<PostTags>? tags}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      content: content ?? this.content,
      tags: tags ?? this.tags);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _content = json['content'],
      _tags = json['tags'] is List
        ? (json['tags'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => PostTags.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'content': _content, 'tags': _tags?.map((PostTags? e) => e?.toJson()).toList()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'title': _title,
    'content': _content,
    'tags': _tags
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static final QueryField TAGS = QueryField(
    fieldName: \\"tags\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'PostTags'));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.CONTENT,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.TAGS,
      isRequired: false,
      ofModelName: 'PostTags',
      associatedKey: PostTags.POST
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Post';
  }
}

/** This is an auto generated class representing the Tag type in your schema. */
@immutable
class Tag extends Model {
  static const classType = const _TagModelType();
  final String id;
  final String? _label;
  final List<PostTags>? _posts;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get label {
    try {
      return _label!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<PostTags>? get posts {
    return _posts;
  }
  
  const Tag._internal({required this.id, required label, posts}): _label = label, _posts = posts;
  
  factory Tag({String? id, required String label, List<PostTags>? posts}) {
    return Tag._internal(
      id: id == null ? UUID.getUUID() : id,
      label: label,
      posts: posts != null ? List<PostTags>.unmodifiable(posts) : posts);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Tag &&
      id == other.id &&
      _label == other._label &&
      DeepCollectionEquality().equals(_posts, other._posts);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Tag {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"label=\\" + \\"$_label\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Tag copyWith({String? id, String? label, List<PostTags>? posts}) {
    return Tag(
      id: id ?? this.id,
      label: label ?? this.label,
      posts: posts ?? this.posts);
  }
  
  Tag.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _label = json['label'],
      _posts = json['posts'] is List
        ? (json['posts'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => PostTags.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'label': _label, 'posts': _posts?.map((PostTags? e) => e?.toJson()).toList()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'label': _label,
    'posts': _posts
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField LABEL = QueryField(fieldName: \\"label\\");
  static final QueryField POSTS = QueryField(
    fieldName: \\"posts\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'PostTags'));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Tag\\";
    modelSchemaDefinition.pluralName = \\"Tags\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Tag.LABEL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Tag.POSTS,
      isRequired: false,
      ofModelName: 'PostTags',
      associatedKey: PostTags.TAG
    ));
  });
}

class _TagModelType extends ModelType<Tag> {
  const _TagModelType();
  
  @override
  Tag fromJson(Map<String, dynamic> jsonData) {
    return Tag.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Tag';
  }
}

/** This is an auto generated class representing the PostTags type in your schema. */
@immutable
class PostTags extends Model {
  static const classType = const _PostTagsModelType();
  final String id;
  final Post? _post;
  final Tag? _tag;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  Post get post {
    try {
      return _post!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Tag get tag {
    try {
      return _tag!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const PostTags._internal({required this.id, required post, required tag}): _post = post, _tag = tag;
  
  factory PostTags({String? id, required Post post, required Tag tag}) {
    return PostTags._internal(
      id: id == null ? UUID.getUUID() : id,
      post: post,
      tag: tag);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is PostTags &&
      id == other.id &&
      _post == other._post &&
      _tag == other._tag;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"PostTags {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (_post != null ? _post!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"tag=\\" + (_tag != null ? _tag!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  PostTags copyWith({String? id, Post? post, Tag? tag}) {
    return PostTags(
      id: id ?? this.id,
      post: post ?? this.post,
      tag: tag ?? this.tag);
  }
  
  PostTags.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _post = json['post']?['serializedData'] != null
        ? Post.fromJson(new Map<String, dynamic>.from(json['post']['serializedData']))
        : null,
      _tag = json['tag']?['serializedData'] != null
        ? Tag.fromJson(new Map<String, dynamic>.from(json['tag']['serializedData']))
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'post': _post?.toJson(), 'tag': _tag?.toJson()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'post': _post,
    'tag': _tag
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField POST = QueryField(
    fieldName: \\"post\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Post'));
  static final QueryField TAG = QueryField(
    fieldName: \\"tag\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Tag'));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"PostTags\\";
    modelSchemaDefinition.pluralName = \\"PostTags\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"postID\\"], name: \\"byPost\\"),
      ModelIndex(fields: const [\\"tagID\\"], name: \\"byTag\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: PostTags.POST,
      isRequired: true,
      targetName: 'postID',
      ofModelName: 'Post'
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: PostTags.TAG,
      isRequired: true,
      targetName: 'tagID',
      ofModelName: 'Tag'
    ));
  });
}

class _PostTagsModelType extends ModelType<PostTags> {
  const _PostTagsModelType();
  
  @override
  PostTags fromJson(Map<String, dynamic> jsonData) {
    return PostTags.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'PostTags';
  }
}"
`;

exports[`AppSync Dart Visitor Model Directive should generate a class for a Simple Model 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String? _name;
  final String? _bar;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  String? get bar {
    return _bar;
  }
  
  const SimpleModel._internal({required this.id, name, bar}): _name = name, _bar = bar;
  
  factory SimpleModel({String? id, String? name, String? bar}) {
    return SimpleModel._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      bar: bar);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel &&
      id == other.id &&
      _name == other._name &&
      _bar == other._bar;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$_bar\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  SimpleModel copyWith({String? id, String? name, String? bar}) {
    return SimpleModel(
      id: id ?? this.id,
      name: name ?? this.name,
      bar: bar ?? this.bar);
  }
  
  SimpleModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _bar = json['bar'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'bar': _bar
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'bar': _bar
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: SimpleModel.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: SimpleModel.BAR,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();
  
  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'SimpleModel';
  }
}"
`;

exports[`AppSync Dart Visitor Model Directive should generate a class for a model with all optional fields except id field 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String? _name;
  final String? _bar;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  String? get bar {
    return _bar;
  }
  
  const SimpleModel._internal({required this.id, name, bar}): _name = name, _bar = bar;
  
  factory SimpleModel({String? id, String? name, String? bar}) {
    return SimpleModel._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      bar: bar);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel &&
      id == other.id &&
      _name == other._name &&
      _bar == other._bar;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$_bar\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  SimpleModel copyWith({String? id, String? name, String? bar}) {
    return SimpleModel(
      id: id ?? this.id,
      name: name ?? this.name,
      bar: bar ?? this.bar);
  }
  
  SimpleModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _bar = json['bar'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'bar': _bar
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'bar': _bar
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: SimpleModel.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: SimpleModel.BAR,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();
  
  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'SimpleModel';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate AuthRule with provider information when enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TodoWithAuth type in your schema. */
@immutable
class TodoWithAuth extends Model {
  static const classType = const _TodoWithAuthModelType();
  final String id;
  final String? _name;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const TodoWithAuth._internal({required this.id, required name, createdAt, updatedAt}): _name = name, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory TodoWithAuth({String? id, required String name}) {
    return TodoWithAuth._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TodoWithAuth &&
      id == other.id &&
      _name == other._name;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TodoWithAuth {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TodoWithAuth copyWith({String? id, String? name}) {
    return TodoWithAuth._internal(
      id: id ?? this.id,
      name: name ?? this.name);
  }
  
  TodoWithAuth.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TodoWithAuth\\";
    modelSchemaDefinition.pluralName = \\"TodoWithAuths\\";
    
    modelSchemaDefinition.authRules = [
      AuthRule(
        authStrategy: AuthStrategy.GROUPS,
        groupClaim: \\"cognito:groups\\",
        groups: [ \\"admin\\" ],
        provider: AuthRuleProvider.USERPOOLS,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE,
          ModelOperation.DELETE,
          ModelOperation.READ
        ]),
      AuthRule(
        authStrategy: AuthStrategy.OWNER,
        ownerField: \\"owner\\",
        identityClaim: \\"cognito:username\\",
        provider: AuthRuleProvider.USERPOOLS,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE
        ]),
      AuthRule(
        authStrategy: AuthStrategy.PUBLIC,
        provider: AuthRuleProvider.APIKEY,
        operations: [
          ModelOperation.READ
        ])
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TodoWithAuth.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _TodoWithAuthModelType extends ModelType<TodoWithAuth> {
  const _TodoWithAuthModelType();
  
  @override
  TodoWithAuth fromJson(Map<String, dynamic> jsonData) {
    return TodoWithAuth.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'TodoWithAuth';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with custom claims 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the customClaim type in your schema. */
@immutable
class customClaim extends Model {
  static const classType = const _customClaimModelType();
  final String id;
  final String? _name;
  final String? _bar;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  String? get bar {
    return _bar;
  }
  
  const customClaim._internal({required this.id, name, bar}): _name = name, _bar = bar;
  
  factory customClaim({String? id, String? name, String? bar}) {
    return customClaim._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      bar: bar);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is customClaim &&
      id == other.id &&
      _name == other._name &&
      _bar == other._bar;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"customClaim {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$_bar\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  customClaim copyWith({String? id, String? name, String? bar}) {
    return customClaim(
      id: id ?? this.id,
      name: name ?? this.name,
      bar: bar ?? this.bar);
  }
  
  customClaim.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _bar = json['bar'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'bar': _bar
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'bar': _bar
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"customClaim\\";
    modelSchemaDefinition.pluralName = \\"customClaims\\";
    
    modelSchemaDefinition.authRules = [
      AuthRule(
        authStrategy: AuthStrategy.OWNER,
        ownerField: \\"owner\\",
        identityClaim: \\"user_id\\",
        provider: AuthRuleProvider.USERPOOLS,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE,
          ModelOperation.DELETE,
          ModelOperation.READ
        ])
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: customClaim.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: customClaim.BAR,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _customClaimModelType extends ModelType<customClaim> {
  const _customClaimModelType();
  
  @override
  customClaim fromJson(Map<String, dynamic> jsonData) {
    return customClaim.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'customClaim';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with custom group claims 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the customClaim type in your schema. */
@immutable
class customClaim extends Model {
  static const classType = const _customClaimModelType();
  final String id;
  final String? _name;
  final String? _bar;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  String? get bar {
    return _bar;
  }
  
  const customClaim._internal({required this.id, name, bar}): _name = name, _bar = bar;
  
  factory customClaim({String? id, String? name, String? bar}) {
    return customClaim._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      bar: bar);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is customClaim &&
      id == other.id &&
      _name == other._name &&
      _bar == other._bar;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"customClaim {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$_bar\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  customClaim copyWith({String? id, String? name, String? bar}) {
    return customClaim(
      id: id ?? this.id,
      name: name ?? this.name,
      bar: bar ?? this.bar);
  }
  
  customClaim.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _bar = json['bar'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'bar': _bar
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'bar': _bar
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"customClaim\\";
    modelSchemaDefinition.pluralName = \\"customClaims\\";
    
    modelSchemaDefinition.authRules = [
      AuthRule(
        authStrategy: AuthStrategy.GROUPS,
        groupClaim: \\"user_groups\\",
        groups: [ \\"Moderator\\" ],
        provider: AuthRuleProvider.USERPOOLS,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE,
          ModelOperation.DELETE,
          ModelOperation.READ
        ])
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: customClaim.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: customClaim.BAR,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _customClaimModelType extends ModelType<customClaim> {
  const _customClaimModelType();
  
  @override
  customClaim fromJson(Map<String, dynamic> jsonData) {
    return customClaim.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'customClaim';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with dynamic groups 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the dynamicGroups type in your schema. */
@immutable
class dynamicGroups extends Model {
  static const classType = const _dynamicGroupsModelType();
  final String id;
  final String? _name;
  final String? _bar;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  String? get bar {
    return _bar;
  }
  
  const dynamicGroups._internal({required this.id, name, bar}): _name = name, _bar = bar;
  
  factory dynamicGroups({String? id, String? name, String? bar}) {
    return dynamicGroups._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      bar: bar);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is dynamicGroups &&
      id == other.id &&
      _name == other._name &&
      _bar == other._bar;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"dynamicGroups {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$_bar\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  dynamicGroups copyWith({String? id, String? name, String? bar}) {
    return dynamicGroups(
      id: id ?? this.id,
      name: name ?? this.name,
      bar: bar ?? this.bar);
  }
  
  dynamicGroups.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _bar = json['bar'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'bar': _bar
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'bar': _bar
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"dynamicGroups\\";
    modelSchemaDefinition.pluralName = \\"dynamicGroups\\";
    
    modelSchemaDefinition.authRules = [
      AuthRule(
        authStrategy: AuthStrategy.GROUPS,
        groupClaim: \\"cognito:groups\\",
        groupsField: \\"groups\\",
        provider: AuthRuleProvider.USERPOOLS,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE,
          ModelOperation.DELETE,
          ModelOperation.READ
        ])
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: dynamicGroups.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: dynamicGroups.BAR,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _dynamicGroupsModelType extends ModelType<dynamicGroups> {
  const _dynamicGroupsModelType();
  
  @override
  dynamicGroups fromJson(Map<String, dynamic> jsonData) {
    return dynamicGroups.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'dynamicGroups';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with owner auth 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the simpleOwnerAuth type in your schema. */
@immutable
class simpleOwnerAuth extends Model {
  static const classType = const _simpleOwnerAuthModelType();
  final String id;
  final String? _name;
  final String? _bar;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  String? get bar {
    return _bar;
  }
  
  const simpleOwnerAuth._internal({required this.id, name, bar}): _name = name, _bar = bar;
  
  factory simpleOwnerAuth({String? id, String? name, String? bar}) {
    return simpleOwnerAuth._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      bar: bar);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is simpleOwnerAuth &&
      id == other.id &&
      _name == other._name &&
      _bar == other._bar;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"simpleOwnerAuth {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$_bar\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  simpleOwnerAuth copyWith({String? id, String? name, String? bar}) {
    return simpleOwnerAuth(
      id: id ?? this.id,
      name: name ?? this.name,
      bar: bar ?? this.bar);
  }
  
  simpleOwnerAuth.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _bar = json['bar'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'bar': _bar
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'bar': _bar
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"simpleOwnerAuth\\";
    modelSchemaDefinition.pluralName = \\"simpleOwnerAuths\\";
    
    modelSchemaDefinition.authRules = [
      AuthRule(
        authStrategy: AuthStrategy.OWNER,
        ownerField: \\"owner\\",
        identityClaim: \\"cognito:username\\",
        provider: AuthRuleProvider.USERPOOLS,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE,
          ModelOperation.DELETE,
          ModelOperation.READ
        ])
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: simpleOwnerAuth.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: simpleOwnerAuth.BAR,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _simpleOwnerAuthModelType extends ModelType<simpleOwnerAuth> {
  const _simpleOwnerAuthModelType();
  
  @override
  simpleOwnerAuth fromJson(Map<String, dynamic> jsonData) {
    return simpleOwnerAuth.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'simpleOwnerAuth';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with owner auth allowing others to read: 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the allowRead type in your schema. */
@immutable
class allowRead extends Model {
  static const classType = const _allowReadModelType();
  final String id;
  final String? _name;
  final String? _bar;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  String? get bar {
    return _bar;
  }
  
  const allowRead._internal({required this.id, name, bar}): _name = name, _bar = bar;
  
  factory allowRead({String? id, String? name, String? bar}) {
    return allowRead._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      bar: bar);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is allowRead &&
      id == other.id &&
      _name == other._name &&
      _bar == other._bar;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"allowRead {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$_bar\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  allowRead copyWith({String? id, String? name, String? bar}) {
    return allowRead(
      id: id ?? this.id,
      name: name ?? this.name,
      bar: bar ?? this.bar);
  }
  
  allowRead.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _bar = json['bar'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'bar': _bar
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'bar': _bar
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"allowRead\\";
    modelSchemaDefinition.pluralName = \\"allowReads\\";
    
    modelSchemaDefinition.authRules = [
      AuthRule(
        authStrategy: AuthStrategy.OWNER,
        ownerField: \\"owner\\",
        identityClaim: \\"cognito:username\\",
        provider: AuthRuleProvider.USERPOOLS,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.DELETE,
          ModelOperation.UPDATE
        ])
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: allowRead.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: allowRead.BAR,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _allowReadModelType extends ModelType<allowRead> {
  const _allowReadModelType();
  
  @override
  allowRead fromJson(Map<String, dynamic> jsonData) {
    return allowRead.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'allowRead';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with private authorization 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the privateType type in your schema. */
@immutable
class privateType extends Model {
  static const classType = const _privateTypeModelType();
  final String id;
  final String? _name;
  final String? _bar;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  String? get bar {
    return _bar;
  }
  
  const privateType._internal({required this.id, name, bar}): _name = name, _bar = bar;
  
  factory privateType({String? id, String? name, String? bar}) {
    return privateType._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      bar: bar);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is privateType &&
      id == other.id &&
      _name == other._name &&
      _bar == other._bar;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"privateType {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$_bar\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  privateType copyWith({String? id, String? name, String? bar}) {
    return privateType(
      id: id ?? this.id,
      name: name ?? this.name,
      bar: bar ?? this.bar);
  }
  
  privateType.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _bar = json['bar'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'bar': _bar
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'bar': _bar
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"privateType\\";
    modelSchemaDefinition.pluralName = \\"privateTypes\\";
    
    modelSchemaDefinition.authRules = [
      AuthRule(
        authStrategy: AuthStrategy.PRIVATE,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE,
          ModelOperation.DELETE,
          ModelOperation.READ
        ])
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: privateType.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: privateType.BAR,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _privateTypeModelType extends ModelType<privateType> {
  const _privateTypeModelType();
  
  @override
  privateType fromJson(Map<String, dynamic> jsonData) {
    return privateType.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'privateType';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with public authorization 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the publicType type in your schema. */
@immutable
class publicType extends Model {
  static const classType = const _publicTypeModelType();
  final String id;
  final String? _name;
  final String? _bar;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  String? get bar {
    return _bar;
  }
  
  const publicType._internal({required this.id, name, bar}): _name = name, _bar = bar;
  
  factory publicType({String? id, String? name, String? bar}) {
    return publicType._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      bar: bar);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is publicType &&
      id == other.id &&
      _name == other._name &&
      _bar == other._bar;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"publicType {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$_bar\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  publicType copyWith({String? id, String? name, String? bar}) {
    return publicType(
      id: id ?? this.id,
      name: name ?? this.name,
      bar: bar ?? this.bar);
  }
  
  publicType.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _bar = json['bar'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'bar': _bar
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'bar': _bar
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"publicType\\";
    modelSchemaDefinition.pluralName = \\"publicTypes\\";
    
    modelSchemaDefinition.authRules = [
      AuthRule(
        authStrategy: AuthStrategy.PUBLIC,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE,
          ModelOperation.DELETE,
          ModelOperation.READ
        ])
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: publicType.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: publicType.BAR,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _publicTypeModelType extends ModelType<publicType> {
  const _publicTypeModelType();
  
  @override
  publicType fromJson(Map<String, dynamic> jsonData) {
    return publicType.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'publicType';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with static groups 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the staticGroups type in your schema. */
@immutable
class staticGroups extends Model {
  static const classType = const _staticGroupsModelType();
  final String id;
  final String? _name;
  final String? _bar;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  String? get bar {
    return _bar;
  }
  
  const staticGroups._internal({required this.id, name, bar}): _name = name, _bar = bar;
  
  factory staticGroups({String? id, String? name, String? bar}) {
    return staticGroups._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      bar: bar);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is staticGroups &&
      id == other.id &&
      _name == other._name &&
      _bar == other._bar;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"staticGroups {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$_bar\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  staticGroups copyWith({String? id, String? name, String? bar}) {
    return staticGroups(
      id: id ?? this.id,
      name: name ?? this.name,
      bar: bar ?? this.bar);
  }
  
  staticGroups.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _bar = json['bar'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'bar': _bar
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'bar': _bar
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"staticGroups\\";
    modelSchemaDefinition.pluralName = \\"staticGroups\\";
    
    modelSchemaDefinition.authRules = [
      AuthRule(
        authStrategy: AuthStrategy.GROUPS,
        groupClaim: \\"cognito:groups\\",
        groups: [ \\"Admin\\" ],
        provider: AuthRuleProvider.USERPOOLS,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE,
          ModelOperation.DELETE,
          ModelOperation.READ
        ])
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: staticGroups.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: staticGroups.BAR,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _staticGroupsModelType extends ModelType<staticGroups> {
  const _staticGroupsModelType();
  
  @override
  staticGroups fromJson(Map<String, dynamic> jsonData) {
    return staticGroups.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'staticGroups';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should include authRules in schema when owner auth is used with ownerField 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final String? _author;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get author {
    try {
      return _author!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Post._internal({required this.id, required title, required author}): _title = title, _author = author;
  
  factory Post({String? id, required String title, required String author}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      author: author);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      _author == other._author;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"author=\\" + \\"$_author\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, String? author}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      author: author ?? this.author);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _author = json['author'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'author': _author
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'title': _title,
    'author': _author
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField AUTHOR = QueryField(fieldName: \\"author\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.authRules = [
      AuthRule(
        authStrategy: AuthStrategy.OWNER,
        ownerField: \\"author\\",
        identityClaim: \\"cognito:username\\",
        provider: AuthRuleProvider.USERPOOLS,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE,
          ModelOperation.DELETE,
          ModelOperation.READ
        ])
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.AUTHOR,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Post';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should support multiple auth rules 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final String? _owner;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get owner {
    try {
      return _owner!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Post._internal({required this.id, required title, required owner}): _title = title, _owner = owner;
  
  factory Post({String? id, required String title, required String owner}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      owner: owner);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      _owner == other._owner;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"owner=\\" + \\"$_owner\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, String? owner}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      owner: owner ?? this.owner);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _owner = json['owner'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'owner': _owner
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'title': _title,
    'owner': _owner
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField OWNER = QueryField(fieldName: \\"owner\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.authRules = [
      AuthRule(
        authStrategy: AuthStrategy.GROUPS,
        groupClaim: \\"cognito:groups\\",
        groups: [ \\"admin\\" ],
        provider: AuthRuleProvider.USERPOOLS,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE,
          ModelOperation.DELETE,
          ModelOperation.READ
        ]),
      AuthRule(
        authStrategy: AuthStrategy.OWNER,
        ownerField: \\"owner\\",
        identityClaim: \\"cognito:username\\",
        provider: AuthRuleProvider.USERPOOLS,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE
        ]),
      AuthRule(
        authStrategy: AuthStrategy.PUBLIC,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE,
          ModelOperation.DELETE,
          ModelOperation.READ
        ])
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.OWNER,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Post';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should generate classes for models with one to many connection 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Todo type in your schema. */
@immutable
class Todo extends Model {
  static const classType = const _TodoModelType();
  final String id;
  final List<Task>? _tasks;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  List<Task>? get tasks {
    return _tasks;
  }
  
  const Todo._internal({required this.id, tasks}): _tasks = tasks;
  
  factory Todo({String? id, List<Task>? tasks}) {
    return Todo._internal(
      id: id == null ? UUID.getUUID() : id,
      tasks: tasks != null ? List<Task>.unmodifiable(tasks) : tasks);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Todo &&
      id == other.id &&
      DeepCollectionEquality().equals(_tasks, other._tasks);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Todo {\\");
    buffer.write(\\"id=\\" + \\"$id\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Todo copyWith({String? id, List<Task>? tasks}) {
    return Todo(
      id: id ?? this.id,
      tasks: tasks ?? this.tasks);
  }
  
  Todo.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _tasks = json['tasks'] is List
        ? (json['tasks'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Task.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'tasks': _tasks?.map((Task? e) => e?.toJson()).toList()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'tasks': _tasks
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TASKS = QueryField(
    fieldName: \\"tasks\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Task'));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Todo\\";
    modelSchemaDefinition.pluralName = \\"Todos\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Todo.TASKS,
      isRequired: false,
      ofModelName: 'Task',
      associatedKey: Task.TODO
    ));
  });
}

class _TodoModelType extends ModelType<Todo> {
  const _TodoModelType();
  
  @override
  Todo fromJson(Map<String, dynamic> jsonData) {
    return Todo.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Todo';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should generate classes for models with one to many connection 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Task type in your schema. */
@immutable
class Task extends Model {
  static const classType = const _TaskModelType();
  final String id;
  final Todo? _todo;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  Todo? get todo {
    return _todo;
  }
  
  const Task._internal({required this.id, todo}): _todo = todo;
  
  factory Task({String? id, Todo? todo}) {
    return Task._internal(
      id: id == null ? UUID.getUUID() : id,
      todo: todo);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Task &&
      id == other.id &&
      _todo == other._todo;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Task {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"todo=\\" + (_todo != null ? _todo!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Task copyWith({String? id, Todo? todo}) {
    return Task(
      id: id ?? this.id,
      todo: todo ?? this.todo);
  }
  
  Task.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _todo = json['todo']?['serializedData'] != null
        ? Todo.fromJson(new Map<String, dynamic>.from(json['todo']['serializedData']))
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'todo': _todo?.toJson()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'todo': _todo
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TODO = QueryField(
    fieldName: \\"todo\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Todo'));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Task\\";
    modelSchemaDefinition.pluralName = \\"Tasks\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Task.TODO,
      isRequired: false,
      targetName: 'taskTodoId',
      ofModelName: 'Todo'
    ));
  });
}

class _TaskModelType extends ModelType<Task> {
  const _TaskModelType();
  
  @override
  Task fromJson(Map<String, dynamic> jsonData) {
    return Task.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Task';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should support connection directive with keyName and fields 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Blog type in your schema. */
@immutable
class Blog extends Model {
  static const classType = const _BlogModelType();
  final String id;
  final String? _name;
  final List<Post>? _posts;
  final List<String>? _test;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Post>? get posts {
    return _posts;
  }
  
  List<String>? get test {
    return _test;
  }
  
  const Blog._internal({required this.id, required name, posts, test}): _name = name, _posts = posts, _test = test;
  
  factory Blog({String? id, required String name, List<Post>? posts, List<String>? test}) {
    return Blog._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      posts: posts != null ? List<Post>.unmodifiable(posts) : posts,
      test: test != null ? List<String>.unmodifiable(test) : test);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Blog &&
      id == other.id &&
      _name == other._name &&
      DeepCollectionEquality().equals(_posts, other._posts) &&
      DeepCollectionEquality().equals(_test, other._test);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Blog {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"test=\\" + (_test != null ? _test!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Blog copyWith({String? id, String? name, List<Post>? posts, List<String>? test}) {
    return Blog(
      id: id ?? this.id,
      name: name ?? this.name,
      posts: posts ?? this.posts,
      test: test ?? this.test);
  }
  
  Blog.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _posts = json['posts'] is List
        ? (json['posts'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Post.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null,
      _test = json['test']?.cast<String>();
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'posts': _posts?.map((Post? e) => e?.toJson()).toList(), 'test': _test
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'posts': _posts,
    'test': _test
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField POSTS = QueryField(
    fieldName: \\"posts\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Post'));
  static final QueryField TEST = QueryField(fieldName: \\"test\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Blog\\";
    modelSchemaDefinition.pluralName = \\"Blogs\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Blog.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Blog.POSTS,
      isRequired: false,
      ofModelName: 'Post',
      associatedKey: Post.BLOG
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Blog.TEST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.string))
    ));
  });
}

class _BlogModelType extends ModelType<Blog> {
  const _BlogModelType();
  
  @override
  Blog fromJson(Map<String, dynamic> jsonData) {
    return Blog.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Blog';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should support connection directive with keyName and fields 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final Post? _post;
  final String? _content;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  Post? get post {
    return _post;
  }
  
  String get content {
    try {
      return _content!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Comment._internal({required this.id, post, required content}): _post = post, _content = content;
  
  factory Comment({String? id, Post? post, required String content}) {
    return Comment._internal(
      id: id == null ? UUID.getUUID() : id,
      post: post,
      content: content);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
      id == other.id &&
      _post == other._post &&
      _content == other._content;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (_post != null ? _post!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment copyWith({String? id, Post? post, String? content}) {
    return Comment(
      id: id ?? this.id,
      post: post ?? this.post,
      content: content ?? this.content);
  }
  
  Comment.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _post = json['post']?['serializedData'] != null
        ? Post.fromJson(new Map<String, dynamic>.from(json['post']['serializedData']))
        : null,
      _content = json['content'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'post': _post?.toJson(), 'content': _content
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'post': _post,
    'content': _content
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField POST = QueryField(
    fieldName: \\"post\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Post'));
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"postID\\", \\"content\\"], name: \\"byPost\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Comment.POST,
      isRequired: false,
      targetName: 'postID',
      ofModelName: 'Post'
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.CONTENT,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();
  
  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Comment';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should support connection directive with keyName and fields 3`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final Blog? _blog;
  final List<Comment>? _comments;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Blog? get blog {
    return _blog;
  }
  
  List<Comment>? get comments {
    return _comments;
  }
  
  const Post._internal({required this.id, required title, blog, comments}): _title = title, _blog = blog, _comments = comments;
  
  factory Post({String? id, required String title, Blog? blog, List<Comment>? comments}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      blog: blog,
      comments: comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      _blog == other._blog &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"blog=\\" + (_blog != null ? _blog!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, Blog? blog, List<Comment>? comments}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      blog: blog ?? this.blog,
      comments: comments ?? this.comments);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _blog = json['blog']?['serializedData'] != null
        ? Blog.fromJson(new Map<String, dynamic>.from(json['blog']['serializedData']))
        : null,
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'blog': _blog?.toJson(), 'comments': _comments?.map((Comment? e) => e?.toJson()).toList()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'title': _title,
    'blog': _blog,
    'comments': _comments
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField BLOG = QueryField(
    fieldName: \\"blog\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Blog'));
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Comment'));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"blogID\\"], name: \\"byBlog\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Post.BLOG,
      isRequired: false,
      targetName: 'blogID',
      ofModelName: 'Blog'
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.COMMENTS,
      isRequired: false,
      ofModelName: 'Comment',
      associatedKey: Comment.POST
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Post';
  }
}"
`;

exports[`AppSync Dart Visitor Model with Key Directive should generate a class for model with key directive 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the authorBook type in your schema. */
@immutable
class authorBook extends Model {
  static const classType = const _authorBookModelType();
  final String id;
  final String? _author_id;
  final String? _book_id;
  final String? _author;
  final String? _book;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get author_id {
    try {
      return _author_id!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get book_id {
    try {
      return _book_id!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String? get author {
    return _author;
  }
  
  String? get book {
    return _book;
  }
  
  const authorBook._internal({required this.id, required author_id, required book_id, author, book}): _author_id = author_id, _book_id = book_id, _author = author, _book = book;
  
  factory authorBook({String? id, required String author_id, required String book_id, String? author, String? book}) {
    return authorBook._internal(
      id: id == null ? UUID.getUUID() : id,
      author_id: author_id,
      book_id: book_id,
      author: author,
      book: book);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is authorBook &&
      id == other.id &&
      _author_id == other._author_id &&
      _book_id == other._book_id &&
      _author == other._author &&
      _book == other._book;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"authorBook {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"author_id=\\" + \\"$_author_id\\" + \\", \\");
    buffer.write(\\"book_id=\\" + \\"$_book_id\\" + \\", \\");
    buffer.write(\\"author=\\" + \\"$_author\\" + \\", \\");
    buffer.write(\\"book=\\" + \\"$_book\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  authorBook copyWith({String? id, String? author_id, String? book_id, String? author, String? book}) {
    return authorBook(
      id: id ?? this.id,
      author_id: author_id ?? this.author_id,
      book_id: book_id ?? this.book_id,
      author: author ?? this.author,
      book: book ?? this.book);
  }
  
  authorBook.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _author_id = json['author_id'],
      _book_id = json['book_id'],
      _author = json['author'],
      _book = json['book'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'author_id': _author_id, 'book_id': _book_id, 'author': _author, 'book': _book
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'author_id': _author_id,
    'book_id': _book_id,
    'author': _author,
    'book': _book
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField AUTHOR_ID = QueryField(fieldName: \\"author_id\\");
  static final QueryField BOOK_ID = QueryField(fieldName: \\"book_id\\");
  static final QueryField AUTHOR = QueryField(fieldName: \\"author\\");
  static final QueryField BOOK = QueryField(fieldName: \\"book\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"authorBook\\";
    modelSchemaDefinition.pluralName = \\"authorBooks\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"author_id\\"], name: \\"byAuthor\\"),
      ModelIndex(fields: const [\\"book_id\\"], name: \\"byBook\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: authorBook.AUTHOR_ID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: authorBook.BOOK_ID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: authorBook.AUTHOR,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: authorBook.BOOK,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _authorBookModelType extends ModelType<authorBook> {
  const _authorBookModelType();
  
  @override
  authorBook fromJson(Map<String, dynamic> jsonData) {
    return authorBook.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'authorBook';
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct internal constructor for a model has only ID field 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TestModel type in your schema. */
@immutable
class TestModel extends Model {
  static const classType = const _TestModelModelType();
  final String id;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  const TestModel._internal({required this.id});
  
  factory TestModel({String? id}) {
    return TestModel._internal(
      id: id == null ? UUID.getUUID() : id);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestModel &&
      id == other.id;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TestModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TestModel copyWith({String? id}) {
    return TestModel(
      id: id ?? this.id);
  }
  
  TestModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'];
  
  Map<String, dynamic> toJson() => {
    'id': id
  };
  
  Map<String, Object?> toMap() => {
    'id': id
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestModel\\";
    modelSchemaDefinition.pluralName = \\"TestModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
  });
}

class _TestModelModelType extends ModelType<TestModel> {
  const _TestModelModelType();
  
  @override
  TestModel fromJson(Map<String, dynamic> jsonData) {
    return TestModel.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'TestModel';
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct model files with nullsafety 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Blog type in your schema. */
@immutable
class Blog extends Model {
  static const classType = const _BlogModelType();
  final String id;
  final String? _name;
  final List<Post>? _posts;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Post>? get posts {
    return _posts;
  }
  
  const Blog._internal({required this.id, required name, posts}): _name = name, _posts = posts;
  
  factory Blog({String? id, required String name, List<Post>? posts}) {
    return Blog._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      posts: posts != null ? List<Post>.unmodifiable(posts) : posts);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Blog &&
      id == other.id &&
      _name == other._name &&
      DeepCollectionEquality().equals(_posts, other._posts);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Blog {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Blog copyWith({String? id, String? name, List<Post>? posts}) {
    return Blog(
      id: id ?? this.id,
      name: name ?? this.name,
      posts: posts ?? this.posts);
  }
  
  Blog.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _posts = json['posts'] is List
        ? (json['posts'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Post.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'posts': _posts?.map((Post? e) => e?.toJson()).toList()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'posts': _posts
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField POSTS = QueryField(
    fieldName: \\"posts\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Post'));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Blog\\";
    modelSchemaDefinition.pluralName = \\"Blogs\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Blog.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Blog.POSTS,
      isRequired: false,
      ofModelName: 'Post',
      associatedKey: Post.BLOG
    ));
  });
}

class _BlogModelType extends ModelType<Blog> {
  const _BlogModelType();
  
  @override
  Blog fromJson(Map<String, dynamic> jsonData) {
    return Blog.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Blog';
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct model files with nullsafety 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final Post? _post;
  final String? _content;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  Post? get post {
    return _post;
  }
  
  String get content {
    try {
      return _content!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Comment._internal({required this.id, post, required content}): _post = post, _content = content;
  
  factory Comment({String? id, Post? post, required String content}) {
    return Comment._internal(
      id: id == null ? UUID.getUUID() : id,
      post: post,
      content: content);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
      id == other.id &&
      _post == other._post &&
      _content == other._content;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (_post != null ? _post!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment copyWith({String? id, Post? post, String? content}) {
    return Comment(
      id: id ?? this.id,
      post: post ?? this.post,
      content: content ?? this.content);
  }
  
  Comment.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _post = json['post']?['serializedData'] != null
        ? Post.fromJson(new Map<String, dynamic>.from(json['post']['serializedData']))
        : null,
      _content = json['content'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'post': _post?.toJson(), 'content': _content
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'post': _post,
    'content': _content
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField POST = QueryField(
    fieldName: \\"post\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Post'));
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"postID\\", \\"content\\"], name: \\"byPost\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Comment.POST,
      isRequired: false,
      targetName: 'postID',
      ofModelName: 'Post'
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.CONTENT,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();
  
  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Comment';
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct model files with nullsafety 3`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final Blog? _blog;
  final List<Comment>? _comments;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Blog? get blog {
    return _blog;
  }
  
  List<Comment>? get comments {
    return _comments;
  }
  
  const Post._internal({required this.id, required title, blog, comments}): _title = title, _blog = blog, _comments = comments;
  
  factory Post({String? id, required String title, Blog? blog, List<Comment>? comments}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      blog: blog,
      comments: comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      _blog == other._blog &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"blog=\\" + (_blog != null ? _blog!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, Blog? blog, List<Comment>? comments}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      blog: blog ?? this.blog,
      comments: comments ?? this.comments);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _blog = json['blog']?['serializedData'] != null
        ? Blog.fromJson(new Map<String, dynamic>.from(json['blog']['serializedData']))
        : null,
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'blog': _blog?.toJson(), 'comments': _comments?.map((Comment? e) => e?.toJson()).toList()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'title': _title,
    'blog': _blog,
    'comments': _comments
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField BLOG = QueryField(
    fieldName: \\"blog\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Blog'));
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Comment'));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"blogID\\"], name: \\"byBlog\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Post.BLOG,
      isRequired: false,
      targetName: 'blogID',
      ofModelName: 'Blog'
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.COMMENTS,
      isRequired: false,
      ofModelName: 'Comment',
      associatedKey: Comment.POST
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Post';
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct null safe output for regular field w/o list or nullable 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TestModel type in your schema. */
@immutable
class TestModel extends Model {
  static const classType = const _TestModelModelType();
  final String id;
  final double? _floatVal;
  final double? _floatNullableVal;
  final List<double>? _floatList;
  final List<double>? _floatNullableList;
  final List<double>? _nullableFloatList;
  final List<double>? _nullableFloatNullableList;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  double get floatVal {
    try {
      return _floatVal!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  double? get floatNullableVal {
    return _floatNullableVal;
  }
  
  List<double> get floatList {
    try {
      return _floatList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<double>? get floatNullableList {
    return _floatNullableList;
  }
  
  List<double> get nullableFloatList {
    try {
      return _nullableFloatList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<double>? get nullableFloatNullableList {
    return _nullableFloatNullableList;
  }
  
  const TestModel._internal({required this.id, required floatVal, floatNullableVal, required floatList, floatNullableList, required nullableFloatList, nullableFloatNullableList}): _floatVal = floatVal, _floatNullableVal = floatNullableVal, _floatList = floatList, _floatNullableList = floatNullableList, _nullableFloatList = nullableFloatList, _nullableFloatNullableList = nullableFloatNullableList;
  
  factory TestModel({String? id, required double floatVal, double? floatNullableVal, required List<double> floatList, List<double>? floatNullableList, required List<double> nullableFloatList, List<double>? nullableFloatNullableList}) {
    return TestModel._internal(
      id: id == null ? UUID.getUUID() : id,
      floatVal: floatVal,
      floatNullableVal: floatNullableVal,
      floatList: floatList != null ? List<double>.unmodifiable(floatList) : floatList,
      floatNullableList: floatNullableList != null ? List<double>.unmodifiable(floatNullableList) : floatNullableList,
      nullableFloatList: nullableFloatList != null ? List<double>.unmodifiable(nullableFloatList) : nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList != null ? List<double>.unmodifiable(nullableFloatNullableList) : nullableFloatNullableList);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestModel &&
      id == other.id &&
      _floatVal == other._floatVal &&
      _floatNullableVal == other._floatNullableVal &&
      DeepCollectionEquality().equals(_floatList, other._floatList) &&
      DeepCollectionEquality().equals(_floatNullableList, other._floatNullableList) &&
      DeepCollectionEquality().equals(_nullableFloatList, other._nullableFloatList) &&
      DeepCollectionEquality().equals(_nullableFloatNullableList, other._nullableFloatNullableList);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TestModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"floatVal=\\" + (_floatVal != null ? _floatVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableVal=\\" + (_floatNullableVal != null ? _floatNullableVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatList=\\" + (_floatList != null ? _floatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableList=\\" + (_floatNullableList != null ? _floatNullableList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatList=\\" + (_nullableFloatList != null ? _nullableFloatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatNullableList=\\" + (_nullableFloatNullableList != null ? _nullableFloatNullableList!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TestModel copyWith({String? id, double? floatVal, double? floatNullableVal, List<double>? floatList, List<double>? floatNullableList, List<double>? nullableFloatList, List<double>? nullableFloatNullableList}) {
    return TestModel(
      id: id ?? this.id,
      floatVal: floatVal ?? this.floatVal,
      floatNullableVal: floatNullableVal ?? this.floatNullableVal,
      floatList: floatList ?? this.floatList,
      floatNullableList: floatNullableList ?? this.floatNullableList,
      nullableFloatList: nullableFloatList ?? this.nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList ?? this.nullableFloatNullableList);
  }
  
  TestModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _floatVal = (json['floatVal'] as num?)?.toDouble(),
      _floatNullableVal = (json['floatNullableVal'] as num?)?.toDouble(),
      _floatList = (json['floatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _floatNullableList = (json['floatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatList = (json['nullableFloatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatNullableList = (json['nullableFloatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList();
  
  Map<String, dynamic> toJson() => {
    'id': id, 'floatVal': _floatVal, 'floatNullableVal': _floatNullableVal, 'floatList': _floatList, 'floatNullableList': _floatNullableList, 'nullableFloatList': _nullableFloatList, 'nullableFloatNullableList': _nullableFloatNullableList
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'floatVal': _floatVal,
    'floatNullableVal': _floatNullableVal,
    'floatList': _floatList,
    'floatNullableList': _floatNullableList,
    'nullableFloatList': _nullableFloatList,
    'nullableFloatNullableList': _nullableFloatNullableList
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField FLOATVAL = QueryField(fieldName: \\"floatVal\\");
  static final QueryField FLOATNULLABLEVAL = QueryField(fieldName: \\"floatNullableVal\\");
  static final QueryField FLOATLIST = QueryField(fieldName: \\"floatList\\");
  static final QueryField FLOATNULLABLELIST = QueryField(fieldName: \\"floatNullableList\\");
  static final QueryField NULLABLEFLOATLIST = QueryField(fieldName: \\"nullableFloatList\\");
  static final QueryField NULLABLEFLOATNULLABLELIST = QueryField(fieldName: \\"nullableFloatNullableList\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestModel\\";
    modelSchemaDefinition.pluralName = \\"TestModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATVAL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLEVAL,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
  });
}

class _TestModelModelType extends ModelType<TestModel> {
  const _TestModelModelType();
  
  @override
  TestModel fromJson(Map<String, dynamic> jsonData) {
    return TestModel.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'TestModel';
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct null safe output for regular scalar/list fields 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TestModel type in your schema. */
@immutable
class TestModel extends Model {
  static const classType = const _TestModelModelType();
  final String id;
  final double? _floatVal;
  final double? _floatNullableVal;
  final List<double>? _floatList;
  final List<double>? _floatNullableList;
  final List<double>? _nullableFloatList;
  final List<double>? _nullableFloatNullableList;
  final int? _intVal;
  final int? _intNullableVal;
  final List<int>? _intList;
  final List<int>? _intNullableList;
  final List<int>? _nullableIntList;
  final List<int>? _nullableIntNullableList;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  double get floatVal {
    try {
      return _floatVal!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  double? get floatNullableVal {
    return _floatNullableVal;
  }
  
  List<double> get floatList {
    try {
      return _floatList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<double>? get floatNullableList {
    return _floatNullableList;
  }
  
  List<double> get nullableFloatList {
    try {
      return _nullableFloatList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<double>? get nullableFloatNullableList {
    return _nullableFloatNullableList;
  }
  
  int get intVal {
    try {
      return _intVal!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  int? get intNullableVal {
    return _intNullableVal;
  }
  
  List<int> get intList {
    try {
      return _intList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<int>? get intNullableList {
    return _intNullableList;
  }
  
  List<int> get nullableIntList {
    try {
      return _nullableIntList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<int>? get nullableIntNullableList {
    return _nullableIntNullableList;
  }
  
  const TestModel._internal({required this.id, required floatVal, floatNullableVal, required floatList, floatNullableList, required nullableFloatList, nullableFloatNullableList, required intVal, intNullableVal, required intList, intNullableList, required nullableIntList, nullableIntNullableList}): _floatVal = floatVal, _floatNullableVal = floatNullableVal, _floatList = floatList, _floatNullableList = floatNullableList, _nullableFloatList = nullableFloatList, _nullableFloatNullableList = nullableFloatNullableList, _intVal = intVal, _intNullableVal = intNullableVal, _intList = intList, _intNullableList = intNullableList, _nullableIntList = nullableIntList, _nullableIntNullableList = nullableIntNullableList;
  
  factory TestModel({String? id, required double floatVal, double? floatNullableVal, required List<double> floatList, List<double>? floatNullableList, required List<double> nullableFloatList, List<double>? nullableFloatNullableList, required int intVal, int? intNullableVal, required List<int> intList, List<int>? intNullableList, required List<int> nullableIntList, List<int>? nullableIntNullableList}) {
    return TestModel._internal(
      id: id == null ? UUID.getUUID() : id,
      floatVal: floatVal,
      floatNullableVal: floatNullableVal,
      floatList: floatList != null ? List<double>.unmodifiable(floatList) : floatList,
      floatNullableList: floatNullableList != null ? List<double>.unmodifiable(floatNullableList) : floatNullableList,
      nullableFloatList: nullableFloatList != null ? List<double>.unmodifiable(nullableFloatList) : nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList != null ? List<double>.unmodifiable(nullableFloatNullableList) : nullableFloatNullableList,
      intVal: intVal,
      intNullableVal: intNullableVal,
      intList: intList != null ? List<int>.unmodifiable(intList) : intList,
      intNullableList: intNullableList != null ? List<int>.unmodifiable(intNullableList) : intNullableList,
      nullableIntList: nullableIntList != null ? List<int>.unmodifiable(nullableIntList) : nullableIntList,
      nullableIntNullableList: nullableIntNullableList != null ? List<int>.unmodifiable(nullableIntNullableList) : nullableIntNullableList);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestModel &&
      id == other.id &&
      _floatVal == other._floatVal &&
      _floatNullableVal == other._floatNullableVal &&
      DeepCollectionEquality().equals(_floatList, other._floatList) &&
      DeepCollectionEquality().equals(_floatNullableList, other._floatNullableList) &&
      DeepCollectionEquality().equals(_nullableFloatList, other._nullableFloatList) &&
      DeepCollectionEquality().equals(_nullableFloatNullableList, other._nullableFloatNullableList) &&
      _intVal == other._intVal &&
      _intNullableVal == other._intNullableVal &&
      DeepCollectionEquality().equals(_intList, other._intList) &&
      DeepCollectionEquality().equals(_intNullableList, other._intNullableList) &&
      DeepCollectionEquality().equals(_nullableIntList, other._nullableIntList) &&
      DeepCollectionEquality().equals(_nullableIntNullableList, other._nullableIntNullableList);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TestModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"floatVal=\\" + (_floatVal != null ? _floatVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableVal=\\" + (_floatNullableVal != null ? _floatNullableVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatList=\\" + (_floatList != null ? _floatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableList=\\" + (_floatNullableList != null ? _floatNullableList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatList=\\" + (_nullableFloatList != null ? _nullableFloatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatNullableList=\\" + (_nullableFloatNullableList != null ? _nullableFloatNullableList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intVal=\\" + (_intVal != null ? _intVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intNullableVal=\\" + (_intNullableVal != null ? _intNullableVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intList=\\" + (_intList != null ? _intList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intNullableList=\\" + (_intNullableList != null ? _intNullableList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableIntList=\\" + (_nullableIntList != null ? _nullableIntList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableIntNullableList=\\" + (_nullableIntNullableList != null ? _nullableIntNullableList!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TestModel copyWith({String? id, double? floatVal, double? floatNullableVal, List<double>? floatList, List<double>? floatNullableList, List<double>? nullableFloatList, List<double>? nullableFloatNullableList, int? intVal, int? intNullableVal, List<int>? intList, List<int>? intNullableList, List<int>? nullableIntList, List<int>? nullableIntNullableList}) {
    return TestModel(
      id: id ?? this.id,
      floatVal: floatVal ?? this.floatVal,
      floatNullableVal: floatNullableVal ?? this.floatNullableVal,
      floatList: floatList ?? this.floatList,
      floatNullableList: floatNullableList ?? this.floatNullableList,
      nullableFloatList: nullableFloatList ?? this.nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList ?? this.nullableFloatNullableList,
      intVal: intVal ?? this.intVal,
      intNullableVal: intNullableVal ?? this.intNullableVal,
      intList: intList ?? this.intList,
      intNullableList: intNullableList ?? this.intNullableList,
      nullableIntList: nullableIntList ?? this.nullableIntList,
      nullableIntNullableList: nullableIntNullableList ?? this.nullableIntNullableList);
  }
  
  TestModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _floatVal = (json['floatVal'] as num?)?.toDouble(),
      _floatNullableVal = (json['floatNullableVal'] as num?)?.toDouble(),
      _floatList = (json['floatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _floatNullableList = (json['floatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatList = (json['nullableFloatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatNullableList = (json['nullableFloatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _intVal = (json['intVal'] as num?)?.toInt(),
      _intNullableVal = (json['intNullableVal'] as num?)?.toInt(),
      _intList = (json['intList'] as List?)?.map((e) => (e as num).toInt()).toList(),
      _intNullableList = (json['intNullableList'] as List?)?.map((e) => (e as num).toInt()).toList(),
      _nullableIntList = (json['nullableIntList'] as List?)?.map((e) => (e as num).toInt()).toList(),
      _nullableIntNullableList = (json['nullableIntNullableList'] as List?)?.map((e) => (e as num).toInt()).toList();
  
  Map<String, dynamic> toJson() => {
    'id': id, 'floatVal': _floatVal, 'floatNullableVal': _floatNullableVal, 'floatList': _floatList, 'floatNullableList': _floatNullableList, 'nullableFloatList': _nullableFloatList, 'nullableFloatNullableList': _nullableFloatNullableList, 'intVal': _intVal, 'intNullableVal': _intNullableVal, 'intList': _intList, 'intNullableList': _intNullableList, 'nullableIntList': _nullableIntList, 'nullableIntNullableList': _nullableIntNullableList
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'floatVal': _floatVal,
    'floatNullableVal': _floatNullableVal,
    'floatList': _floatList,
    'floatNullableList': _floatNullableList,
    'nullableFloatList': _nullableFloatList,
    'nullableFloatNullableList': _nullableFloatNullableList,
    'intVal': _intVal,
    'intNullableVal': _intNullableVal,
    'intList': _intList,
    'intNullableList': _intNullableList,
    'nullableIntList': _nullableIntList,
    'nullableIntNullableList': _nullableIntNullableList
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField FLOATVAL = QueryField(fieldName: \\"floatVal\\");
  static final QueryField FLOATNULLABLEVAL = QueryField(fieldName: \\"floatNullableVal\\");
  static final QueryField FLOATLIST = QueryField(fieldName: \\"floatList\\");
  static final QueryField FLOATNULLABLELIST = QueryField(fieldName: \\"floatNullableList\\");
  static final QueryField NULLABLEFLOATLIST = QueryField(fieldName: \\"nullableFloatList\\");
  static final QueryField NULLABLEFLOATNULLABLELIST = QueryField(fieldName: \\"nullableFloatNullableList\\");
  static final QueryField INTVAL = QueryField(fieldName: \\"intVal\\");
  static final QueryField INTNULLABLEVAL = QueryField(fieldName: \\"intNullableVal\\");
  static final QueryField INTLIST = QueryField(fieldName: \\"intList\\");
  static final QueryField INTNULLABLELIST = QueryField(fieldName: \\"intNullableList\\");
  static final QueryField NULLABLEINTLIST = QueryField(fieldName: \\"nullableIntList\\");
  static final QueryField NULLABLEINTNULLABLELIST = QueryField(fieldName: \\"nullableIntNullableList\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestModel\\";
    modelSchemaDefinition.pluralName = \\"TestModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATVAL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLEVAL,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.INTVAL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.INTNULLABLEVAL,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.INTLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.int))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.INTNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.int))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEINTLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.int))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEINTNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.int))
    ));
  });
}

class _TestModelModelType extends ModelType<TestModel> {
  const _TestModelModelType();
  
  @override
  TestModel fromJson(Map<String, dynamic> jsonData) {
    return TestModel.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'TestModel';
  }
}"
`;

exports[`AppSync Dart Visitor Read-only Field Tests should generate the read-only timestamp fields when isTimestampFields is true 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String? _name;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const SimpleModel._internal({required this.id, name, createdAt, updatedAt}): _name = name, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory SimpleModel({String? id, String? name}) {
    return SimpleModel._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel &&
      id == other.id &&
      _name == other._name;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  SimpleModel copyWith({String? id, String? name}) {
    return SimpleModel._internal(
      id: id ?? this.id,
      name: name ?? this.name);
  }
  
  SimpleModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: SimpleModel.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();
  
  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'SimpleModel';
  }
}"
`;

exports[`AppSync Dart Visitor Read-only and Null Safety Combined Tests should generate the read-only timestamp fields when isTimestampFields is true and with null safety 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String? _name;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const SimpleModel._internal({required this.id, name, createdAt, updatedAt}): _name = name, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory SimpleModel({String? id, String? name}) {
    return SimpleModel._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel &&
      id == other.id &&
      _name == other._name;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  SimpleModel copyWith({String? id, String? name}) {
    return SimpleModel._internal(
      id: id ?? this.id,
      name: name ?? this.name);
  }
  
  SimpleModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: SimpleModel.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();
  
  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'SimpleModel';
  }
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct model and helper class for model that is NOT using custom primary key 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the ModelWithImplicitID type in your schema. */
@immutable
class ModelWithImplicitID extends Model {
  static const classType = const _ModelWithImplicitIDModelType();
  final String id;
  final String? _title;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  ModelWithImplicitIDModelIdentifier get modelIdentifier {
      return ModelWithImplicitIDModelIdentifier(
        id: id
      );
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const ModelWithImplicitID._internal({required this.id, required title, createdAt, updatedAt}): _title = title, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory ModelWithImplicitID({String? id, required String title}) {
    return ModelWithImplicitID._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ModelWithImplicitID &&
      id == other.id &&
      _title == other._title;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"ModelWithImplicitID {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  ModelWithImplicitID copyWith({String? title}) {
    return ModelWithImplicitID._internal(
      id: id,
      title: title ?? this.title);
  }
  
  ModelWithImplicitID.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'title': _title,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt
  };

  static final QueryModelIdentifier<ModelWithImplicitIDModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ModelWithImplicitIDModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"ModelWithImplicitID\\";
    modelSchemaDefinition.pluralName = \\"ModelWithImplicitIDS\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithImplicitID.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _ModelWithImplicitIDModelType extends ModelType<ModelWithImplicitID> {
  const _ModelWithImplicitIDModelType();
  
  @override
  ModelWithImplicitID fromJson(Map<String, dynamic> jsonData) {
    return ModelWithImplicitID.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'ModelWithImplicitID';
  }
}

/**
 * This is an auto generated class representing the model identifier
 * of [ModelWithImplicitID] in your schema.
 */
@immutable
class ModelWithImplicitIDModelIdentifier implements ModelIdentifier<ModelWithImplicitID> {
  final String id;

  /** Create an instance of ModelWithImplicitIDModelIdentifier using [id] the primary key. */
  const ModelWithImplicitIDModelIdentifier({
    required this.id});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ModelWithImplicitIDModelIdentifier(id: $id)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ModelWithImplicitIDModelIdentifier &&
      id == other.id;
  }
  
  @override
  int get hashCode =>
    id.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct model and helper class for model that is NOT using custom primary key 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the ModelWithExplicitID type in your schema. */
@immutable
class ModelWithExplicitID extends Model {
  static const classType = const _ModelWithExplicitIDModelType();
  final String id;
  final String? _title;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  ModelWithExplicitIDModelIdentifier get modelIdentifier {
      return ModelWithExplicitIDModelIdentifier(
        id: id
      );
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const ModelWithExplicitID._internal({required this.id, required title, createdAt, updatedAt}): _title = title, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory ModelWithExplicitID({String? id, required String title}) {
    return ModelWithExplicitID._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ModelWithExplicitID &&
      id == other.id &&
      _title == other._title;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"ModelWithExplicitID {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  ModelWithExplicitID copyWith({String? title}) {
    return ModelWithExplicitID._internal(
      id: id,
      title: title ?? this.title);
  }
  
  ModelWithExplicitID.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'title': _title,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt
  };

  static final QueryModelIdentifier<ModelWithExplicitIDModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ModelWithExplicitIDModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"ModelWithExplicitID\\";
    modelSchemaDefinition.pluralName = \\"ModelWithExplicitIDS\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitID.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _ModelWithExplicitIDModelType extends ModelType<ModelWithExplicitID> {
  const _ModelWithExplicitIDModelType();
  
  @override
  ModelWithExplicitID fromJson(Map<String, dynamic> jsonData) {
    return ModelWithExplicitID.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'ModelWithExplicitID';
  }
}

/**
 * This is an auto generated class representing the model identifier
 * of [ModelWithExplicitID] in your schema.
 */
@immutable
class ModelWithExplicitIDModelIdentifier implements ModelIdentifier<ModelWithExplicitID> {
  final String id;

  /** Create an instance of ModelWithExplicitIDModelIdentifier using [id] the primary key. */
  const ModelWithExplicitIDModelIdentifier({
    required this.id});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ModelWithExplicitIDModelIdentifier(id: $id)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ModelWithExplicitIDModelIdentifier &&
      id == other.id;
  }
  
  @override
  int get hashCode =>
    id.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct model and helper class for model that is NOT using custom primary key 3`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the ModelWithExplicitIDAndSDI type in your schema. */
@immutable
class ModelWithExplicitIDAndSDI extends Model {
  static const classType = const _ModelWithExplicitIDAndSDIModelType();
  final String id;
  final String? _parentID;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  ModelWithExplicitIDAndSDIModelIdentifier get modelIdentifier {
      return ModelWithExplicitIDAndSDIModelIdentifier(
        id: id
      );
  }
  
  String? get parentID {
    return _parentID;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const ModelWithExplicitIDAndSDI._internal({required this.id, parentID, createdAt, updatedAt}): _parentID = parentID, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory ModelWithExplicitIDAndSDI({String? id, String? parentID}) {
    return ModelWithExplicitIDAndSDI._internal(
      id: id == null ? UUID.getUUID() : id,
      parentID: parentID);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ModelWithExplicitIDAndSDI &&
      id == other.id &&
      _parentID == other._parentID;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"ModelWithExplicitIDAndSDI {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"parentID=\\" + \\"$_parentID\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  ModelWithExplicitIDAndSDI copyWith({String? parentID}) {
    return ModelWithExplicitIDAndSDI._internal(
      id: id,
      parentID: parentID ?? this.parentID);
  }
  
  ModelWithExplicitIDAndSDI.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _parentID = json['parentID'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'parentID': _parentID, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'parentID': _parentID,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt
  };

  static final QueryModelIdentifier<ModelWithExplicitIDAndSDIModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ModelWithExplicitIDAndSDIModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField PARENTID = QueryField(fieldName: \\"parentID\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"ModelWithExplicitIDAndSDI\\";
    modelSchemaDefinition.pluralName = \\"ModelWithExplicitIDAndSDIS\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"parentID\\"], name: \\"byParent\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitIDAndSDI.PARENTID,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _ModelWithExplicitIDAndSDIModelType extends ModelType<ModelWithExplicitIDAndSDI> {
  const _ModelWithExplicitIDAndSDIModelType();
  
  @override
  ModelWithExplicitIDAndSDI fromJson(Map<String, dynamic> jsonData) {
    return ModelWithExplicitIDAndSDI.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'ModelWithExplicitIDAndSDI';
  }
}

/**
 * This is an auto generated class representing the model identifier
 * of [ModelWithExplicitIDAndSDI] in your schema.
 */
@immutable
class ModelWithExplicitIDAndSDIModelIdentifier implements ModelIdentifier<ModelWithExplicitIDAndSDI> {
  final String id;

  /** Create an instance of ModelWithExplicitIDAndSDIModelIdentifier using [id] the primary key. */
  const ModelWithExplicitIDAndSDIModelIdentifier({
    required this.id});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ModelWithExplicitIDAndSDIModelIdentifier(id: $id)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ModelWithExplicitIDAndSDIModelIdentifier &&
      id == other.id;
  }
  
  @override
  int get hashCode =>
    id.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct model and helper class for model that is using \`id\` field as primary key plus sort keys 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the ModelWithIDPlusSortKeys type in your schema. */
@immutable
class ModelWithIDPlusSortKeys extends Model {
  static const classType = const _ModelWithIDPlusSortKeysModelType();
  final String id;
  final String? _title;
  final int? _rating;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  ModelWithIDPlusSortKeysModelIdentifier get modelIdentifier {
    try {
      return ModelWithIDPlusSortKeysModelIdentifier(
        id: id,
        title: _title!,
        rating: _rating!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  int get rating {
    try {
      return _rating!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const ModelWithIDPlusSortKeys._internal({required this.id, required title, required rating, createdAt, updatedAt}): _title = title, _rating = rating, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory ModelWithIDPlusSortKeys({String? id, required String title, required int rating}) {
    return ModelWithIDPlusSortKeys._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      rating: rating);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ModelWithIDPlusSortKeys &&
      id == other.id &&
      _title == other._title &&
      _rating == other._rating;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"ModelWithIDPlusSortKeys {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"rating=\\" + (_rating != null ? _rating!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  ModelWithIDPlusSortKeys copyWith() {
    return ModelWithIDPlusSortKeys._internal(
      id: id,
      title: title,
      rating: rating);
  }
  
  ModelWithIDPlusSortKeys.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _rating = (json['rating'] as num?)?.toInt(),
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'rating': _rating, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'title': _title,
    'rating': _rating,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt
  };

  static final QueryModelIdentifier<ModelWithIDPlusSortKeysModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ModelWithIDPlusSortKeysModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField RATING = QueryField(fieldName: \\"rating\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"ModelWithIDPlusSortKeys\\";
    modelSchemaDefinition.pluralName = \\"ModelWithIDPlusSortKeys\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"id\\", \\"title\\", \\"rating\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithIDPlusSortKeys.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithIDPlusSortKeys.RATING,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _ModelWithIDPlusSortKeysModelType extends ModelType<ModelWithIDPlusSortKeys> {
  const _ModelWithIDPlusSortKeysModelType();
  
  @override
  ModelWithIDPlusSortKeys fromJson(Map<String, dynamic> jsonData) {
    return ModelWithIDPlusSortKeys.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'ModelWithIDPlusSortKeys';
  }
}

/**
 * This is an auto generated class representing the model identifier
 * of [ModelWithIDPlusSortKeys] in your schema.
 */
@immutable
class ModelWithIDPlusSortKeysModelIdentifier implements ModelIdentifier<ModelWithIDPlusSortKeys> {
  final String id;
  final String title;
  final int rating;

  /**
   * Create an instance of ModelWithIDPlusSortKeysModelIdentifier using [id] the primary key.
   * And [title], [rating] the sort keys.
   */
  const ModelWithIDPlusSortKeysModelIdentifier({
    required this.id,
    required this.title,
    required this.rating});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id,
    'title': title,
    'rating': rating
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ModelWithIDPlusSortKeysModelIdentifier(id: $id, title: $title, rating: $rating)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ModelWithIDPlusSortKeysModelIdentifier &&
      id == other.id &&
      title == other.title &&
      rating == other.rating;
  }
  
  @override
  int get hashCode =>
    id.hashCode ^
    title.hashCode ^
    rating.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct model and helper class for model that is using custom primary key 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the ModelWithExplicitlyDefinedPK type in your schema. */
@immutable
class ModelWithExplicitlyDefinedPK extends Model {
  static const classType = const _ModelWithExplicitlyDefinedPKModelType();
  final String? _modelID;
  final String? _title;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => modelIdentifier.serializeAsString();
  
  ModelWithExplicitlyDefinedPKModelIdentifier get modelIdentifier {
    try {
      return ModelWithExplicitlyDefinedPKModelIdentifier(
        modelID: _modelID!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get modelID {
    try {
      return _modelID!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const ModelWithExplicitlyDefinedPK._internal({required modelID, required title, createdAt, updatedAt}): _modelID = modelID, _title = title, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory ModelWithExplicitlyDefinedPK({required String modelID, required String title}) {
    return ModelWithExplicitlyDefinedPK._internal(
      modelID: modelID,
      title: title);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ModelWithExplicitlyDefinedPK &&
      _modelID == other._modelID &&
      _title == other._title;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"ModelWithExplicitlyDefinedPK {\\");
    buffer.write(\\"modelID=\\" + \\"$_modelID\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  ModelWithExplicitlyDefinedPK copyWith({String? title}) {
    return ModelWithExplicitlyDefinedPK._internal(
      modelID: modelID,
      title: title ?? this.title);
  }
  
  ModelWithExplicitlyDefinedPK.fromJson(Map<String, dynamic> json)  
    : _modelID = json['modelID'],
      _title = json['title'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'modelID': _modelID, 'title': _title, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };
  
  Map<String, Object?> toMap() => {
    'modelID': _modelID,
    'title': _title,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt
  };

  static final QueryModelIdentifier<ModelWithExplicitlyDefinedPKModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ModelWithExplicitlyDefinedPKModelIdentifier>();
  static final QueryField MODELID = QueryField(fieldName: \\"modelID\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"ModelWithExplicitlyDefinedPK\\";
    modelSchemaDefinition.pluralName = \\"ModelWithExplicitlyDefinedPKS\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"modelID\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitlyDefinedPK.MODELID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitlyDefinedPK.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _ModelWithExplicitlyDefinedPKModelType extends ModelType<ModelWithExplicitlyDefinedPK> {
  const _ModelWithExplicitlyDefinedPKModelType();
  
  @override
  ModelWithExplicitlyDefinedPK fromJson(Map<String, dynamic> jsonData) {
    return ModelWithExplicitlyDefinedPK.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'ModelWithExplicitlyDefinedPK';
  }
}

/**
 * This is an auto generated class representing the model identifier
 * of [ModelWithExplicitlyDefinedPK] in your schema.
 */
@immutable
class ModelWithExplicitlyDefinedPKModelIdentifier implements ModelIdentifier<ModelWithExplicitlyDefinedPK> {
  final String modelID;

  /** Create an instance of ModelWithExplicitlyDefinedPKModelIdentifier using [modelID] the primary key. */
  const ModelWithExplicitlyDefinedPKModelIdentifier({
    required this.modelID});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'modelID': modelID
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ModelWithExplicitlyDefinedPKModelIdentifier(modelID: $modelID)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ModelWithExplicitlyDefinedPKModelIdentifier &&
      modelID == other.modelID;
  }
  
  @override
  int get hashCode =>
    modelID.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct model and helper class for model that is using custom primary key 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey type in your schema. */
@immutable
class ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey extends Model {
  static const classType = const _ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelType();
  final String? _modelID;
  final String? _title;
  final int? _rating;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => modelIdentifier.serializeAsString();
  
  ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier get modelIdentifier {
    try {
      return ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier(
        modelID: _modelID!,
        title: _title!,
        rating: _rating!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get modelID {
    try {
      return _modelID!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  int get rating {
    try {
      return _rating!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey._internal({required modelID, required title, required rating, createdAt, updatedAt}): _modelID = modelID, _title = title, _rating = rating, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey({required String modelID, required String title, required int rating}) {
    return ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey._internal(
      modelID: modelID,
      title: title,
      rating: rating);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey &&
      _modelID == other._modelID &&
      _title == other._title &&
      _rating == other._rating;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey {\\");
    buffer.write(\\"modelID=\\" + \\"$_modelID\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"rating=\\" + (_rating != null ? _rating!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey copyWith() {
    return ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey._internal(
      modelID: modelID,
      title: title,
      rating: rating);
  }
  
  ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey.fromJson(Map<String, dynamic> json)  
    : _modelID = json['modelID'],
      _title = json['title'],
      _rating = (json['rating'] as num?)?.toInt(),
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'modelID': _modelID, 'title': _title, 'rating': _rating, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };
  
  Map<String, Object?> toMap() => {
    'modelID': _modelID,
    'title': _title,
    'rating': _rating,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt
  };

  static final QueryModelIdentifier<ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier>();
  static final QueryField MODELID = QueryField(fieldName: \\"modelID\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField RATING = QueryField(fieldName: \\"rating\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey\\";
    modelSchemaDefinition.pluralName = \\"ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeys\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"modelID\\", \\"title\\", \\"rating\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey.MODELID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey.RATING,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelType extends ModelType<ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey> {
  const _ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelType();
  
  @override
  ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey fromJson(Map<String, dynamic> jsonData) {
    return ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey';
  }
}

/**
 * This is an auto generated class representing the model identifier
 * of [ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey] in your schema.
 */
@immutable
class ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier implements ModelIdentifier<ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey> {
  final String modelID;
  final String title;
  final int rating;

  /**
   * Create an instance of ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier using [modelID] the primary key.
   * And [title], [rating] the sort keys.
   */
  const ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier({
    required this.modelID,
    required this.title,
    required this.rating});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'modelID': modelID,
    'title': title,
    'rating': rating
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier(modelID: $modelID, title: $title, rating: $rating)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier &&
      modelID == other.modelID &&
      title == other.title &&
      rating == other.rating;
  }
  
  @override
  int get hashCode =>
    modelID.hashCode ^
    title.hashCode ^
    rating.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct models for hasMany uni relation when custom PK is enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final List<Comment>? _comments;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  PostModelIdentifier get modelIdentifier {
    try {
      return PostModelIdentifier(
        id: id,
        title: _title!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Comment>? get comments {
    return _comments;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const Post._internal({required this.id, required title, comments, createdAt, updatedAt}): _title = title, _comments = comments, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory Post({String? id, required String title, List<Comment>? comments}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      comments: comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({List<Comment>? comments}) {
    return Post._internal(
      id: id,
      title: title,
      comments: comments ?? this.comments);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null,
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'comments': _comments?.map((Comment? e) => e?.toJson()).toList(), 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'title': _title,
    'comments': _comments,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt
  };

  static final QueryModelIdentifier<PostModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<PostModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Comment'));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"id\\", \\"title\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.COMMENTS,
      isRequired: false,
      ofModelName: 'Comment',
      associatedKey: Comment.POSTCOMMENTSID
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Post';
  }
}

/**
 * This is an auto generated class representing the model identifier
 * of [Post] in your schema.
 */
@immutable
class PostModelIdentifier implements ModelIdentifier<Post> {
  final String id;
  final String title;

  /**
   * Create an instance of PostModelIdentifier using [id] the primary key.
   * And [title] the sort key.
   */
  const PostModelIdentifier({
    required this.id,
    required this.title});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id,
    'title': title
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'PostModelIdentifier(id: $id, title: $title)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is PostModelIdentifier &&
      id == other.id &&
      title == other.title;
  }
  
  @override
  int get hashCode =>
    id.hashCode ^
    title.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct models for hasMany uni relation when custom PK is enabled 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final String? _content;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;
  final String? _postCommentsId;
  final String? _postCommentsTitle;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  CommentModelIdentifier get modelIdentifier {
    try {
      return CommentModelIdentifier(
        id: id,
        content: _content!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get content {
    try {
      return _content!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  String? get postCommentsId {
    return _postCommentsId;
  }
  
  String? get postCommentsTitle {
    return _postCommentsTitle;
  }
  
  const Comment._internal({required this.id, required content, createdAt, updatedAt, postCommentsId, postCommentsTitle}): _content = content, _createdAt = createdAt, _updatedAt = updatedAt, _postCommentsId = postCommentsId, _postCommentsTitle = postCommentsTitle;
  
  factory Comment({String? id, required String content, String? postCommentsId, String? postCommentsTitle}) {
    return Comment._internal(
      id: id == null ? UUID.getUUID() : id,
      content: content,
      postCommentsId: postCommentsId,
      postCommentsTitle: postCommentsTitle);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
      id == other.id &&
      _content == other._content &&
      _postCommentsId == other._postCommentsId &&
      _postCommentsTitle == other._postCommentsTitle;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"postCommentsId=\\" + \\"$_postCommentsId\\" + \\", \\");
    buffer.write(\\"postCommentsTitle=\\" + \\"$_postCommentsTitle\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment copyWith({String? postCommentsId, String? postCommentsTitle}) {
    return Comment._internal(
      id: id,
      content: content,
      postCommentsId: postCommentsId ?? this.postCommentsId,
      postCommentsTitle: postCommentsTitle ?? this.postCommentsTitle);
  }
  
  Comment.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _content = json['content'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null,
      _postCommentsId = json['postCommentsId'],
      _postCommentsTitle = json['postCommentsTitle'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'content': _content, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format(), 'postCommentsId': _postCommentsId, 'postCommentsTitle': _postCommentsTitle
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'content': _content,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt,
    'postCommentsId': _postCommentsId,
    'postCommentsTitle': _postCommentsTitle
  };

  static final QueryModelIdentifier<CommentModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<CommentModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static final QueryField POSTCOMMENTSID = QueryField(fieldName: \\"postCommentsId\\");
  static final QueryField POSTCOMMENTSTITLE = QueryField(fieldName: \\"postCommentsTitle\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"id\\", \\"content\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.CONTENT,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.POSTCOMMENTSID,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.POSTCOMMENTSTITLE,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();
  
  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Comment';
  }
}

/**
 * This is an auto generated class representing the model identifier
 * of [Comment] in your schema.
 */
@immutable
class CommentModelIdentifier implements ModelIdentifier<Comment> {
  final String id;
  final String content;

  /**
   * Create an instance of CommentModelIdentifier using [id] the primary key.
   * And [content] the sort key.
   */
  const CommentModelIdentifier({
    required this.id,
    required this.content});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id,
    'content': content
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'CommentModelIdentifier(id: $id, content: $content)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is CommentModelIdentifier &&
      id == other.id &&
      content == other.content;
  }
  
  @override
  int get hashCode =>
    id.hashCode ^
    content.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct models for hasOne/belongsTo relation when custom PK is enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Project type in your schema. */
@immutable
class Project extends Model {
  static const classType = const _ProjectModelType();
  final String? _projectId;
  final String? _name;
  final Team? _team;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;
  final String? _projectTeamTeamId;
  final String? _projectTeamName;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => modelIdentifier.serializeAsString();
  
  ProjectModelIdentifier get modelIdentifier {
    try {
      return ProjectModelIdentifier(
        projectId: _projectId!,
        name: _name!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get projectId {
    try {
      return _projectId!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Team? get team {
    return _team;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  String? get projectTeamTeamId {
    return _projectTeamTeamId;
  }
  
  String? get projectTeamName {
    return _projectTeamName;
  }
  
  const Project._internal({required projectId, required name, team, createdAt, updatedAt, projectTeamTeamId, projectTeamName}): _projectId = projectId, _name = name, _team = team, _createdAt = createdAt, _updatedAt = updatedAt, _projectTeamTeamId = projectTeamTeamId, _projectTeamName = projectTeamName;
  
  factory Project({required String projectId, required String name, Team? team, String? projectTeamTeamId, String? projectTeamName}) {
    return Project._internal(
      projectId: projectId,
      name: name,
      team: team,
      projectTeamTeamId: projectTeamTeamId,
      projectTeamName: projectTeamName);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Project &&
      _projectId == other._projectId &&
      _name == other._name &&
      _team == other._team &&
      _projectTeamTeamId == other._projectTeamTeamId &&
      _projectTeamName == other._projectTeamName;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Project {\\");
    buffer.write(\\"projectId=\\" + \\"$_projectId\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"projectTeamTeamId=\\" + \\"$_projectTeamTeamId\\" + \\", \\");
    buffer.write(\\"projectTeamName=\\" + \\"$_projectTeamName\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Project copyWith({Team? team, String? projectTeamTeamId, String? projectTeamName}) {
    return Project._internal(
      projectId: projectId,
      name: name,
      team: team ?? this.team,
      projectTeamTeamId: projectTeamTeamId ?? this.projectTeamTeamId,
      projectTeamName: projectTeamName ?? this.projectTeamName);
  }
  
  Project.fromJson(Map<String, dynamic> json)  
    : _projectId = json['projectId'],
      _name = json['name'],
      _team = json['team']?['serializedData'] != null
        ? Team.fromJson(new Map<String, dynamic>.from(json['team']['serializedData']))
        : null,
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null,
      _projectTeamTeamId = json['projectTeamTeamId'],
      _projectTeamName = json['projectTeamName'];
  
  Map<String, dynamic> toJson() => {
    'projectId': _projectId, 'name': _name, 'team': _team?.toJson(), 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format(), 'projectTeamTeamId': _projectTeamTeamId, 'projectTeamName': _projectTeamName
  };
  
  Map<String, Object?> toMap() => {
    'projectId': _projectId,
    'name': _name,
    'team': _team,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt,
    'projectTeamTeamId': _projectTeamTeamId,
    'projectTeamName': _projectTeamName
  };

  static final QueryModelIdentifier<ProjectModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ProjectModelIdentifier>();
  static final QueryField PROJECTID = QueryField(fieldName: \\"projectId\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField TEAM = QueryField(
    fieldName: \\"team\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Team'));
  static final QueryField PROJECTTEAMTEAMID = QueryField(fieldName: \\"projectTeamTeamId\\");
  static final QueryField PROJECTTEAMNAME = QueryField(fieldName: \\"projectTeamName\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Project\\";
    modelSchemaDefinition.pluralName = \\"Projects\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"projectId\\", \\"name\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project.PROJECTID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasOne(
      key: Project.TEAM,
      isRequired: false,
      ofModelName: 'Team',
      associatedKey: Team.PROJECT
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project.PROJECTTEAMTEAMID,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project.PROJECTTEAMNAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _ProjectModelType extends ModelType<Project> {
  const _ProjectModelType();
  
  @override
  Project fromJson(Map<String, dynamic> jsonData) {
    return Project.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Project';
  }
}

/**
 * This is an auto generated class representing the model identifier
 * of [Project] in your schema.
 */
@immutable
class ProjectModelIdentifier implements ModelIdentifier<Project> {
  final String projectId;
  final String name;

  /**
   * Create an instance of ProjectModelIdentifier using [projectId] the primary key.
   * And [name] the sort key.
   */
  const ProjectModelIdentifier({
    required this.projectId,
    required this.name});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'projectId': projectId,
    'name': name
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ProjectModelIdentifier(projectId: $projectId, name: $name)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ProjectModelIdentifier &&
      projectId == other.projectId &&
      name == other.name;
  }
  
  @override
  int get hashCode =>
    projectId.hashCode ^
    name.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct models for hasOne/belongsTo relation when custom PK is enabled 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Team type in your schema. */
@immutable
class Team extends Model {
  static const classType = const _TeamModelType();
  final String? _teamId;
  final String? _name;
  final Project? _project;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => modelIdentifier.serializeAsString();
  
  TeamModelIdentifier get modelIdentifier {
    try {
      return TeamModelIdentifier(
        teamId: _teamId!,
        name: _name!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get teamId {
    try {
      return _teamId!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Project? get project {
    return _project;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const Team._internal({required teamId, required name, project, createdAt, updatedAt}): _teamId = teamId, _name = name, _project = project, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory Team({required String teamId, required String name, Project? project}) {
    return Team._internal(
      teamId: teamId,
      name: name,
      project: project);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Team &&
      _teamId == other._teamId &&
      _name == other._name &&
      _project == other._project;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Team {\\");
    buffer.write(\\"teamId=\\" + \\"$_teamId\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"project=\\" + (_project != null ? _project!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Team copyWith({Project? project}) {
    return Team._internal(
      teamId: teamId,
      name: name,
      project: project ?? this.project);
  }
  
  Team.fromJson(Map<String, dynamic> json)  
    : _teamId = json['teamId'],
      _name = json['name'],
      _project = json['project']?['serializedData'] != null
        ? Project.fromJson(new Map<String, dynamic>.from(json['project']['serializedData']))
        : null,
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'teamId': _teamId, 'name': _name, 'project': _project?.toJson(), 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };
  
  Map<String, Object?> toMap() => {
    'teamId': _teamId,
    'name': _name,
    'project': _project,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt
  };

  static final QueryModelIdentifier<TeamModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<TeamModelIdentifier>();
  static final QueryField TEAMID = QueryField(fieldName: \\"teamId\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField PROJECT = QueryField(
    fieldName: \\"project\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'Project'));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Team\\";
    modelSchemaDefinition.pluralName = \\"Teams\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"teamId\\", \\"name\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Team.TEAMID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Team.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Team.PROJECT,
      isRequired: false,
      targetNames: ['teamProjectProjectId', 'teamProjectName'],
      ofModelName: 'Project'
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _TeamModelType extends ModelType<Team> {
  const _TeamModelType();
  
  @override
  Team fromJson(Map<String, dynamic> jsonData) {
    return Team.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'Team';
  }
}

/**
 * This is an auto generated class representing the model identifier
 * of [Team] in your schema.
 */
@immutable
class TeamModelIdentifier implements ModelIdentifier<Team> {
  final String teamId;
  final String name;

  /**
   * Create an instance of TeamModelIdentifier using [teamId] the primary key.
   * And [name] the sort key.
   */
  const TeamModelIdentifier({
    required this.teamId,
    required this.name});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'teamId': teamId,
    'name': name
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'TeamModelIdentifier(teamId: $teamId, name: $name)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is TeamModelIdentifier &&
      teamId == other.teamId &&
      name == other.name;
  }
  
  @override
  int get hashCode =>
    teamId.hashCode ^
    name.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct models for hasOne/belongsTo relation when custom PK is enabled 3`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the CpkOneToOneBidirectionalParent type in your schema. */
@immutable
class CpkOneToOneBidirectionalParent extends Model {
  static const classType = const _CpkOneToOneBidirectionalParentModelType();
  final String id;
  final String? _name;
  final CpkOneToOneBidirectionalChildExplicit? _explicitChild;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;
  final String? _cpkOneToOneBidirectionalParentExplicitChildId;
  final String? _cpkOneToOneBidirectionalParentExplicitChildName;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  CpkOneToOneBidirectionalParentModelIdentifier get modelIdentifier {
    try {
      return CpkOneToOneBidirectionalParentModelIdentifier(
        id: id,
        name: _name!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  CpkOneToOneBidirectionalChildExplicit? get explicitChild {
    return _explicitChild;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  String? get cpkOneToOneBidirectionalParentExplicitChildId {
    return _cpkOneToOneBidirectionalParentExplicitChildId;
  }
  
  String? get cpkOneToOneBidirectionalParentExplicitChildName {
    return _cpkOneToOneBidirectionalParentExplicitChildName;
  }
  
  const CpkOneToOneBidirectionalParent._internal({required this.id, required name, explicitChild, createdAt, updatedAt, cpkOneToOneBidirectionalParentExplicitChildId, cpkOneToOneBidirectionalParentExplicitChildName}): _name = name, _explicitChild = explicitChild, _createdAt = createdAt, _updatedAt = updatedAt, _cpkOneToOneBidirectionalParentExplicitChildId = cpkOneToOneBidirectionalParentExplicitChildId, _cpkOneToOneBidirectionalParentExplicitChildName = cpkOneToOneBidirectionalParentExplicitChildName;
  
  factory CpkOneToOneBidirectionalParent({String? id, required String name, CpkOneToOneBidirectionalChildExplicit? explicitChild, String? cpkOneToOneBidirectionalParentExplicitChildId, String? cpkOneToOneBidirectionalParentExplicitChildName}) {
    return CpkOneToOneBidirectionalParent._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      explicitChild: explicitChild,
      cpkOneToOneBidirectionalParentExplicitChildId: cpkOneToOneBidirectionalParentExplicitChildId,
      cpkOneToOneBidirectionalParentExplicitChildName: cpkOneToOneBidirectionalParentExplicitChildName);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CpkOneToOneBidirectionalParent &&
      id == other.id &&
      _name == other._name &&
      _explicitChild == other._explicitChild &&
      _cpkOneToOneBidirectionalParentExplicitChildId == other._cpkOneToOneBidirectionalParentExplicitChildId &&
      _cpkOneToOneBidirectionalParentExplicitChildName == other._cpkOneToOneBidirectionalParentExplicitChildName;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"CpkOneToOneBidirectionalParent {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"cpkOneToOneBidirectionalParentExplicitChildId=\\" + \\"$_cpkOneToOneBidirectionalParentExplicitChildId\\" + \\", \\");
    buffer.write(\\"cpkOneToOneBidirectionalParentExplicitChildName=\\" + \\"$_cpkOneToOneBidirectionalParentExplicitChildName\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  CpkOneToOneBidirectionalParent copyWith({CpkOneToOneBidirectionalChildExplicit? explicitChild, String? cpkOneToOneBidirectionalParentExplicitChildId, String? cpkOneToOneBidirectionalParentExplicitChildName}) {
    return CpkOneToOneBidirectionalParent._internal(
      id: id,
      name: name,
      explicitChild: explicitChild ?? this.explicitChild,
      cpkOneToOneBidirectionalParentExplicitChildId: cpkOneToOneBidirectionalParentExplicitChildId ?? this.cpkOneToOneBidirectionalParentExplicitChildId,
      cpkOneToOneBidirectionalParentExplicitChildName: cpkOneToOneBidirectionalParentExplicitChildName ?? this.cpkOneToOneBidirectionalParentExplicitChildName);
  }
  
  CpkOneToOneBidirectionalParent.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _explicitChild = json['explicitChild']?['serializedData'] != null
        ? CpkOneToOneBidirectionalChildExplicit.fromJson(new Map<String, dynamic>.from(json['explicitChild']['serializedData']))
        : null,
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null,
      _cpkOneToOneBidirectionalParentExplicitChildId = json['cpkOneToOneBidirectionalParentExplicitChildId'],
      _cpkOneToOneBidirectionalParentExplicitChildName = json['cpkOneToOneBidirectionalParentExplicitChildName'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'explicitChild': _explicitChild?.toJson(), 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format(), 'cpkOneToOneBidirectionalParentExplicitChildId': _cpkOneToOneBidirectionalParentExplicitChildId, 'cpkOneToOneBidirectionalParentExplicitChildName': _cpkOneToOneBidirectionalParentExplicitChildName
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'explicitChild': _explicitChild,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt,
    'cpkOneToOneBidirectionalParentExplicitChildId': _cpkOneToOneBidirectionalParentExplicitChildId,
    'cpkOneToOneBidirectionalParentExplicitChildName': _cpkOneToOneBidirectionalParentExplicitChildName
  };

  static final QueryModelIdentifier<CpkOneToOneBidirectionalParentModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<CpkOneToOneBidirectionalParentModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField EXPLICITCHILD = QueryField(
    fieldName: \\"explicitChild\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'CpkOneToOneBidirectionalChildExplicit'));
  static final QueryField CPKONETOONEBIDIRECTIONALPARENTEXPLICITCHILDID = QueryField(fieldName: \\"cpkOneToOneBidirectionalParentExplicitChildId\\");
  static final QueryField CPKONETOONEBIDIRECTIONALPARENTEXPLICITCHILDNAME = QueryField(fieldName: \\"cpkOneToOneBidirectionalParentExplicitChildName\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"CpkOneToOneBidirectionalParent\\";
    modelSchemaDefinition.pluralName = \\"CpkOneToOneBidirectionalParents\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"id\\", \\"name\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: CpkOneToOneBidirectionalParent.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasOne(
      key: CpkOneToOneBidirectionalParent.EXPLICITCHILD,
      isRequired: false,
      ofModelName: 'CpkOneToOneBidirectionalChildExplicit',
      associatedKey: CpkOneToOneBidirectionalChildExplicit.BELONGSTOPARENT
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: CpkOneToOneBidirectionalParent.CPKONETOONEBIDIRECTIONALPARENTEXPLICITCHILDID,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: CpkOneToOneBidirectionalParent.CPKONETOONEBIDIRECTIONALPARENTEXPLICITCHILDNAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CpkOneToOneBidirectionalParentModelType extends ModelType<CpkOneToOneBidirectionalParent> {
  const _CpkOneToOneBidirectionalParentModelType();
  
  @override
  CpkOneToOneBidirectionalParent fromJson(Map<String, dynamic> jsonData) {
    return CpkOneToOneBidirectionalParent.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'CpkOneToOneBidirectionalParent';
  }
}

/**
 * This is an auto generated class representing the model identifier
 * of [CpkOneToOneBidirectionalParent] in your schema.
 */
@immutable
class CpkOneToOneBidirectionalParentModelIdentifier implements ModelIdentifier<CpkOneToOneBidirectionalParent> {
  final String id;
  final String name;

  /**
   * Create an instance of CpkOneToOneBidirectionalParentModelIdentifier using [id] the primary key.
   * And [name] the sort key.
   */
  const CpkOneToOneBidirectionalParentModelIdentifier({
    required this.id,
    required this.name});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id,
    'name': name
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'CpkOneToOneBidirectionalParentModelIdentifier(id: $id, name: $name)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is CpkOneToOneBidirectionalParentModelIdentifier &&
      id == other.id &&
      name == other.name;
  }
  
  @override
  int get hashCode =>
    id.hashCode ^
    name.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct models for hasOne/belongsTo relation when custom PK is enabled 4`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the CpkOneToOneBidirectionalChildExplicit type in your schema. */
@immutable
class CpkOneToOneBidirectionalChildExplicit extends Model {
  static const classType = const _CpkOneToOneBidirectionalChildExplicitModelType();
  final String id;
  final String? _name;
  final CpkOneToOneBidirectionalParent? _belongsToParent;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  CpkOneToOneBidirectionalChildExplicitModelIdentifier get modelIdentifier {
    try {
      return CpkOneToOneBidirectionalChildExplicitModelIdentifier(
        id: id,
        name: _name!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  CpkOneToOneBidirectionalParent? get belongsToParent {
    return _belongsToParent;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const CpkOneToOneBidirectionalChildExplicit._internal({required this.id, required name, belongsToParent, createdAt, updatedAt}): _name = name, _belongsToParent = belongsToParent, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory CpkOneToOneBidirectionalChildExplicit({String? id, required String name, CpkOneToOneBidirectionalParent? belongsToParent}) {
    return CpkOneToOneBidirectionalChildExplicit._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      belongsToParent: belongsToParent);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CpkOneToOneBidirectionalChildExplicit &&
      id == other.id &&
      _name == other._name &&
      _belongsToParent == other._belongsToParent;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"CpkOneToOneBidirectionalChildExplicit {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"belongsToParent=\\" + (_belongsToParent != null ? _belongsToParent!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  CpkOneToOneBidirectionalChildExplicit copyWith({CpkOneToOneBidirectionalParent? belongsToParent}) {
    return CpkOneToOneBidirectionalChildExplicit._internal(
      id: id,
      name: name,
      belongsToParent: belongsToParent ?? this.belongsToParent);
  }
  
  CpkOneToOneBidirectionalChildExplicit.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _belongsToParent = json['belongsToParent']?['serializedData'] != null
        ? CpkOneToOneBidirectionalParent.fromJson(new Map<String, dynamic>.from(json['belongsToParent']['serializedData']))
        : null,
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'belongsToParent': _belongsToParent?.toJson(), 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };
  
  Map<String, Object?> toMap() => {
    'id': id,
    'name': _name,
    'belongsToParent': _belongsToParent,
    'createdAt': _createdAt,
    'updatedAt': _updatedAt
  };

  static final QueryModelIdentifier<CpkOneToOneBidirectionalChildExplicitModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<CpkOneToOneBidirectionalChildExplicitModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BELONGSTOPARENT = QueryField(
    fieldName: \\"belongsToParent\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: 'CpkOneToOneBidirectionalParent'));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"CpkOneToOneBidirectionalChildExplicit\\";
    modelSchemaDefinition.pluralName = \\"CpkOneToOneBidirectionalChildExplicits\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"id\\", \\"name\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: CpkOneToOneBidirectionalChildExplicit.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: CpkOneToOneBidirectionalChildExplicit.BELONGSTOPARENT,
      isRequired: false,
      targetNames: ['belongsToParentID', 'belongsToParentName'],
      ofModelName: 'CpkOneToOneBidirectionalParent'
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _CpkOneToOneBidirectionalChildExplicitModelType extends ModelType<CpkOneToOneBidirectionalChildExplicit> {
  const _CpkOneToOneBidirectionalChildExplicitModelType();
  
  @override
  CpkOneToOneBidirectionalChildExplicit fromJson(Map<String, dynamic> jsonData) {
    return CpkOneToOneBidirectionalChildExplicit.fromJson(jsonData);
  }
  
  @override
  String modelName() {
    return 'CpkOneToOneBidirectionalChildExplicit';
  }
}

/**
 * This is an auto generated class representing the model identifier
 * of [CpkOneToOneBidirectionalChildExplicit] in your schema.
 */
@immutable
class CpkOneToOneBidirectionalChildExplicitModelIdentifier implements ModelIdentifier<CpkOneToOneBidirectionalChildExplicit> {
  final String id;
  final String name;

  /**
   * Create an instance of CpkOneToOneBidirectionalChildExplicitModelIdentifier using [id] the primary key.
   * And [name] the sort key.
   */
  const CpkOneToOneBidirectionalChildExplicitModelIdentifier({
    required this.id,
    required this.name});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id,
    'name': name
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'CpkOneToOneBidirectionalChildExplicitModelIdentifier(id: $id, name: $name)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is CpkOneToOneBidirectionalChildExplicitModelIdentifier &&
      id == other.id &&
      name == other.name;
  }
  
  @override
  int get hashCode =>
    id.hashCode ^
    name.hashCode;
}"
`;
