// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for Address with nullsafety disabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Address type in your schema. */
@immutable
class Address {
  final String line1;
  final String line2;
  final String city;
  final String state;
  final String postalCode;

  const Address._internal(
      {@required this.line1,
      this.line2,
      @required this.city,
      @required this.state,
      @required this.postalCode});

  factory Address(
      {@required String line1,
      String line2,
      @required String city,
      @required String state,
      @required String postalCode}) {
    return Address._internal(
        line1: line1,
        line2: line2,
        city: city,
        state: state,
        postalCode: postalCode);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Address &&
        line1 == other.line1 &&
        line2 == other.line2 &&
        city == other.city &&
        state == other.state &&
        postalCode == other.postalCode;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Address {\\");
    buffer.write(\\"line1=\\" + \\"$line1\\" + \\", \\");
    buffer.write(\\"line2=\\" + \\"$line2\\" + \\", \\");
    buffer.write(\\"city=\\" + \\"$city\\" + \\", \\");
    buffer.write(\\"state=\\" + \\"$state\\" + \\", \\");
    buffer.write(\\"postalCode=\\" + \\"$postalCode\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Address copyWith(
      {String line1,
      String line2,
      String city,
      String state,
      String postalCode}) {
    return Address(
        line1: line1 ?? this.line1,
        line2: line2 ?? this.line2,
        city: city ?? this.city,
        state: state ?? this.state,
        postalCode: postalCode ?? this.postalCode);
  }

  Address.fromJson(Map<String, dynamic> json)
      : line1 = json['line1'],
        line2 = json['line2'],
        city = json['city'],
        state = json['state'],
        postalCode = json['postalCode'];

  Map<String, dynamic> toJson() => {
        'line1': line1,
        'line2': line2,
        'city': city,
        'state': state,
        'postalCode': postalCode
      };

  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Address\\";
    modelSchemaDefinition.pluralName = \\"Addresses\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
        fieldName: 'line1',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
        fieldName: 'line2',
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
        fieldName: 'city',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
        fieldName: 'state',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
        fieldName: 'postalCode',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}
"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for Address with nullsafety enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Address type in your schema. */
@immutable
class Address {
  final String? _line1;
  final String? _line2;
  final String? _city;
  final String? _state;
  final String? _postalCode;

  String get line1 {
    try {
      return _line1!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  String? get line2 {
    return _line2;
  }
  
  String get city {
    try {
      return _city!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  String get state {
    try {
      return _state!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  String get postalCode {
    try {
      return _postalCode!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  const Address._internal({required line1, line2, required city, required state, required postalCode}): _line1 = line1, _line2 = line2, _city = city, _state = state, _postalCode = postalCode;
  
  factory Address({required String line1, String? line2, required String city, required String state, required String postalCode}) {
    return Address._internal(
      line1: line1,
      line2: line2,
      city: city,
      state: state,
      postalCode: postalCode);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Address &&
      _line1 == other._line1 &&
      _line2 == other._line2 &&
      _city == other._city &&
      _state == other._state &&
      _postalCode == other._postalCode;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Address {\\");
    buffer.write(\\"line1=\\" + \\"$_line1\\" + \\", \\");
    buffer.write(\\"line2=\\" + \\"$_line2\\" + \\", \\");
    buffer.write(\\"city=\\" + \\"$_city\\" + \\", \\");
    buffer.write(\\"state=\\" + \\"$_state\\" + \\", \\");
    buffer.write(\\"postalCode=\\" + \\"$_postalCode\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Address copyWith({String? line1, String? line2, String? city, String? state, String? postalCode}) {
    return Address(
      line1: line1 ?? this.line1,
      line2: line2 ?? this.line2,
      city: city ?? this.city,
      state: state ?? this.state,
      postalCode: postalCode ?? this.postalCode);
  }
  
  Address.fromJson(Map<String, dynamic> json)  
    : _line1 = json['line1'],
      _line2 = json['line2'],
      _city = json['city'],
      _state = json['state'],
      _postalCode = json['postalCode'];
  
  Map<String, dynamic> toJson() => {
    'line1': _line1, 'line2': _line2, 'city': _city, 'state': _state, 'postalCode': _postalCode
  };

  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Address\\";
    modelSchemaDefinition.pluralName = \\"Addresses\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'line1',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'line2',
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'city',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'state',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'postalCode',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for Contact with nullsafety disabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Contact type in your schema. */
@immutable
class Contact {
  final String contactName;
  final Phone phone;
  final List<Address> mailingAddresses;

  const Contact._internal(
      {@required this.contactName,
      @required this.phone,
      this.mailingAddresses});

  factory Contact(
      {@required String contactName,
      @required Phone phone,
      List<Address> mailingAddresses}) {
    return Contact._internal(
        contactName: contactName,
        phone: phone,
        mailingAddresses: mailingAddresses != null
            ? List<Address>.unmodifiable(mailingAddresses)
            : mailingAddresses);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Contact &&
        contactName == other.contactName &&
        phone == other.phone &&
        DeepCollectionEquality()
            .equals(mailingAddresses, other.mailingAddresses);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Contact {\\");
    buffer.write(\\"contactName=\\" + \\"$contactName\\" + \\", \\");
    buffer.write(\\"phone=\\" + (phone != null ? phone.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"mailingAddresses=\\" +
        (mailingAddresses != null ? mailingAddresses.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Contact copyWith(
      {String contactName, Phone phone, List<Address> mailingAddresses}) {
    return Contact(
        contactName: contactName ?? this.contactName,
        phone: phone ?? this.phone,
        mailingAddresses: mailingAddresses ?? this.mailingAddresses);
  }

  Contact.fromJson(Map<String, dynamic> json)
      : contactName = json['contactName'],
        phone = json['phone'] != null
            ? Phone.fromJson(new Map<String, dynamic>.from(json['phone']))
            : null,
        mailingAddresses = json['mailingAddresses'] is List
            ? (json['mailingAddresses'] as List)
                .map((e) => Address.fromJson(
                    new Map<String, dynamic>.from(e['serializedData'])))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'contactName': contactName,
        'phone': phone?.toJson(),
        'mailingAddresses':
            mailingAddresses?.map((Address? e) => e?.toJson()).toList()
      };

  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Contact\\";
    modelSchemaDefinition.pluralName = \\"Contacts\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
        fieldName: 'contactName',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
        fieldName: 'phone',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.embedded,
            ofCustomTypeName: 'Phone')));

    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
        fieldName: 'mailingAddresses',
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.embeddedCollection,
            ofCustomTypeName: 'Address')));
  });
}
"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for Contact with nullsafety enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Contact type in your schema. */
@immutable
class Contact {
  final String? _contactName;
  final Phone? _phone;
  final List<Address>? _mailingAddresses;

  String get contactName {
    try {
      return _contactName!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  Phone get phone {
    try {
      return _phone!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  List<Address>? get mailingAddresses {
    return _mailingAddresses;
  }
  
  const Contact._internal({required contactName, required phone, mailingAddresses}): _contactName = contactName, _phone = phone, _mailingAddresses = mailingAddresses;
  
  factory Contact({required String contactName, required Phone phone, List<Address>? mailingAddresses}) {
    return Contact._internal(
      contactName: contactName,
      phone: phone,
      mailingAddresses: mailingAddresses != null ? List<Address>.unmodifiable(mailingAddresses) : mailingAddresses);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Contact &&
      _contactName == other._contactName &&
      _phone == other._phone &&
      DeepCollectionEquality().equals(_mailingAddresses, other._mailingAddresses);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Contact {\\");
    buffer.write(\\"contactName=\\" + \\"$_contactName\\" + \\", \\");
    buffer.write(\\"phone=\\" + (_phone != null ? _phone!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"mailingAddresses=\\" + (_mailingAddresses != null ? _mailingAddresses!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Contact copyWith({String? contactName, Phone? phone, List<Address>? mailingAddresses}) {
    return Contact(
      contactName: contactName ?? this.contactName,
      phone: phone ?? this.phone,
      mailingAddresses: mailingAddresses ?? this.mailingAddresses);
  }
  
  Contact.fromJson(Map<String, dynamic> json)  
    : _contactName = json['contactName'],
      _phone = json['phone']?['serializedData'] != null
        ? Phone.fromJson(new Map<String, dynamic>.from(json['phone']['serializedData']))
        : null,
      _mailingAddresses = json['mailingAddresses'] is List
        ? (json['mailingAddresses'] as List)
          .where((e) => e != null)
          .map((e) => Address.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'contactName': _contactName, 'phone': _phone?.toJson(), 'mailingAddresses': _mailingAddresses?.map((Address? e) => e?.toJson()).toList()
  };

  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Contact\\";
    modelSchemaDefinition.pluralName = \\"Contacts\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'contactName',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
      fieldName: 'phone',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.embedded, ofCustomTypeName: 'Phone')
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
      fieldName: 'mailingAddresses',
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.embeddedCollection, ofCustomTypeName: 'Address')
    ));
  });
}"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for ModelProvider with nullsafety disabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'Person.dart';
import 'Address.dart';
import 'Contact.dart';
import 'Phone.dart';

export 'Address.dart';
export 'Contact.dart';
export 'Person.dart';
export 'Phone.dart';

class ModelProvider implements ModelProviderInterface {
  @override
  String version = \\"b65f704d832381d9985dd162ae40c075\\";
  @override
  List<ModelSchema> modelSchemas = [Person.schema];
  static final ModelProvider _instance = ModelProvider();
  @override
  List<ModelSchema> customTypeSchemas = [
    Address.schema,
    Contact.schema,
    Phone.schema
  ];

  static ModelProvider get instance => _instance;

  ModelType getModelTypeByModelName(String modelName) {
    switch (modelName) {
      case \\"Person\\":
        return Person.classType;
      default:
        throw Exception(
            \\"Failed to find model in model provider for model name: \\" +
                modelName);
    }
  }
}
"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for ModelProvider with nullsafety enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'Person.dart';
import 'Address.dart';
import 'Contact.dart';
import 'Phone.dart';

export 'Address.dart';
export 'Contact.dart';
export 'Person.dart';
export 'Phone.dart';

class ModelProvider implements ModelProviderInterface {
  @override
  String version = \\"b65f704d832381d9985dd162ae40c075\\";
  @override
  List<ModelSchema> modelSchemas = [Person.schema];
  static final ModelProvider _instance = ModelProvider();
  @override
  List<ModelSchema> customTypeSchemas = [Address.schema, Contact.schema, Phone.schema];

  static ModelProvider get instance => _instance;
  
  ModelType getModelTypeByModelName(String modelName) {
    switch(modelName) {
      case \\"Person\\":
        return Person.classType;
      default:
        throw Exception(\\"Failed to find model in model provider for model name: \\" + modelName);
    }
  }
}"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for Person with nullsafety disabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Person type in your schema. */
@immutable
class Person extends Model {
  static const classType = const _PersonModelType();
  final String id;
  final String name;
  final Phone phone;
  final List<Address> mailingAddresses;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Person._internal(
      {@required this.id,
      @required this.name,
      @required this.phone,
      this.mailingAddresses});

  factory Person(
      {String id,
      @required String name,
      @required Phone phone,
      List<Address> mailingAddresses}) {
    return Person._internal(
        id: id == null ? UUID.getUUID() : id,
        name: name,
        phone: phone,
        mailingAddresses: mailingAddresses != null
            ? List<Address>.unmodifiable(mailingAddresses)
            : mailingAddresses);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Person &&
        id == other.id &&
        name == other.name &&
        phone == other.phone &&
        DeepCollectionEquality()
            .equals(mailingAddresses, other.mailingAddresses);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Person {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"phone=\\" + (phone != null ? phone.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"mailingAddresses=\\" +
        (mailingAddresses != null ? mailingAddresses.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Person copyWith(
      {String id, String name, Phone phone, List<Address> mailingAddresses}) {
    return Person(
        id: id ?? this.id,
        name: name ?? this.name,
        phone: phone ?? this.phone,
        mailingAddresses: mailingAddresses ?? this.mailingAddresses);
  }

  Person.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        phone = json['phone'] != null
            ? Phone.fromJson(new Map<String, dynamic>.from(json['phone']))
            : null,
        mailingAddresses = json['mailingAddresses'] is List
            ? (json['mailingAddresses'] as List)
                .map((e) => Address.fromJson(
                    new Map<String, dynamic>.from(e['serializedData'])))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'phone': phone?.toJson(),
        'mailingAddresses':
            mailingAddresses?.map((Address? e) => e?.toJson()).toList()
      };

  static final QueryField ID = QueryField(fieldName: \\"person.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField PHONE = QueryField(fieldName: \\"phone\\");
  static final QueryField MAILINGADDRESSES =
      QueryField(fieldName: \\"mailingAddresses\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Person\\";
    modelSchemaDefinition.pluralName = \\"People\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Person.NAME,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
        fieldName: 'phone',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.embedded,
            ofCustomTypeName: 'Phone')));

    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
        fieldName: 'mailingAddresses',
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.embeddedCollection,
            ofCustomTypeName: 'Address')));
  });
}

class _PersonModelType extends ModelType<Person> {
  const _PersonModelType();

  @override
  Person fromJson(Map<String, dynamic> jsonData) {
    return Person.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for Person with nullsafety enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Person type in your schema. */
@immutable
class Person extends Model {
  static const classType = const _PersonModelType();
  final String id;
  final String? _name;
  final Phone? _phone;
  final List<Address>? _mailingAddresses;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  Phone get phone {
    try {
      return _phone!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  List<Address>? get mailingAddresses {
    return _mailingAddresses;
  }
  
  const Person._internal({required this.id, required name, required phone, mailingAddresses}): _name = name, _phone = phone, _mailingAddresses = mailingAddresses;
  
  factory Person({String? id, required String name, required Phone phone, List<Address>? mailingAddresses}) {
    return Person._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      phone: phone,
      mailingAddresses: mailingAddresses != null ? List<Address>.unmodifiable(mailingAddresses) : mailingAddresses);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Person &&
      id == other.id &&
      _name == other._name &&
      _phone == other._phone &&
      DeepCollectionEquality().equals(_mailingAddresses, other._mailingAddresses);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Person {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"phone=\\" + (_phone != null ? _phone!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"mailingAddresses=\\" + (_mailingAddresses != null ? _mailingAddresses!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Person copyWith({String? id, String? name, Phone? phone, List<Address>? mailingAddresses}) {
    return Person(
      id: id ?? this.id,
      name: name ?? this.name,
      phone: phone ?? this.phone,
      mailingAddresses: mailingAddresses ?? this.mailingAddresses);
  }
  
  Person.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _phone = json['phone']?['serializedData'] != null
        ? Phone.fromJson(new Map<String, dynamic>.from(json['phone']['serializedData']))
        : null,
      _mailingAddresses = json['mailingAddresses'] is List
        ? (json['mailingAddresses'] as List)
          .where((e) => e != null)
          .map((e) => Address.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'phone': _phone?.toJson(), 'mailingAddresses': _mailingAddresses?.map((Address? e) => e?.toJson()).toList()
  };

  static final QueryField ID = QueryField(fieldName: \\"person.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField PHONE = QueryField(fieldName: \\"phone\\");
  static final QueryField MAILINGADDRESSES = QueryField(fieldName: \\"mailingAddresses\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Person\\";
    modelSchemaDefinition.pluralName = \\"People\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Person.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
      fieldName: 'phone',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.embedded, ofCustomTypeName: 'Phone')
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
      fieldName: 'mailingAddresses',
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.embeddedCollection, ofCustomTypeName: 'Address')
    ));
  });
}

class _PersonModelType extends ModelType<Person> {
  const _PersonModelType();
  
  @override
  Person fromJson(Map<String, dynamic> jsonData) {
    return Person.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should not generate custom type field in model provider if non model feature is disabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'Person.dart';
import 'Address.dart';
import 'Contact.dart';
import 'Phone.dart';

export 'Address.dart';
export 'Contact.dart';
export 'Person.dart';
export 'Phone.dart';

class ModelProvider implements ModelProviderInterface {
  @override
  String version = \\"b65f704d832381d9985dd162ae40c075\\";
  @override
  List<ModelSchema> modelSchemas = [Person.schema];
  static final ModelProvider _instance = ModelProvider();

  static ModelProvider get instance => _instance;
  
  ModelType getModelTypeByModelName(String modelName) {
    switch(modelName) {
      case \\"Person\\":
        return Person.classType;
      default:
        throw Exception(\\"Failed to find model in model provider for model name: \\" + modelName);
    }
  }
}"
`;

exports[`AppSync Dart Visitor Dart Specific Tests should generate the model provider 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'SimpleModel.dart';

export 'SimpleModel.dart';

class ModelProvider implements ModelProviderInterface {
  @override
  String version = \\"20078c21a81919792555926e238b194e\\";
  @override
  List<ModelSchema> modelSchemas = [SimpleModel.schema];
  static final ModelProvider _instance = ModelProvider();
  @override
  List<ModelSchema> customTypeSchemas = [];

  static ModelProvider get instance => _instance;

  ModelType getModelTypeByModelName(String modelName) {
    switch (modelName) {
      case \\"SimpleModel\\":
        return SimpleModel.classType;
      default:
        throw Exception(
            \\"Failed to find model in model provider for model name: \\" +
                modelName);
    }
  }
}
"
`;

exports[`AppSync Dart Visitor Enum Generation should generate a class for enum type 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final Status status;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const SimpleModel._internal({@required this.id, this.status});

  factory SimpleModel({String id, Status status}) {
    return SimpleModel._internal(
        id: id == null ? UUID.getUUID() : id, status: status);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel && id == other.id && status == other.status;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"status=\\" + (status != null ? enumToString(status) : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  SimpleModel copyWith({String id, Status status}) {
    return SimpleModel(id: id ?? this.id, status: status ?? this.status);
  }

  SimpleModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        status = enumFromString<Status>(json['status'], Status.values);

  Map<String, dynamic> toJson() => {'id': id, 'status': enumToString(status)};

  static final QueryField ID = QueryField(fieldName: \\"simpleModel.id\\");
  static final QueryField STATUS = QueryField(fieldName: \\"status\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.STATUS,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();

  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Enum Generation should generate a class for enum type 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

enum Status { yes, no, maybe }
"
`;

exports[`AppSync Dart Visitor Field tests should generate correct output for appsync scalar types of time and int 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the TemporalTimeModel type in your schema. */
@immutable
class TemporalTimeModel extends Model {
  static const classType = const _TemporalTimeModelModelType();
  final String id;
  final TemporalDate date;
  final TemporalTime time;
  final TemporalDateTime dateTime;
  final TemporalTimestamp timestamp;
  final int intNum;
  final List<TemporalDate> dateList;
  final List<TemporalTime> timeList;
  final List<TemporalDateTime> dateTimeList;
  final List<TemporalTimestamp> timestampList;
  final List<int> intList;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const TemporalTimeModel._internal(
      {@required this.id,
      this.date,
      this.time,
      this.dateTime,
      this.timestamp,
      this.intNum,
      this.dateList,
      this.timeList,
      this.dateTimeList,
      this.timestampList,
      this.intList});

  factory TemporalTimeModel(
      {String id,
      TemporalDate date,
      TemporalTime time,
      TemporalDateTime dateTime,
      TemporalTimestamp timestamp,
      int intNum,
      List<TemporalDate> dateList,
      List<TemporalTime> timeList,
      List<TemporalDateTime> dateTimeList,
      List<TemporalTimestamp> timestampList,
      List<int> intList}) {
    return TemporalTimeModel._internal(
        id: id == null ? UUID.getUUID() : id,
        date: date,
        time: time,
        dateTime: dateTime,
        timestamp: timestamp,
        intNum: intNum,
        dateList: dateList != null
            ? List<TemporalDate>.unmodifiable(dateList)
            : dateList,
        timeList: timeList != null
            ? List<TemporalTime>.unmodifiable(timeList)
            : timeList,
        dateTimeList: dateTimeList != null
            ? List<TemporalDateTime>.unmodifiable(dateTimeList)
            : dateTimeList,
        timestampList: timestampList != null
            ? List<TemporalTimestamp>.unmodifiable(timestampList)
            : timestampList,
        intList: intList != null ? List<int>.unmodifiable(intList) : intList);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TemporalTimeModel &&
        id == other.id &&
        date == other.date &&
        time == other.time &&
        dateTime == other.dateTime &&
        timestamp == other.timestamp &&
        intNum == other.intNum &&
        DeepCollectionEquality().equals(dateList, other.dateList) &&
        DeepCollectionEquality().equals(timeList, other.timeList) &&
        DeepCollectionEquality().equals(dateTimeList, other.dateTimeList) &&
        DeepCollectionEquality().equals(timestampList, other.timestampList) &&
        DeepCollectionEquality().equals(intList, other.intList);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"TemporalTimeModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"date=\\" + (date != null ? date.format() : \\"null\\") + \\", \\");
    buffer.write(\\"time=\\" + (time != null ? time.format() : \\"null\\") + \\", \\");
    buffer.write(
        \\"dateTime=\\" + (dateTime != null ? dateTime.format() : \\"null\\") + \\", \\");
    buffer.write(\\"timestamp=\\" +
        (timestamp != null ? timestamp.toString() : \\"null\\") +
        \\", \\");
    buffer.write(
        \\"intNum=\\" + (intNum != null ? intNum.toString() : \\"null\\") + \\", \\");
    buffer.write(
        \\"dateList=\\" + (dateList != null ? dateList.toString() : \\"null\\") + \\", \\");
    buffer.write(
        \\"timeList=\\" + (timeList != null ? timeList.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"dateTimeList=\\" +
        (dateTimeList != null ? dateTimeList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"timestampList=\\" +
        (timestampList != null ? timestampList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"intList=\\" + (intList != null ? intList.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  TemporalTimeModel copyWith(
      {String id,
      TemporalDate date,
      TemporalTime time,
      TemporalDateTime dateTime,
      TemporalTimestamp timestamp,
      int intNum,
      List<TemporalDate> dateList,
      List<TemporalTime> timeList,
      List<TemporalDateTime> dateTimeList,
      List<TemporalTimestamp> timestampList,
      List<int> intList}) {
    return TemporalTimeModel(
        id: id ?? this.id,
        date: date ?? this.date,
        time: time ?? this.time,
        dateTime: dateTime ?? this.dateTime,
        timestamp: timestamp ?? this.timestamp,
        intNum: intNum ?? this.intNum,
        dateList: dateList ?? this.dateList,
        timeList: timeList ?? this.timeList,
        dateTimeList: dateTimeList ?? this.dateTimeList,
        timestampList: timestampList ?? this.timestampList,
        intList: intList ?? this.intList);
  }

  TemporalTimeModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        date =
            json['date'] != null ? TemporalDate.fromString(json['date']) : null,
        time =
            json['time'] != null ? TemporalTime.fromString(json['time']) : null,
        dateTime = json['dateTime'] != null
            ? TemporalDateTime.fromString(json['dateTime'])
            : null,
        timestamp = json['timestamp'] != null
            ? TemporalTimestamp.fromSeconds(json['timestamp'])
            : null,
        intNum = (json['intNum'] as num)?.toInt(),
        dateList = (json['dateList'] as List)
            ?.map((e) => TemporalDate.fromString(e))
            .toList(),
        timeList = (json['timeList'] as List)
            ?.map((e) => TemporalTime.fromString(e))
            .toList(),
        dateTimeList = (json['dateTimeList'] as List)
            ?.map((e) => TemporalDateTime.fromString(e))
            .toList(),
        timestampList = (json['timestampList'] as List)
            ?.map((e) => TemporalTimestamp.fromSeconds(e))
            .toList(),
        intList =
            (json['intList'] as List)?.map((e) => (e as num).toInt()).toList();

  Map<String, dynamic> toJson() => {
        'id': id,
        'date': date?.format(),
        'time': time?.format(),
        'dateTime': dateTime?.format(),
        'timestamp': timestamp?.toSeconds(),
        'intNum': intNum,
        'dateList': dateList?.map((e) => e.format()).toList(),
        'timeList': timeList?.map((e) => e.format()).toList(),
        'dateTimeList': dateTimeList?.map((e) => e.format()).toList(),
        'timestampList': timestampList?.map((e) => e.toSeconds()).toList(),
        'intList': intList
      };

  static final QueryField ID = QueryField(fieldName: \\"temporalTimeModel.id\\");
  static final QueryField DATE = QueryField(fieldName: \\"date\\");
  static final QueryField TIME = QueryField(fieldName: \\"time\\");
  static final QueryField DATETIME = QueryField(fieldName: \\"dateTime\\");
  static final QueryField TIMESTAMP = QueryField(fieldName: \\"timestamp\\");
  static final QueryField INTNUM = QueryField(fieldName: \\"intNum\\");
  static final QueryField DATELIST = QueryField(fieldName: \\"dateList\\");
  static final QueryField TIMELIST = QueryField(fieldName: \\"timeList\\");
  static final QueryField DATETIMELIST = QueryField(fieldName: \\"dateTimeList\\");
  static final QueryField TIMESTAMPLIST =
      QueryField(fieldName: \\"timestampList\\");
  static final QueryField INTLIST = QueryField(fieldName: \\"intList\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TemporalTimeModel\\";
    modelSchemaDefinition.pluralName = \\"TemporalTimeModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.DATE,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.date)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.TIME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.time)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.DATETIME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.TIMESTAMP,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.timestamp)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.INTNUM,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.int)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.DATELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.date))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.TIMELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.time))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.DATETIMELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.dateTime))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.TIMESTAMPLIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.timestamp))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.INTLIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.int))));
  });
}

class _TemporalTimeModelModelType extends ModelType<TemporalTimeModel> {
  const _TemporalTimeModelModelType();

  @override
  TemporalTimeModel fromJson(Map<String, dynamic> jsonData) {
    return TemporalTimeModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Field tests should generate correct output for enum field w/o list or nullable 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the TestEnumModel type in your schema. */
@immutable
class TestEnumModel extends Model {
  static const classType = const _TestEnumModelModelType();
  final String id;
  final TestEnum enumVal;
  final TestEnum nullableEnumVal;
  final List<TestEnum> enumList;
  final List<TestEnum> enumNullableList;
  final List<TestEnum> nullableEnumList;
  final List<TestEnum> nullableEnumNullableList;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const TestEnumModel._internal(
      {@required this.id,
      @required this.enumVal,
      this.nullableEnumVal,
      @required this.enumList,
      this.enumNullableList,
      @required this.nullableEnumList,
      this.nullableEnumNullableList});

  factory TestEnumModel(
      {String id,
      @required TestEnum enumVal,
      TestEnum nullableEnumVal,
      @required List<TestEnum> enumList,
      List<TestEnum> enumNullableList,
      @required List<TestEnum> nullableEnumList,
      List<TestEnum> nullableEnumNullableList}) {
    return TestEnumModel._internal(
        id: id == null ? UUID.getUUID() : id,
        enumVal: enumVal,
        nullableEnumVal: nullableEnumVal,
        enumList:
            enumList != null ? List<TestEnum>.unmodifiable(enumList) : enumList,
        enumNullableList: enumNullableList != null
            ? List<TestEnum>.unmodifiable(enumNullableList)
            : enumNullableList,
        nullableEnumList: nullableEnumList != null
            ? List<TestEnum>.unmodifiable(nullableEnumList)
            : nullableEnumList,
        nullableEnumNullableList: nullableEnumNullableList != null
            ? List<TestEnum>.unmodifiable(nullableEnumNullableList)
            : nullableEnumNullableList);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestEnumModel &&
        id == other.id &&
        enumVal == other.enumVal &&
        nullableEnumVal == other.nullableEnumVal &&
        DeepCollectionEquality().equals(enumList, other.enumList) &&
        DeepCollectionEquality()
            .equals(enumNullableList, other.enumNullableList) &&
        DeepCollectionEquality()
            .equals(nullableEnumList, other.nullableEnumList) &&
        DeepCollectionEquality()
            .equals(nullableEnumNullableList, other.nullableEnumNullableList);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"TestEnumModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(
        \\"enumVal=\\" + (enumVal != null ? enumToString(enumVal) : \\"null\\") + \\", \\");
    buffer.write(\\"nullableEnumVal=\\" +
        (nullableEnumVal != null ? enumToString(nullableEnumVal) : \\"null\\") +
        \\", \\");
    buffer.write(
        \\"enumList=\\" + enumList?.map((e) => enumToString(e)).toString() + \\", \\");
    buffer.write(\\"enumNullableList=\\" +
        enumNullableList?.map((e) => enumToString(e)).toString() +
        \\", \\");
    buffer.write(\\"nullableEnumList=\\" +
        nullableEnumList?.map((e) => enumToString(e)).toString() +
        \\", \\");
    buffer.write(\\"nullableEnumNullableList=\\" +
        nullableEnumNullableList?.map((e) => enumToString(e)).toString());
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  TestEnumModel copyWith(
      {String id,
      TestEnum enumVal,
      TestEnum nullableEnumVal,
      List<TestEnum> enumList,
      List<TestEnum> enumNullableList,
      List<TestEnum> nullableEnumList,
      List<TestEnum> nullableEnumNullableList}) {
    return TestEnumModel(
        id: id ?? this.id,
        enumVal: enumVal ?? this.enumVal,
        nullableEnumVal: nullableEnumVal ?? this.nullableEnumVal,
        enumList: enumList ?? this.enumList,
        enumNullableList: enumNullableList ?? this.enumNullableList,
        nullableEnumList: nullableEnumList ?? this.nullableEnumList,
        nullableEnumNullableList:
            nullableEnumNullableList ?? this.nullableEnumNullableList);
  }

  TestEnumModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        enumVal = enumFromString<TestEnum>(json['enumVal'], TestEnum.values),
        nullableEnumVal =
            enumFromString<TestEnum>(json['nullableEnumVal'], TestEnum.values),
        enumList = json['enumList'] is List
            ? (json['enumList'] as List)
                .map((e) => enumFromString<TestEnum>(e, TestEnum.values))
                .toList()
            : null,
        enumNullableList = json['enumNullableList'] is List
            ? (json['enumNullableList'] as List)
                .map((e) => enumFromString<TestEnum>(e, TestEnum.values))
                .toList()
            : null,
        nullableEnumList = json['nullableEnumList'] is List
            ? (json['nullableEnumList'] as List)
                .map((e) => enumFromString<TestEnum>(e, TestEnum.values))
                .toList()
            : null,
        nullableEnumNullableList = json['nullableEnumNullableList'] is List
            ? (json['nullableEnumNullableList'] as List)
                .map((e) => enumFromString<TestEnum>(e, TestEnum.values))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'enumVal': enumToString(enumVal),
        'nullableEnumVal': enumToString(nullableEnumVal),
        'enumList': enumList?.map((e) => enumToString(e)).toList(),
        'enumNullableList':
            enumNullableList?.map((e) => enumToString(e)).toList(),
        'nullableEnumList':
            nullableEnumList?.map((e) => enumToString(e)).toList(),
        'nullableEnumNullableList':
            nullableEnumNullableList?.map((e) => enumToString(e)).toList()
      };

  static final QueryField ID = QueryField(fieldName: \\"testEnumModel.id\\");
  static final QueryField ENUMVAL = QueryField(fieldName: \\"enumVal\\");
  static final QueryField NULLABLEENUMVAL =
      QueryField(fieldName: \\"nullableEnumVal\\");
  static final QueryField ENUMLIST = QueryField(fieldName: \\"enumList\\");
  static final QueryField ENUMNULLABLELIST =
      QueryField(fieldName: \\"enumNullableList\\");
  static final QueryField NULLABLEENUMLIST =
      QueryField(fieldName: \\"nullableEnumList\\");
  static final QueryField NULLABLEENUMNULLABLELIST =
      QueryField(fieldName: \\"nullableEnumNullableList\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestEnumModel\\";
    modelSchemaDefinition.pluralName = \\"TestEnumModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.ENUMVAL,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.NULLABLEENUMVAL,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.ENUMLIST,
        isRequired: true,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.ENUMNULLABLELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.NULLABLEENUMLIST,
        isRequired: true,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.NULLABLEENUMNULLABLELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))));
  });
}

class _TestEnumModelModelType extends ModelType<TestEnumModel> {
  const _TestEnumModelModelType();

  @override
  TestEnumModel fromJson(Map<String, dynamic> jsonData) {
    return TestEnumModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Field tests should generate correct output for regular field w/o list or nullable 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the TestModel type in your schema. */
@immutable
class TestModel extends Model {
  static const classType = const _TestModelModelType();
  final String id;
  final double floatVal;
  final double floatNullableVal;
  final List<double> floatList;
  final List<double> floatNullableList;
  final List<double> nullableFloatList;
  final List<double> nullableFloatNullableList;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const TestModel._internal(
      {@required this.id,
      @required this.floatVal,
      this.floatNullableVal,
      @required this.floatList,
      this.floatNullableList,
      @required this.nullableFloatList,
      this.nullableFloatNullableList});

  factory TestModel(
      {String id,
      @required double floatVal,
      double floatNullableVal,
      @required List<double> floatList,
      List<double> floatNullableList,
      @required List<double> nullableFloatList,
      List<double> nullableFloatNullableList}) {
    return TestModel._internal(
        id: id == null ? UUID.getUUID() : id,
        floatVal: floatVal,
        floatNullableVal: floatNullableVal,
        floatList: floatList != null
            ? List<double>.unmodifiable(floatList)
            : floatList,
        floatNullableList: floatNullableList != null
            ? List<double>.unmodifiable(floatNullableList)
            : floatNullableList,
        nullableFloatList: nullableFloatList != null
            ? List<double>.unmodifiable(nullableFloatList)
            : nullableFloatList,
        nullableFloatNullableList: nullableFloatNullableList != null
            ? List<double>.unmodifiable(nullableFloatNullableList)
            : nullableFloatNullableList);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestModel &&
        id == other.id &&
        floatVal == other.floatVal &&
        floatNullableVal == other.floatNullableVal &&
        DeepCollectionEquality().equals(floatList, other.floatList) &&
        DeepCollectionEquality()
            .equals(floatNullableList, other.floatNullableList) &&
        DeepCollectionEquality()
            .equals(nullableFloatList, other.nullableFloatList) &&
        DeepCollectionEquality()
            .equals(nullableFloatNullableList, other.nullableFloatNullableList);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"TestModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(
        \\"floatVal=\\" + (floatVal != null ? floatVal.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableVal=\\" +
        (floatNullableVal != null ? floatNullableVal.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"floatList=\\" +
        (floatList != null ? floatList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"floatNullableList=\\" +
        (floatNullableList != null ? floatNullableList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"nullableFloatList=\\" +
        (nullableFloatList != null ? nullableFloatList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"nullableFloatNullableList=\\" +
        (nullableFloatNullableList != null
            ? nullableFloatNullableList.toString()
            : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  TestModel copyWith(
      {String id,
      double floatVal,
      double floatNullableVal,
      List<double> floatList,
      List<double> floatNullableList,
      List<double> nullableFloatList,
      List<double> nullableFloatNullableList}) {
    return TestModel(
        id: id ?? this.id,
        floatVal: floatVal ?? this.floatVal,
        floatNullableVal: floatNullableVal ?? this.floatNullableVal,
        floatList: floatList ?? this.floatList,
        floatNullableList: floatNullableList ?? this.floatNullableList,
        nullableFloatList: nullableFloatList ?? this.nullableFloatList,
        nullableFloatNullableList:
            nullableFloatNullableList ?? this.nullableFloatNullableList);
  }

  TestModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        floatVal = (json['floatVal'] as num)?.toDouble(),
        floatNullableVal = (json['floatNullableVal'] as num)?.toDouble(),
        floatList = (json['floatList'] as List)
            ?.map((e) => (e as num).toDouble())
            .toList(),
        floatNullableList = (json['floatNullableList'] as List)
            ?.map((e) => (e as num).toDouble())
            .toList(),
        nullableFloatList = (json['nullableFloatList'] as List)
            ?.map((e) => (e as num).toDouble())
            .toList(),
        nullableFloatNullableList = (json['nullableFloatNullableList'] as List)
            ?.map((e) => (e as num).toDouble())
            .toList();

  Map<String, dynamic> toJson() => {
        'id': id,
        'floatVal': floatVal,
        'floatNullableVal': floatNullableVal,
        'floatList': floatList,
        'floatNullableList': floatNullableList,
        'nullableFloatList': nullableFloatList,
        'nullableFloatNullableList': nullableFloatNullableList
      };

  static final QueryField ID = QueryField(fieldName: \\"testModel.id\\");
  static final QueryField FLOATVAL = QueryField(fieldName: \\"floatVal\\");
  static final QueryField FLOATNULLABLEVAL =
      QueryField(fieldName: \\"floatNullableVal\\");
  static final QueryField FLOATLIST = QueryField(fieldName: \\"floatList\\");
  static final QueryField FLOATNULLABLELIST =
      QueryField(fieldName: \\"floatNullableList\\");
  static final QueryField NULLABLEFLOATLIST =
      QueryField(fieldName: \\"nullableFloatList\\");
  static final QueryField NULLABLEFLOATNULLABLELIST =
      QueryField(fieldName: \\"nullableFloatNullableList\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestModel\\";
    modelSchemaDefinition.pluralName = \\"TestModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.FLOATVAL,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.double)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.FLOATNULLABLEVAL,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.double)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.FLOATLIST,
        isRequired: true,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.double))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.FLOATNULLABLELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.double))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.NULLABLEFLOATLIST,
        isRequired: true,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.double))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.NULLABLEFLOATNULLABLELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.double))));
  });
}

class _TestModelModelType extends ModelType<TestModel> {
  const _TestModelModelType();

  @override
  TestModel fromJson(Map<String, dynamic> jsonData) {
    return TestModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model Directive should generate a class for a Simple Model 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const SimpleModel._internal({@required this.id, this.name, this.bar});

  factory SimpleModel({String id, String name, String bar}) {
    return SimpleModel._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  SimpleModel copyWith({String id, String name, String bar}) {
    return SimpleModel(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  SimpleModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"simpleModel.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();

  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model Directive should generate a class for a model with all optional fields except id field 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const SimpleModel._internal({@required this.id, this.name, this.bar});

  factory SimpleModel({String id, String name, String bar}) {
    return SimpleModel._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  SimpleModel copyWith({String id, String name, String bar}) {
    return SimpleModel(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  SimpleModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"simpleModel.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();

  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with custom claims 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the customClaim type in your schema. */
@immutable
class customClaim extends Model {
  static const classType = const _customClaimModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const customClaim._internal({@required this.id, this.name, this.bar});

  factory customClaim({String id, String name, String bar}) {
    return customClaim._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is customClaim &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"customClaim {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  customClaim copyWith({String id, String name, String bar}) {
    return customClaim(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  customClaim.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"customClaim.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"customClaim\\";
    modelSchemaDefinition.pluralName = \\"customClaims\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"owner\\",
          identityClaim: \\"user_id\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: customClaim.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: customClaim.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _customClaimModelType extends ModelType<customClaim> {
  const _customClaimModelType();

  @override
  customClaim fromJson(Map<String, dynamic> jsonData) {
    return customClaim.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with custom group claims 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the customClaim type in your schema. */
@immutable
class customClaim extends Model {
  static const classType = const _customClaimModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const customClaim._internal({@required this.id, this.name, this.bar});

  factory customClaim({String id, String name, String bar}) {
    return customClaim._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is customClaim &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"customClaim {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  customClaim copyWith({String id, String name, String bar}) {
    return customClaim(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  customClaim.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"customClaim.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"customClaim\\";
    modelSchemaDefinition.pluralName = \\"customClaims\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.GROUPS,
          groupClaim: \\"user_groups\\",
          groups: [
            \\"Moderator\\"
          ],
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: customClaim.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: customClaim.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _customClaimModelType extends ModelType<customClaim> {
  const _customClaimModelType();

  @override
  customClaim fromJson(Map<String, dynamic> jsonData) {
    return customClaim.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with dynamic groups 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the dynamicGroups type in your schema. */
@immutable
class dynamicGroups extends Model {
  static const classType = const _dynamicGroupsModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const dynamicGroups._internal({@required this.id, this.name, this.bar});

  factory dynamicGroups({String id, String name, String bar}) {
    return dynamicGroups._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is dynamicGroups &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"dynamicGroups {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  dynamicGroups copyWith({String id, String name, String bar}) {
    return dynamicGroups(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  dynamicGroups.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"dynamicGroups.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"dynamicGroups\\";
    modelSchemaDefinition.pluralName = \\"dynamicGroups\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.GROUPS,
          groupClaim: \\"cognito:groups\\",
          groupsField: \\"groups\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: dynamicGroups.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: dynamicGroups.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _dynamicGroupsModelType extends ModelType<dynamicGroups> {
  const _dynamicGroupsModelType();

  @override
  dynamicGroups fromJson(Map<String, dynamic> jsonData) {
    return dynamicGroups.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with owner auth 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the simpleOwnerAuth type in your schema. */
@immutable
class simpleOwnerAuth extends Model {
  static const classType = const _simpleOwnerAuthModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const simpleOwnerAuth._internal({@required this.id, this.name, this.bar});

  factory simpleOwnerAuth({String id, String name, String bar}) {
    return simpleOwnerAuth._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is simpleOwnerAuth &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"simpleOwnerAuth {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  simpleOwnerAuth copyWith({String id, String name, String bar}) {
    return simpleOwnerAuth(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  simpleOwnerAuth.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"simpleOwnerAuth.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"simpleOwnerAuth\\";
    modelSchemaDefinition.pluralName = \\"simpleOwnerAuths\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"owner\\",
          identityClaim: \\"cognito:username\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: simpleOwnerAuth.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: simpleOwnerAuth.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _simpleOwnerAuthModelType extends ModelType<simpleOwnerAuth> {
  const _simpleOwnerAuthModelType();

  @override
  simpleOwnerAuth fromJson(Map<String, dynamic> jsonData) {
    return simpleOwnerAuth.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with owner auth allowing others to read: 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the allowRead type in your schema. */
@immutable
class allowRead extends Model {
  static const classType = const _allowReadModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const allowRead._internal({@required this.id, this.name, this.bar});

  factory allowRead({String id, String name, String bar}) {
    return allowRead._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is allowRead &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"allowRead {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  allowRead copyWith({String id, String name, String bar}) {
    return allowRead(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  allowRead.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"allowRead.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"allowRead\\";
    modelSchemaDefinition.pluralName = \\"allowReads\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"owner\\",
          identityClaim: \\"cognito:username\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.DELETE,
            ModelOperation.UPDATE
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: allowRead.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: allowRead.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _allowReadModelType extends ModelType<allowRead> {
  const _allowReadModelType();

  @override
  allowRead fromJson(Map<String, dynamic> jsonData) {
    return allowRead.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with private authorization 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the privateType type in your schema. */
@immutable
class privateType extends Model {
  static const classType = const _privateTypeModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const privateType._internal({@required this.id, this.name, this.bar});

  factory privateType({String id, String name, String bar}) {
    return privateType._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is privateType &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"privateType {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  privateType copyWith({String id, String name, String bar}) {
    return privateType(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  privateType.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"privateType.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"privateType\\";
    modelSchemaDefinition.pluralName = \\"privateTypes\\";

    modelSchemaDefinition.authRules = [
      AuthRule(authStrategy: AuthStrategy.PRIVATE, operations: [
        ModelOperation.CREATE,
        ModelOperation.UPDATE,
        ModelOperation.DELETE,
        ModelOperation.READ
      ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: privateType.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: privateType.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _privateTypeModelType extends ModelType<privateType> {
  const _privateTypeModelType();

  @override
  privateType fromJson(Map<String, dynamic> jsonData) {
    return privateType.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with public authorization 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the publicType type in your schema. */
@immutable
class publicType extends Model {
  static const classType = const _publicTypeModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const publicType._internal({@required this.id, this.name, this.bar});

  factory publicType({String id, String name, String bar}) {
    return publicType._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is publicType &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"publicType {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  publicType copyWith({String id, String name, String bar}) {
    return publicType(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  publicType.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"publicType.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"publicType\\";
    modelSchemaDefinition.pluralName = \\"publicTypes\\";

    modelSchemaDefinition.authRules = [
      AuthRule(authStrategy: AuthStrategy.PUBLIC, operations: [
        ModelOperation.CREATE,
        ModelOperation.UPDATE,
        ModelOperation.DELETE,
        ModelOperation.READ
      ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: publicType.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: publicType.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _publicTypeModelType extends ModelType<publicType> {
  const _publicTypeModelType();

  @override
  publicType fromJson(Map<String, dynamic> jsonData) {
    return publicType.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with static groups 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the staticGroups type in your schema. */
@immutable
class staticGroups extends Model {
  static const classType = const _staticGroupsModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const staticGroups._internal({@required this.id, this.name, this.bar});

  factory staticGroups({String id, String name, String bar}) {
    return staticGroups._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is staticGroups &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"staticGroups {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  staticGroups copyWith({String id, String name, String bar}) {
    return staticGroups(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  staticGroups.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"staticGroups.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"staticGroups\\";
    modelSchemaDefinition.pluralName = \\"staticGroups\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.GROUPS,
          groupClaim: \\"cognito:groups\\",
          groups: [
            \\"Admin\\"
          ],
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: staticGroups.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: staticGroups.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _staticGroupsModelType extends ModelType<staticGroups> {
  const _staticGroupsModelType();

  @override
  staticGroups fromJson(Map<String, dynamic> jsonData) {
    return staticGroups.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should include authRules in schema when owner auth is used with ownerField 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String title;
  final String author;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Post._internal(
      {@required this.id, @required this.title, @required this.author});

  factory Post({String id, @required String title, @required String author}) {
    return Post._internal(
        id: id == null ? UUID.getUUID() : id, title: title, author: author);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
        id == other.id &&
        title == other.title &&
        author == other.author;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$title\\" + \\", \\");
    buffer.write(\\"author=\\" + \\"$author\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Post copyWith({String id, String title, String author}) {
    return Post(
        id: id ?? this.id,
        title: title ?? this.title,
        author: author ?? this.author);
  }

  Post.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        title = json['title'],
        author = json['author'];

  Map<String, dynamic> toJson() => {'id': id, 'title': title, 'author': author};

  static final QueryField ID = QueryField(fieldName: \\"post.id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField AUTHOR = QueryField(fieldName: \\"author\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"author\\",
          identityClaim: \\"cognito:username\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.TITLE,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.AUTHOR,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();

  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should support multiple auth rules 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String title;
  final String owner;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Post._internal(
      {@required this.id, @required this.title, @required this.owner});

  factory Post({String id, @required String title, @required String owner}) {
    return Post._internal(
        id: id == null ? UUID.getUUID() : id, title: title, owner: owner);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
        id == other.id &&
        title == other.title &&
        owner == other.owner;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$title\\" + \\", \\");
    buffer.write(\\"owner=\\" + \\"$owner\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Post copyWith({String id, String title, String owner}) {
    return Post(
        id: id ?? this.id,
        title: title ?? this.title,
        owner: owner ?? this.owner);
  }

  Post.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        title = json['title'],
        owner = json['owner'];

  Map<String, dynamic> toJson() => {'id': id, 'title': title, 'owner': owner};

  static final QueryField ID = QueryField(fieldName: \\"post.id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField OWNER = QueryField(fieldName: \\"owner\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.GROUPS,
          groupClaim: \\"cognito:groups\\",
          groups: [
            \\"admin\\"
          ],
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ]),
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"owner\\",
          identityClaim: \\"cognito:username\\",
          operations: [ModelOperation.CREATE, ModelOperation.UPDATE]),
      AuthRule(authStrategy: AuthStrategy.PUBLIC, operations: [
        ModelOperation.CREATE,
        ModelOperation.UPDATE,
        ModelOperation.DELETE,
        ModelOperation.READ
      ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.TITLE,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.OWNER,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();

  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should generate classes for models with one to many connection 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Todo type in your schema. */
@immutable
class Todo extends Model {
  static const classType = const _TodoModelType();
  final String id;
  final List<Task> tasks;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Todo._internal({@required this.id, this.tasks});

  factory Todo({String id, List<Task> tasks}) {
    return Todo._internal(
        id: id == null ? UUID.getUUID() : id,
        tasks: tasks != null ? List<Task>.unmodifiable(tasks) : tasks);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Todo &&
        id == other.id &&
        DeepCollectionEquality().equals(tasks, other.tasks);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Todo {\\");
    buffer.write(\\"id=\\" + \\"$id\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Todo copyWith({String id, List<Task> tasks}) {
    return Todo(id: id ?? this.id, tasks: tasks ?? this.tasks);
  }

  Todo.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        tasks = json['tasks'] is List
            ? (json['tasks'] as List)
                .map((e) => Task.fromJson(new Map<String, dynamic>.from(e)))
                .toList()
            : null;

  Map<String, dynamic> toJson() =>
      {'id': id, 'tasks': tasks?.map((Task? e) => e?.toJson()).toList()};

  static final QueryField ID = QueryField(fieldName: \\"todo.id\\");
  static final QueryField TASKS = QueryField(
      fieldName: \\"tasks\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Task).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Todo\\";
    modelSchemaDefinition.pluralName = \\"Todos\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
        key: Todo.TASKS,
        isRequired: false,
        ofModelName: (Task).toString(),
        associatedKey: Task.TODO));
  });
}

class _TodoModelType extends ModelType<Todo> {
  const _TodoModelType();

  @override
  Todo fromJson(Map<String, dynamic> jsonData) {
    return Todo.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should generate classes for models with one to many connection 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Task type in your schema. */
@immutable
class Task extends Model {
  static const classType = const _TaskModelType();
  final String id;
  final Todo todo;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Task._internal({@required this.id, this.todo});

  factory Task({String id, Todo todo}) {
    return Task._internal(id: id == null ? UUID.getUUID() : id, todo: todo);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Task && id == other.id && todo == other.todo;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Task {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"todo=\\" + (todo != null ? todo.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Task copyWith({String id, Todo todo}) {
    return Task(id: id ?? this.id, todo: todo ?? this.todo);
  }

  Task.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        todo = json['todo'] != null
            ? Todo.fromJson(new Map<String, dynamic>.from(json['todo']))
            : null;

  Map<String, dynamic> toJson() => {'id': id, 'todo': todo?.toJson()};

  static final QueryField ID = QueryField(fieldName: \\"task.id\\");
  static final QueryField TODO = QueryField(
      fieldName: \\"todo\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Todo).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Task\\";
    modelSchemaDefinition.pluralName = \\"Tasks\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
        key: Task.TODO,
        isRequired: false,
        targetName: \\"taskTodoId\\",
        ofModelName: (Todo).toString()));
  });
}

class _TaskModelType extends ModelType<Task> {
  const _TaskModelType();

  @override
  Task fromJson(Map<String, dynamic> jsonData) {
    return Task.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should support connection directive with keyName and fields 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Blog type in your schema. */
@immutable
class Blog extends Model {
  static const classType = const _BlogModelType();
  final String id;
  final String name;
  final List<Post> posts;
  final List<String> test;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Blog._internal(
      {@required this.id, @required this.name, this.posts, this.test});

  factory Blog(
      {String id, @required String name, List<Post> posts, List<String> test}) {
    return Blog._internal(
        id: id == null ? UUID.getUUID() : id,
        name: name,
        posts: posts != null ? List<Post>.unmodifiable(posts) : posts,
        test: test != null ? List<String>.unmodifiable(test) : test);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Blog &&
        id == other.id &&
        name == other.name &&
        DeepCollectionEquality().equals(posts, other.posts) &&
        DeepCollectionEquality().equals(test, other.test);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Blog {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"test=\\" + (test != null ? test.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Blog copyWith({String id, String name, List<Post> posts, List<String> test}) {
    return Blog(
        id: id ?? this.id,
        name: name ?? this.name,
        posts: posts ?? this.posts,
        test: test ?? this.test);
  }

  Blog.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        posts = json['posts'] is List
            ? (json['posts'] as List)
                .map((e) => Post.fromJson(new Map<String, dynamic>.from(e)))
                .toList()
            : null,
        test = json['test']?.cast<String>();

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'posts': posts?.map((Post? e) => e?.toJson()).toList(),
        'test': test
      };

  static final QueryField ID = QueryField(fieldName: \\"blog.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField POSTS = QueryField(
      fieldName: \\"posts\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Post).toString()));
  static final QueryField TEST = QueryField(fieldName: \\"test\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Blog\\";
    modelSchemaDefinition.pluralName = \\"Blogs\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Blog.NAME,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
        key: Blog.POSTS,
        isRequired: false,
        ofModelName: (Post).toString(),
        associatedKey: Post.BLOG));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Blog.TEST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.string))));
  });
}

class _BlogModelType extends ModelType<Blog> {
  const _BlogModelType();

  @override
  Blog fromJson(Map<String, dynamic> jsonData) {
    return Blog.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should support connection directive with keyName and fields 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final Post post;
  final String content;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Comment._internal(
      {@required this.id, this.post, @required this.content});

  factory Comment({String id, Post post, @required String content}) {
    return Comment._internal(
        id: id == null ? UUID.getUUID() : id, post: post, content: content);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
        id == other.id &&
        post == other.post &&
        content == other.content;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (post != null ? post.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"content=\\" + \\"$content\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Comment copyWith({String id, Post post, String content}) {
    return Comment(
        id: id ?? this.id,
        post: post ?? this.post,
        content: content ?? this.content);
  }

  Comment.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        post = json['post'] != null
            ? Post.fromJson(new Map<String, dynamic>.from(json['post']))
            : null,
        content = json['content'];

  Map<String, dynamic> toJson() =>
      {'id': id, 'post': post?.toJson(), 'content': content};

  static final QueryField ID = QueryField(fieldName: \\"comment.id\\");
  static final QueryField POST = QueryField(
      fieldName: \\"post\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Post).toString()));
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
        key: Comment.POST,
        isRequired: false,
        targetName: \\"postID\\",
        ofModelName: (Post).toString()));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Comment.CONTENT,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();

  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should support connection directive with keyName and fields 3`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String title;
  final Blog blog;
  final List<Comment> comments;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Post._internal(
      {@required this.id, @required this.title, this.blog, this.comments});

  factory Post(
      {String id, @required String title, Blog blog, List<Comment> comments}) {
    return Post._internal(
        id: id == null ? UUID.getUUID() : id,
        title: title,
        blog: blog,
        comments:
            comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
        id == other.id &&
        title == other.title &&
        blog == other.blog &&
        DeepCollectionEquality().equals(comments, other.comments);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$title\\" + \\", \\");
    buffer.write(\\"blog=\\" + (blog != null ? blog.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Post copyWith({String id, String title, Blog blog, List<Comment> comments}) {
    return Post(
        id: id ?? this.id,
        title: title ?? this.title,
        blog: blog ?? this.blog,
        comments: comments ?? this.comments);
  }

  Post.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        title = json['title'],
        blog = json['blog'] != null
            ? Blog.fromJson(new Map<String, dynamic>.from(json['blog']))
            : null,
        comments = json['comments'] is List
            ? (json['comments'] as List)
                .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e)))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'blog': blog?.toJson(),
        'comments': comments?.map((Comment? e) => e?.toJson()).toList()
      };

  static final QueryField ID = QueryField(fieldName: \\"post.id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField BLOG = QueryField(
      fieldName: \\"blog\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Blog).toString()));
  static final QueryField COMMENTS = QueryField(
      fieldName: \\"comments\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Comment).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.TITLE,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
        key: Post.BLOG,
        isRequired: false,
        targetName: \\"blogID\\",
        ofModelName: (Blog).toString()));

    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
        key: Post.COMMENTS,
        isRequired: false,
        ofModelName: (Comment).toString(),
        associatedKey: Comment.POST));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();

  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Key Directive should generate a class for model with key directive 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the authorBook type in your schema. */
@immutable
class authorBook extends Model {
  static const classType = const _authorBookModelType();
  final String id;
  final String author_id;
  final String book_id;
  final String author;
  final String book;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const authorBook._internal(
      {@required this.id,
      @required this.author_id,
      @required this.book_id,
      this.author,
      this.book});

  factory authorBook(
      {String id,
      @required String author_id,
      @required String book_id,
      String author,
      String book}) {
    return authorBook._internal(
        id: id == null ? UUID.getUUID() : id,
        author_id: author_id,
        book_id: book_id,
        author: author,
        book: book);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is authorBook &&
        id == other.id &&
        author_id == other.author_id &&
        book_id == other.book_id &&
        author == other.author &&
        book == other.book;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"authorBook {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"author_id=\\" + \\"$author_id\\" + \\", \\");
    buffer.write(\\"book_id=\\" + \\"$book_id\\" + \\", \\");
    buffer.write(\\"author=\\" + \\"$author\\" + \\", \\");
    buffer.write(\\"book=\\" + \\"$book\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  authorBook copyWith(
      {String id,
      String author_id,
      String book_id,
      String author,
      String book}) {
    return authorBook(
        id: id ?? this.id,
        author_id: author_id ?? this.author_id,
        book_id: book_id ?? this.book_id,
        author: author ?? this.author,
        book: book ?? this.book);
  }

  authorBook.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        author_id = json['author_id'],
        book_id = json['book_id'],
        author = json['author'],
        book = json['book'];

  Map<String, dynamic> toJson() => {
        'id': id,
        'author_id': author_id,
        'book_id': book_id,
        'author': author,
        'book': book
      };

  static final QueryField ID = QueryField(fieldName: \\"authorBook.id\\");
  static final QueryField AUTHOR_ID = QueryField(fieldName: \\"author_id\\");
  static final QueryField BOOK_ID = QueryField(fieldName: \\"book_id\\");
  static final QueryField AUTHOR = QueryField(fieldName: \\"author\\");
  static final QueryField BOOK = QueryField(fieldName: \\"book\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"authorBook\\";
    modelSchemaDefinition.pluralName = \\"authorBooks\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: authorBook.AUTHOR_ID,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: authorBook.BOOK_ID,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: authorBook.AUTHOR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: authorBook.BOOK,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _authorBookModelType extends ModelType<authorBook> {
  const _authorBookModelType();

  @override
  authorBook fromJson(Map<String, dynamic> jsonData) {
    return authorBook.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct internal constructor for a model has only ID field 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TestModel type in your schema. */
@immutable
class TestModel extends Model {
  static const classType = const _TestModelModelType();
  final String id;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  const TestModel._internal({required this.id});
  
  factory TestModel({String? id}) {
    return TestModel._internal(
      id: id == null ? UUID.getUUID() : id);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestModel &&
      id == other.id;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TestModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TestModel copyWith({String? id}) {
    return TestModel(
      id: id ?? this.id);
  }
  
  TestModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'];
  
  Map<String, dynamic> toJson() => {
    'id': id
  };

  static final QueryField ID = QueryField(fieldName: \\"testModel.id\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestModel\\";
    modelSchemaDefinition.pluralName = \\"TestModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
  });
}

class _TestModelModelType extends ModelType<TestModel> {
  const _TestModelModelType();
  
  @override
  TestModel fromJson(Map<String, dynamic> jsonData) {
    return TestModel.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct model files if the null safety is enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Blog type in your schema. */
@immutable
class Blog extends Model {
  static const classType = const _BlogModelType();
  final String id;
  final String? _name;
  final List<Post>? _posts;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  List<Post>? get posts {
    return _posts;
  }
  
  const Blog._internal({required this.id, required name, posts}): _name = name, _posts = posts;
  
  factory Blog({String? id, required String name, List<Post>? posts}) {
    return Blog._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      posts: posts != null ? List<Post>.unmodifiable(posts) : posts);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Blog &&
      id == other.id &&
      _name == other._name &&
      DeepCollectionEquality().equals(_posts, other._posts);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Blog {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Blog copyWith({String? id, String? name, List<Post>? posts}) {
    return Blog(
      id: id ?? this.id,
      name: name ?? this.name,
      posts: posts ?? this.posts);
  }
  
  Blog.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _posts = json['posts'] is List
        ? (json['posts'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Post.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'posts': _posts?.map((Post? e) => e?.toJson()).toList()
  };

  static final QueryField ID = QueryField(fieldName: \\"blog.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField POSTS = QueryField(
    fieldName: \\"posts\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Post).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Blog\\";
    modelSchemaDefinition.pluralName = \\"Blogs\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Blog.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Blog.POSTS,
      isRequired: false,
      ofModelName: (Post).toString(),
      associatedKey: Post.BLOG
    ));
  });
}

class _BlogModelType extends ModelType<Blog> {
  const _BlogModelType();
  
  @override
  Blog fromJson(Map<String, dynamic> jsonData) {
    return Blog.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct model files if the null safety is enabled 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final Post? _post;
  final String? _content;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  Post? get post {
    return _post;
  }
  
  String get content {
    try {
      return _content!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  const Comment._internal({required this.id, post, required content}): _post = post, _content = content;
  
  factory Comment({String? id, Post? post, required String content}) {
    return Comment._internal(
      id: id == null ? UUID.getUUID() : id,
      post: post,
      content: content);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
      id == other.id &&
      _post == other._post &&
      _content == other._content;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (_post != null ? _post!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment copyWith({String? id, Post? post, String? content}) {
    return Comment(
      id: id ?? this.id,
      post: post ?? this.post,
      content: content ?? this.content);
  }
  
  Comment.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _post = json['post']?['serializedData'] != null
        ? Post.fromJson(new Map<String, dynamic>.from(json['post']['serializedData']))
        : null,
      _content = json['content'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'post': _post?.toJson(), 'content': _content
  };

  static final QueryField ID = QueryField(fieldName: \\"comment.id\\");
  static final QueryField POST = QueryField(
    fieldName: \\"post\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Post).toString()));
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Comment.POST,
      isRequired: false,
      targetName: \\"postID\\",
      ofModelName: (Post).toString()
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.CONTENT,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();
  
  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct model files if the null safety is enabled 3`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final Blog? _blog;
  final List<Comment>? _comments;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  Blog? get blog {
    return _blog;
  }
  
  List<Comment>? get comments {
    return _comments;
  }
  
  const Post._internal({required this.id, required title, blog, comments}): _title = title, _blog = blog, _comments = comments;
  
  factory Post({String? id, required String title, Blog? blog, List<Comment>? comments}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      blog: blog,
      comments: comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      _blog == other._blog &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"blog=\\" + (_blog != null ? _blog!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, Blog? blog, List<Comment>? comments}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      blog: blog ?? this.blog,
      comments: comments ?? this.comments);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _blog = json['blog']?['serializedData'] != null
        ? Blog.fromJson(new Map<String, dynamic>.from(json['blog']['serializedData']))
        : null,
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'blog': _blog?.toJson(), 'comments': _comments?.map((Comment? e) => e?.toJson()).toList()
  };

  static final QueryField ID = QueryField(fieldName: \\"post.id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField BLOG = QueryField(
    fieldName: \\"blog\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Blog).toString()));
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Comment).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Post.BLOG,
      isRequired: false,
      targetName: \\"blogID\\",
      ofModelName: (Blog).toString()
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.COMMENTS,
      isRequired: false,
      ofModelName: (Comment).toString(),
      associatedKey: Comment.POST
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct null safe output for regular field w/o list or nullable 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TestModel type in your schema. */
@immutable
class TestModel extends Model {
  static const classType = const _TestModelModelType();
  final String id;
  final double? _floatVal;
  final double? _floatNullableVal;
  final List<double>? _floatList;
  final List<double>? _floatNullableList;
  final List<double>? _nullableFloatList;
  final List<double>? _nullableFloatNullableList;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  double get floatVal {
    try {
      return _floatVal!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  double? get floatNullableVal {
    return _floatNullableVal;
  }
  
  List<double> get floatList {
    try {
      return _floatList!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  List<double>? get floatNullableList {
    return _floatNullableList;
  }
  
  List<double> get nullableFloatList {
    try {
      return _nullableFloatList!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  List<double>? get nullableFloatNullableList {
    return _nullableFloatNullableList;
  }
  
  const TestModel._internal({required this.id, required floatVal, floatNullableVal, required floatList, floatNullableList, required nullableFloatList, nullableFloatNullableList}): _floatVal = floatVal, _floatNullableVal = floatNullableVal, _floatList = floatList, _floatNullableList = floatNullableList, _nullableFloatList = nullableFloatList, _nullableFloatNullableList = nullableFloatNullableList;
  
  factory TestModel({String? id, required double floatVal, double? floatNullableVal, required List<double> floatList, List<double>? floatNullableList, required List<double> nullableFloatList, List<double>? nullableFloatNullableList}) {
    return TestModel._internal(
      id: id == null ? UUID.getUUID() : id,
      floatVal: floatVal,
      floatNullableVal: floatNullableVal,
      floatList: floatList != null ? List<double>.unmodifiable(floatList) : floatList,
      floatNullableList: floatNullableList != null ? List<double>.unmodifiable(floatNullableList) : floatNullableList,
      nullableFloatList: nullableFloatList != null ? List<double>.unmodifiable(nullableFloatList) : nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList != null ? List<double>.unmodifiable(nullableFloatNullableList) : nullableFloatNullableList);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestModel &&
      id == other.id &&
      _floatVal == other._floatVal &&
      _floatNullableVal == other._floatNullableVal &&
      DeepCollectionEquality().equals(_floatList, other._floatList) &&
      DeepCollectionEquality().equals(_floatNullableList, other._floatNullableList) &&
      DeepCollectionEquality().equals(_nullableFloatList, other._nullableFloatList) &&
      DeepCollectionEquality().equals(_nullableFloatNullableList, other._nullableFloatNullableList);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TestModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"floatVal=\\" + (_floatVal != null ? _floatVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableVal=\\" + (_floatNullableVal != null ? _floatNullableVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatList=\\" + (_floatList != null ? _floatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableList=\\" + (_floatNullableList != null ? _floatNullableList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatList=\\" + (_nullableFloatList != null ? _nullableFloatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatNullableList=\\" + (_nullableFloatNullableList != null ? _nullableFloatNullableList!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TestModel copyWith({String? id, double? floatVal, double? floatNullableVal, List<double>? floatList, List<double>? floatNullableList, List<double>? nullableFloatList, List<double>? nullableFloatNullableList}) {
    return TestModel(
      id: id ?? this.id,
      floatVal: floatVal ?? this.floatVal,
      floatNullableVal: floatNullableVal ?? this.floatNullableVal,
      floatList: floatList ?? this.floatList,
      floatNullableList: floatNullableList ?? this.floatNullableList,
      nullableFloatList: nullableFloatList ?? this.nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList ?? this.nullableFloatNullableList);
  }
  
  TestModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _floatVal = (json['floatVal'] as num?)?.toDouble(),
      _floatNullableVal = (json['floatNullableVal'] as num?)?.toDouble(),
      _floatList = (json['floatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _floatNullableList = (json['floatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatList = (json['nullableFloatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatNullableList = (json['nullableFloatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList();
  
  Map<String, dynamic> toJson() => {
    'id': id, 'floatVal': _floatVal, 'floatNullableVal': _floatNullableVal, 'floatList': _floatList, 'floatNullableList': _floatNullableList, 'nullableFloatList': _nullableFloatList, 'nullableFloatNullableList': _nullableFloatNullableList
  };

  static final QueryField ID = QueryField(fieldName: \\"testModel.id\\");
  static final QueryField FLOATVAL = QueryField(fieldName: \\"floatVal\\");
  static final QueryField FLOATNULLABLEVAL = QueryField(fieldName: \\"floatNullableVal\\");
  static final QueryField FLOATLIST = QueryField(fieldName: \\"floatList\\");
  static final QueryField FLOATNULLABLELIST = QueryField(fieldName: \\"floatNullableList\\");
  static final QueryField NULLABLEFLOATLIST = QueryField(fieldName: \\"nullableFloatList\\");
  static final QueryField NULLABLEFLOATNULLABLELIST = QueryField(fieldName: \\"nullableFloatNullableList\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestModel\\";
    modelSchemaDefinition.pluralName = \\"TestModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATVAL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLEVAL,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
  });
}

class _TestModelModelType extends ModelType<TestModel> {
  const _TestModelModelType();
  
  @override
  TestModel fromJson(Map<String, dynamic> jsonData) {
    return TestModel.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct null safe output for regular scalar/list fields 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TestModel type in your schema. */
@immutable
class TestModel extends Model {
  static const classType = const _TestModelModelType();
  final String id;
  final double? _floatVal;
  final double? _floatNullableVal;
  final List<double>? _floatList;
  final List<double>? _floatNullableList;
  final List<double>? _nullableFloatList;
  final List<double>? _nullableFloatNullableList;
  final int? _intVal;
  final int? _intNullableVal;
  final List<int>? _intList;
  final List<int>? _intNullableList;
  final List<int>? _nullableIntList;
  final List<int>? _nullableIntNullableList;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  double get floatVal {
    try {
      return _floatVal!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  double? get floatNullableVal {
    return _floatNullableVal;
  }
  
  List<double> get floatList {
    try {
      return _floatList!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  List<double>? get floatNullableList {
    return _floatNullableList;
  }
  
  List<double> get nullableFloatList {
    try {
      return _nullableFloatList!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  List<double>? get nullableFloatNullableList {
    return _nullableFloatNullableList;
  }
  
  int get intVal {
    try {
      return _intVal!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  int? get intNullableVal {
    return _intNullableVal;
  }
  
  List<int> get intList {
    try {
      return _intList!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  List<int>? get intNullableList {
    return _intNullableList;
  }
  
  List<int> get nullableIntList {
    try {
      return _nullableIntList!;
    } catch(e) {
      throw new DataStoreException(
      DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
      recoverySuggestion:
        DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
      underlyingException: e.toString()
    );
    }
  }
  
  List<int>? get nullableIntNullableList {
    return _nullableIntNullableList;
  }
  
  const TestModel._internal({required this.id, required floatVal, floatNullableVal, required floatList, floatNullableList, required nullableFloatList, nullableFloatNullableList, required intVal, intNullableVal, required intList, intNullableList, required nullableIntList, nullableIntNullableList}): _floatVal = floatVal, _floatNullableVal = floatNullableVal, _floatList = floatList, _floatNullableList = floatNullableList, _nullableFloatList = nullableFloatList, _nullableFloatNullableList = nullableFloatNullableList, _intVal = intVal, _intNullableVal = intNullableVal, _intList = intList, _intNullableList = intNullableList, _nullableIntList = nullableIntList, _nullableIntNullableList = nullableIntNullableList;
  
  factory TestModel({String? id, required double floatVal, double? floatNullableVal, required List<double> floatList, List<double>? floatNullableList, required List<double> nullableFloatList, List<double>? nullableFloatNullableList, required int intVal, int? intNullableVal, required List<int> intList, List<int>? intNullableList, required List<int> nullableIntList, List<int>? nullableIntNullableList}) {
    return TestModel._internal(
      id: id == null ? UUID.getUUID() : id,
      floatVal: floatVal,
      floatNullableVal: floatNullableVal,
      floatList: floatList != null ? List<double>.unmodifiable(floatList) : floatList,
      floatNullableList: floatNullableList != null ? List<double>.unmodifiable(floatNullableList) : floatNullableList,
      nullableFloatList: nullableFloatList != null ? List<double>.unmodifiable(nullableFloatList) : nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList != null ? List<double>.unmodifiable(nullableFloatNullableList) : nullableFloatNullableList,
      intVal: intVal,
      intNullableVal: intNullableVal,
      intList: intList != null ? List<int>.unmodifiable(intList) : intList,
      intNullableList: intNullableList != null ? List<int>.unmodifiable(intNullableList) : intNullableList,
      nullableIntList: nullableIntList != null ? List<int>.unmodifiable(nullableIntList) : nullableIntList,
      nullableIntNullableList: nullableIntNullableList != null ? List<int>.unmodifiable(nullableIntNullableList) : nullableIntNullableList);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestModel &&
      id == other.id &&
      _floatVal == other._floatVal &&
      _floatNullableVal == other._floatNullableVal &&
      DeepCollectionEquality().equals(_floatList, other._floatList) &&
      DeepCollectionEquality().equals(_floatNullableList, other._floatNullableList) &&
      DeepCollectionEquality().equals(_nullableFloatList, other._nullableFloatList) &&
      DeepCollectionEquality().equals(_nullableFloatNullableList, other._nullableFloatNullableList) &&
      _intVal == other._intVal &&
      _intNullableVal == other._intNullableVal &&
      DeepCollectionEquality().equals(_intList, other._intList) &&
      DeepCollectionEquality().equals(_intNullableList, other._intNullableList) &&
      DeepCollectionEquality().equals(_nullableIntList, other._nullableIntList) &&
      DeepCollectionEquality().equals(_nullableIntNullableList, other._nullableIntNullableList);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TestModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"floatVal=\\" + (_floatVal != null ? _floatVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableVal=\\" + (_floatNullableVal != null ? _floatNullableVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatList=\\" + (_floatList != null ? _floatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableList=\\" + (_floatNullableList != null ? _floatNullableList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatList=\\" + (_nullableFloatList != null ? _nullableFloatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatNullableList=\\" + (_nullableFloatNullableList != null ? _nullableFloatNullableList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intVal=\\" + (_intVal != null ? _intVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intNullableVal=\\" + (_intNullableVal != null ? _intNullableVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intList=\\" + (_intList != null ? _intList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intNullableList=\\" + (_intNullableList != null ? _intNullableList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableIntList=\\" + (_nullableIntList != null ? _nullableIntList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableIntNullableList=\\" + (_nullableIntNullableList != null ? _nullableIntNullableList!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TestModel copyWith({String? id, double? floatVal, double? floatNullableVal, List<double>? floatList, List<double>? floatNullableList, List<double>? nullableFloatList, List<double>? nullableFloatNullableList, int? intVal, int? intNullableVal, List<int>? intList, List<int>? intNullableList, List<int>? nullableIntList, List<int>? nullableIntNullableList}) {
    return TestModel(
      id: id ?? this.id,
      floatVal: floatVal ?? this.floatVal,
      floatNullableVal: floatNullableVal ?? this.floatNullableVal,
      floatList: floatList ?? this.floatList,
      floatNullableList: floatNullableList ?? this.floatNullableList,
      nullableFloatList: nullableFloatList ?? this.nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList ?? this.nullableFloatNullableList,
      intVal: intVal ?? this.intVal,
      intNullableVal: intNullableVal ?? this.intNullableVal,
      intList: intList ?? this.intList,
      intNullableList: intNullableList ?? this.intNullableList,
      nullableIntList: nullableIntList ?? this.nullableIntList,
      nullableIntNullableList: nullableIntNullableList ?? this.nullableIntNullableList);
  }
  
  TestModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _floatVal = (json['floatVal'] as num?)?.toDouble(),
      _floatNullableVal = (json['floatNullableVal'] as num?)?.toDouble(),
      _floatList = (json['floatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _floatNullableList = (json['floatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatList = (json['nullableFloatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatNullableList = (json['nullableFloatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _intVal = (json['intVal'] as num?)?.toInt(),
      _intNullableVal = (json['intNullableVal'] as num?)?.toInt(),
      _intList = (json['intList'] as List?)?.map((e) => (e as num).toInt()).toList(),
      _intNullableList = (json['intNullableList'] as List?)?.map((e) => (e as num).toInt()).toList(),
      _nullableIntList = (json['nullableIntList'] as List?)?.map((e) => (e as num).toInt()).toList(),
      _nullableIntNullableList = (json['nullableIntNullableList'] as List?)?.map((e) => (e as num).toInt()).toList();
  
  Map<String, dynamic> toJson() => {
    'id': id, 'floatVal': _floatVal, 'floatNullableVal': _floatNullableVal, 'floatList': _floatList, 'floatNullableList': _floatNullableList, 'nullableFloatList': _nullableFloatList, 'nullableFloatNullableList': _nullableFloatNullableList, 'intVal': _intVal, 'intNullableVal': _intNullableVal, 'intList': _intList, 'intNullableList': _intNullableList, 'nullableIntList': _nullableIntList, 'nullableIntNullableList': _nullableIntNullableList
  };

  static final QueryField ID = QueryField(fieldName: \\"testModel.id\\");
  static final QueryField FLOATVAL = QueryField(fieldName: \\"floatVal\\");
  static final QueryField FLOATNULLABLEVAL = QueryField(fieldName: \\"floatNullableVal\\");
  static final QueryField FLOATLIST = QueryField(fieldName: \\"floatList\\");
  static final QueryField FLOATNULLABLELIST = QueryField(fieldName: \\"floatNullableList\\");
  static final QueryField NULLABLEFLOATLIST = QueryField(fieldName: \\"nullableFloatList\\");
  static final QueryField NULLABLEFLOATNULLABLELIST = QueryField(fieldName: \\"nullableFloatNullableList\\");
  static final QueryField INTVAL = QueryField(fieldName: \\"intVal\\");
  static final QueryField INTNULLABLEVAL = QueryField(fieldName: \\"intNullableVal\\");
  static final QueryField INTLIST = QueryField(fieldName: \\"intList\\");
  static final QueryField INTNULLABLELIST = QueryField(fieldName: \\"intNullableList\\");
  static final QueryField NULLABLEINTLIST = QueryField(fieldName: \\"nullableIntList\\");
  static final QueryField NULLABLEINTNULLABLELIST = QueryField(fieldName: \\"nullableIntNullableList\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestModel\\";
    modelSchemaDefinition.pluralName = \\"TestModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATVAL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLEVAL,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.INTVAL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.INTNULLABLEVAL,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.INTLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.int))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.INTNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.int))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEINTLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.int))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEINTNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.int))
    ));
  });
}

class _TestModelModelType extends ModelType<TestModel> {
  const _TestModelModelType();
  
  @override
  TestModel fromJson(Map<String, dynamic> jsonData) {
    return TestModel.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Read-only Field Tests should generate the read-only timestamp fields when isTimestampFields is true 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String name;
  final TemporalDateTime createdAt;
  final TemporalDateTime updatedAt;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const SimpleModel._internal(
      {@required this.id, this.name, this.createdAt, this.updatedAt});

  factory SimpleModel({String id, String name}) {
    return SimpleModel._internal(
        id: id == null ? UUID.getUUID() : id, name: name);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel && id == other.id && name == other.name;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"createdAt=\\" +
        (createdAt != null ? createdAt.format() : \\"null\\") +
        \\", \\");
    buffer.write(
        \\"updatedAt=\\" + (updatedAt != null ? updatedAt.format() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  SimpleModel copyWith({String id, String name}) {
    return SimpleModel._internal(id: id ?? this.id, name: name ?? this.name);
  }

  SimpleModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        createdAt = json['createdAt'] != null
            ? TemporalDateTime.fromString(json['createdAt'])
            : null,
        updatedAt = json['updatedAt'] != null
            ? TemporalDateTime.fromString(json['updatedAt'])
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'createdAt': createdAt?.format(),
        'updatedAt': updatedAt?.format()
      };

  static final QueryField ID = QueryField(fieldName: \\"simpleModel.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
        fieldName: 'createdAt',
        isRequired: false,
        isReadOnly: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)));

    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
        fieldName: 'updatedAt',
        isRequired: false,
        isReadOnly: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();

  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Read-only and Null Safety Combined Tests should generate the read-only timestamp fields when isTimestampFields is true and with null safety 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String? _name;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const SimpleModel._internal({required this.id, name, createdAt, updatedAt}): _name = name, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory SimpleModel({String? id, String? name}) {
    return SimpleModel._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel &&
      id == other.id &&
      _name == other._name;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  SimpleModel copyWith({String? id, String? name}) {
    return SimpleModel._internal(
      id: id ?? this.id,
      name: name ?? this.name);
  }
  
  SimpleModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };

  static final QueryField ID = QueryField(fieldName: \\"simpleModel.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: SimpleModel.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();
  
  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
}"
`;
