// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AppSync Dart Visitor Dart Specific Tests should generate the model provider 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'SimpleModel.dart';

export 'SimpleModel.dart';

class ModelProvider implements ModelProviderInterface {
  @override
  String version = \\"20078c21a81919792555926e238b194e\\";
  @override
  List<ModelSchema> modelSchemas = [SimpleModel.schema];
  static final ModelProvider _instance = ModelProvider();

  static ModelProvider get instance => _instance;

  ModelType getModelTypeByModelName(String modelName) {
    switch (modelName) {
      case \\"SimpleModel\\":
        {
          return SimpleModel.classType;
        }
        break;
      default:
        {
          throw Exception(
              \\"Failed to find model in model provider for model name: \\" +
                  modelName);
        }
    }
  }
}
"
`;

exports[`AppSync Dart Visitor Enum Generation should generate a class for enum type 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final Status status;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const SimpleModel._internal({@required this.id, this.status});

  factory SimpleModel({String id, Status status}) {
    return SimpleModel._internal(
        id: id == null ? UUID.getUUID() : id, status: status);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel && id == other.id && status == other.status;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"status=\\" + (status != null ? enumToString(status) : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  SimpleModel copyWith({String id, Status status}) {
    return SimpleModel(id: id ?? this.id, status: status ?? this.status);
  }

  SimpleModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        status = enumFromString<Status>(json['status'], Status.values);

  Map<String, dynamic> toJson() => {'id': id, 'status': enumToString(status)};

  static final QueryField ID = QueryField(fieldName: \\"simpleModel.id\\");
  static final QueryField STATUS = QueryField(fieldName: \\"status\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.STATUS,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();

  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Enum Generation should generate a class for enum type 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

enum Status { yes, no, maybe }
"
`;

exports[`AppSync Dart Visitor Field tests should generate correct output for appsync scalar types of time and int 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the TemporalTimeModel type in your schema. */
@immutable
class TemporalTimeModel extends Model {
  static const classType = const _TemporalTimeModelModelType();
  final String id;
  final TemporalDate date;
  final TemporalTime time;
  final TemporalDateTime dateTime;
  final TemporalTimestamp timestamp;
  final List<TemporalDate> dateList;
  final List<TemporalTime> timeList;
  final List<TemporalDateTime> dateTimeList;
  final List<TemporalTimestamp> timestampList;
  final List<int> intList;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const TemporalTimeModel._internal(
      {@required this.id,
      this.date,
      this.time,
      this.dateTime,
      this.timestamp,
      this.dateList,
      this.timeList,
      this.dateTimeList,
      this.timestampList,
      this.intList});

  factory TemporalTimeModel(
      {String id,
      TemporalDate date,
      TemporalTime time,
      TemporalDateTime dateTime,
      TemporalTimestamp timestamp,
      List<TemporalDate> dateList,
      List<TemporalTime> timeList,
      List<TemporalDateTime> dateTimeList,
      List<TemporalTimestamp> timestampList,
      List<int> intList}) {
    return TemporalTimeModel._internal(
        id: id == null ? UUID.getUUID() : id,
        date: date,
        time: time,
        dateTime: dateTime,
        timestamp: timestamp,
        dateList: dateList != null ? List.unmodifiable(dateList) : dateList,
        timeList: timeList != null ? List.unmodifiable(timeList) : timeList,
        dateTimeList: dateTimeList != null
            ? List.unmodifiable(dateTimeList)
            : dateTimeList,
        timestampList: timestampList != null
            ? List.unmodifiable(timestampList)
            : timestampList,
        intList: intList != null ? List.unmodifiable(intList) : intList);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TemporalTimeModel &&
        id == other.id &&
        date == other.date &&
        time == other.time &&
        dateTime == other.dateTime &&
        timestamp == other.timestamp &&
        DeepCollectionEquality().equals(dateList, other.dateList) &&
        DeepCollectionEquality().equals(timeList, other.timeList) &&
        DeepCollectionEquality().equals(dateTimeList, other.dateTimeList) &&
        DeepCollectionEquality().equals(timestampList, other.timestampList) &&
        DeepCollectionEquality().equals(intList, other.intList);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"TemporalTimeModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"date=\\" + (date != null ? date.format() : \\"null\\") + \\", \\");
    buffer.write(\\"time=\\" + (time != null ? time.format() : \\"null\\") + \\", \\");
    buffer.write(
        \\"dateTime=\\" + (dateTime != null ? dateTime.format() : \\"null\\") + \\", \\");
    buffer.write(\\"timestamp=\\" +
        (timestamp != null ? timestamp.toString() : \\"null\\") +
        \\", \\");
    buffer.write(
        \\"dateList=\\" + (dateList != null ? dateList.toString() : \\"null\\") + \\", \\");
    buffer.write(
        \\"timeList=\\" + (timeList != null ? timeList.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"dateTimeList=\\" +
        (dateTimeList != null ? dateTimeList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"timestampList=\\" +
        (timestampList != null ? timestampList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"intList=\\" + (intList != null ? intList.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  TemporalTimeModel copyWith(
      {String id,
      TemporalDate date,
      TemporalTime time,
      TemporalDateTime dateTime,
      TemporalTimestamp timestamp,
      List<TemporalDate> dateList,
      List<TemporalTime> timeList,
      List<TemporalDateTime> dateTimeList,
      List<TemporalTimestamp> timestampList,
      List<int> intList}) {
    return TemporalTimeModel(
        id: id ?? this.id,
        date: date ?? this.date,
        time: time ?? this.time,
        dateTime: dateTime ?? this.dateTime,
        timestamp: timestamp ?? this.timestamp,
        dateList: dateList ?? this.dateList,
        timeList: timeList ?? this.timeList,
        dateTimeList: dateTimeList ?? this.dateTimeList,
        timestampList: timestampList ?? this.timestampList,
        intList: intList ?? this.intList);
  }

  TemporalTimeModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        date =
            json['date'] != null ? TemporalDate.fromString(json['date']) : null,
        time =
            json['time'] != null ? TemporalTime.fromString(json['time']) : null,
        dateTime = json['dateTime'] != null
            ? TemporalDateTime.fromString(json['dateTime'])
            : null,
        timestamp = json['timestamp'] != null
            ? TemporalTimestamp.fromSeconds(json['timestamp'])
            : null,
        dateList = (json['dateList'] as List)
            ?.map((e) => TemporalDate.fromString(e))
            ?.toList(),
        timeList = (json['timeList'] as List)
            ?.map((e) => TemporalTime.fromString(e))
            ?.toList(),
        dateTimeList = (json['dateTimeList'] as List)
            ?.map((e) => TemporalDateTime.fromString(e))
            ?.toList(),
        timestampList = (json['timestampList'] as List)
            ?.map((e) => TemporalTimestamp.fromSeconds(e))
            ?.toList(),
        intList = (json['intList'] as List<dynamic>)
            ?.map((dynamic e) => e is double ? e.toInt() : e as int)
            ?.toList();

  Map<String, dynamic> toJson() => {
        'id': id,
        'date': date?.format(),
        'time': time?.format(),
        'dateTime': dateTime?.format(),
        'timestamp': timestamp?.toSeconds(),
        'dateList': dateList?.map((e) => e.format()).toList(),
        'timeList': timeList?.map((e) => e.format()).toList(),
        'dateTimeList': dateTimeList?.map((e) => e.format()).toList(),
        'timestampList': timestampList?.map((e) => e.toSeconds()).toList(),
        'intList': intList
      };

  static final QueryField ID = QueryField(fieldName: \\"temporalTimeModel.id\\");
  static final QueryField DATE = QueryField(fieldName: \\"date\\");
  static final QueryField TIME = QueryField(fieldName: \\"time\\");
  static final QueryField DATETIME = QueryField(fieldName: \\"dateTime\\");
  static final QueryField TIMESTAMP = QueryField(fieldName: \\"timestamp\\");
  static final QueryField DATELIST = QueryField(fieldName: \\"dateList\\");
  static final QueryField TIMELIST = QueryField(fieldName: \\"timeList\\");
  static final QueryField DATETIMELIST = QueryField(fieldName: \\"dateTimeList\\");
  static final QueryField TIMESTAMPLIST =
      QueryField(fieldName: \\"timestampList\\");
  static final QueryField INTLIST = QueryField(fieldName: \\"intList\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TemporalTimeModel\\";
    modelSchemaDefinition.pluralName = \\"TemporalTimeModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.DATE,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.date)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.TIME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.time)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.DATETIME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.TIMESTAMP,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.timestamp)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.DATELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.date))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.TIMELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.time))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.DATETIMELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.dateTime))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.TIMESTAMPLIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.timestamp))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.INTLIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.int))));
  });
}

class _TemporalTimeModelModelType extends ModelType<TemporalTimeModel> {
  const _TemporalTimeModelModelType();

  @override
  TemporalTimeModel fromJson(Map<String, dynamic> jsonData) {
    return TemporalTimeModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Field tests should generate correct output for enum field w/o list or nullable 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the TestEnumModel type in your schema. */
@immutable
class TestEnumModel extends Model {
  static const classType = const _TestEnumModelModelType();
  final String id;
  final TestEnum enumVal;
  final TestEnum nullableEnumVal;
  final List<TestEnum> enumList;
  final List<TestEnum> enumNullableList;
  final List<TestEnum> nullableEnumList;
  final List<TestEnum> nullableEnumNullableList;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const TestEnumModel._internal(
      {@required this.id,
      @required this.enumVal,
      this.nullableEnumVal,
      @required this.enumList,
      this.enumNullableList,
      @required this.nullableEnumList,
      this.nullableEnumNullableList});

  factory TestEnumModel(
      {String id,
      @required TestEnum enumVal,
      TestEnum nullableEnumVal,
      @required List<TestEnum> enumList,
      List<TestEnum> enumNullableList,
      @required List<TestEnum> nullableEnumList,
      List<TestEnum> nullableEnumNullableList}) {
    return TestEnumModel._internal(
        id: id == null ? UUID.getUUID() : id,
        enumVal: enumVal,
        nullableEnumVal: nullableEnumVal,
        enumList: enumList != null ? List.unmodifiable(enumList) : enumList,
        enumNullableList: enumNullableList != null
            ? List.unmodifiable(enumNullableList)
            : enumNullableList,
        nullableEnumList: nullableEnumList != null
            ? List.unmodifiable(nullableEnumList)
            : nullableEnumList,
        nullableEnumNullableList: nullableEnumNullableList != null
            ? List.unmodifiable(nullableEnumNullableList)
            : nullableEnumNullableList);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestEnumModel &&
        id == other.id &&
        enumVal == other.enumVal &&
        nullableEnumVal == other.nullableEnumVal &&
        DeepCollectionEquality().equals(enumList, other.enumList) &&
        DeepCollectionEquality()
            .equals(enumNullableList, other.enumNullableList) &&
        DeepCollectionEquality()
            .equals(nullableEnumList, other.nullableEnumList) &&
        DeepCollectionEquality()
            .equals(nullableEnumNullableList, other.nullableEnumNullableList);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"TestEnumModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(
        \\"enumVal=\\" + (enumVal != null ? enumToString(enumVal) : \\"null\\") + \\", \\");
    buffer.write(\\"nullableEnumVal=\\" +
        (nullableEnumVal != null ? enumToString(nullableEnumVal) : \\"null\\") +
        \\", \\");
    buffer.write(
        \\"enumList=\\" + enumList?.map((e) => enumToString(e)).toString() + \\", \\");
    buffer.write(\\"enumNullableList=\\" +
        enumNullableList?.map((e) => enumToString(e)).toString() +
        \\", \\");
    buffer.write(\\"nullableEnumList=\\" +
        nullableEnumList?.map((e) => enumToString(e)).toString() +
        \\", \\");
    buffer.write(\\"nullableEnumNullableList=\\" +
        nullableEnumNullableList?.map((e) => enumToString(e)).toString());
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  TestEnumModel copyWith(
      {String id,
      TestEnum enumVal,
      TestEnum nullableEnumVal,
      List<TestEnum> enumList,
      List<TestEnum> enumNullableList,
      List<TestEnum> nullableEnumList,
      List<TestEnum> nullableEnumNullableList}) {
    return TestEnumModel(
        id: id ?? this.id,
        enumVal: enumVal ?? this.enumVal,
        nullableEnumVal: nullableEnumVal ?? this.nullableEnumVal,
        enumList: enumList ?? this.enumList,
        enumNullableList: enumNullableList ?? this.enumNullableList,
        nullableEnumList: nullableEnumList ?? this.nullableEnumList,
        nullableEnumNullableList:
            nullableEnumNullableList ?? this.nullableEnumNullableList);
  }

  TestEnumModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        enumVal = enumFromString<TestEnum>(json['enumVal'], TestEnum.values),
        nullableEnumVal =
            enumFromString<TestEnum>(json['nullableEnumVal'], TestEnum.values),
        enumList = json['enumList'] is List
            ? (json['enumList'] as List)
                .map((e) => enumFromString<TestEnum>(e, TestEnum.values))
                .toList()
            : null,
        enumNullableList = json['enumNullableList'] is List
            ? (json['enumNullableList'] as List)
                .map((e) => enumFromString<TestEnum>(e, TestEnum.values))
                .toList()
            : null,
        nullableEnumList = json['nullableEnumList'] is List
            ? (json['nullableEnumList'] as List)
                .map((e) => enumFromString<TestEnum>(e, TestEnum.values))
                .toList()
            : null,
        nullableEnumNullableList = json['nullableEnumNullableList'] is List
            ? (json['nullableEnumNullableList'] as List)
                .map((e) => enumFromString<TestEnum>(e, TestEnum.values))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'enumVal': enumToString(enumVal),
        'nullableEnumVal': enumToString(nullableEnumVal),
        'enumList': enumList?.map((e) => enumToString(e))?.toList(),
        'enumNullableList':
            enumNullableList?.map((e) => enumToString(e))?.toList(),
        'nullableEnumList':
            nullableEnumList?.map((e) => enumToString(e))?.toList(),
        'nullableEnumNullableList':
            nullableEnumNullableList?.map((e) => enumToString(e))?.toList()
      };

  static final QueryField ID = QueryField(fieldName: \\"testEnumModel.id\\");
  static final QueryField ENUMVAL = QueryField(fieldName: \\"enumVal\\");
  static final QueryField NULLABLEENUMVAL =
      QueryField(fieldName: \\"nullableEnumVal\\");
  static final QueryField ENUMLIST = QueryField(fieldName: \\"enumList\\");
  static final QueryField ENUMNULLABLELIST =
      QueryField(fieldName: \\"enumNullableList\\");
  static final QueryField NULLABLEENUMLIST =
      QueryField(fieldName: \\"nullableEnumList\\");
  static final QueryField NULLABLEENUMNULLABLELIST =
      QueryField(fieldName: \\"nullableEnumNullableList\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestEnumModel\\";
    modelSchemaDefinition.pluralName = \\"TestEnumModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.ENUMVAL,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.NULLABLEENUMVAL,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.ENUMLIST,
        isRequired: true,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.ENUMNULLABLELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.NULLABLEENUMLIST,
        isRequired: true,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.NULLABLEENUMNULLABLELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))));
  });
}

class _TestEnumModelModelType extends ModelType<TestEnumModel> {
  const _TestEnumModelModelType();

  @override
  TestEnumModel fromJson(Map<String, dynamic> jsonData) {
    return TestEnumModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Field tests should generate correct output for regular field w/o list or nullable 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the TestModel type in your schema. */
@immutable
class TestModel extends Model {
  static const classType = const _TestModelModelType();
  final String id;
  final double floatVal;
  final double floatNullableVal;
  final List<double> floatList;
  final List<double> floatNullableList;
  final List<double> nullableFloatList;
  final List<double> nullableFloatNullableList;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const TestModel._internal(
      {@required this.id,
      @required this.floatVal,
      this.floatNullableVal,
      @required this.floatList,
      this.floatNullableList,
      @required this.nullableFloatList,
      this.nullableFloatNullableList});

  factory TestModel(
      {String id,
      @required double floatVal,
      double floatNullableVal,
      @required List<double> floatList,
      List<double> floatNullableList,
      @required List<double> nullableFloatList,
      List<double> nullableFloatNullableList}) {
    return TestModel._internal(
        id: id == null ? UUID.getUUID() : id,
        floatVal: floatVal,
        floatNullableVal: floatNullableVal,
        floatList: floatList != null ? List.unmodifiable(floatList) : floatList,
        floatNullableList: floatNullableList != null
            ? List.unmodifiable(floatNullableList)
            : floatNullableList,
        nullableFloatList: nullableFloatList != null
            ? List.unmodifiable(nullableFloatList)
            : nullableFloatList,
        nullableFloatNullableList: nullableFloatNullableList != null
            ? List.unmodifiable(nullableFloatNullableList)
            : nullableFloatNullableList);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestModel &&
        id == other.id &&
        floatVal == other.floatVal &&
        floatNullableVal == other.floatNullableVal &&
        DeepCollectionEquality().equals(floatList, other.floatList) &&
        DeepCollectionEquality()
            .equals(floatNullableList, other.floatNullableList) &&
        DeepCollectionEquality()
            .equals(nullableFloatList, other.nullableFloatList) &&
        DeepCollectionEquality()
            .equals(nullableFloatNullableList, other.nullableFloatNullableList);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"TestModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(
        \\"floatVal=\\" + (floatVal != null ? floatVal.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableVal=\\" +
        (floatNullableVal != null ? floatNullableVal.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"floatList=\\" +
        (floatList != null ? floatList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"floatNullableList=\\" +
        (floatNullableList != null ? floatNullableList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"nullableFloatList=\\" +
        (nullableFloatList != null ? nullableFloatList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"nullableFloatNullableList=\\" +
        (nullableFloatNullableList != null
            ? nullableFloatNullableList.toString()
            : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  TestModel copyWith(
      {String id,
      double floatVal,
      double floatNullableVal,
      List<double> floatList,
      List<double> floatNullableList,
      List<double> nullableFloatList,
      List<double> nullableFloatNullableList}) {
    return TestModel(
        id: id ?? this.id,
        floatVal: floatVal ?? this.floatVal,
        floatNullableVal: floatNullableVal ?? this.floatNullableVal,
        floatList: floatList ?? this.floatList,
        floatNullableList: floatNullableList ?? this.floatNullableList,
        nullableFloatList: nullableFloatList ?? this.nullableFloatList,
        nullableFloatNullableList:
            nullableFloatNullableList ?? this.nullableFloatNullableList);
  }

  TestModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        floatVal = json['floatVal'],
        floatNullableVal = json['floatNullableVal'],
        floatList = json['floatList']?.cast<double>(),
        floatNullableList = json['floatNullableList']?.cast<double>(),
        nullableFloatList = json['nullableFloatList']?.cast<double>(),
        nullableFloatNullableList =
            json['nullableFloatNullableList']?.cast<double>();

  Map<String, dynamic> toJson() => {
        'id': id,
        'floatVal': floatVal,
        'floatNullableVal': floatNullableVal,
        'floatList': floatList,
        'floatNullableList': floatNullableList,
        'nullableFloatList': nullableFloatList,
        'nullableFloatNullableList': nullableFloatNullableList
      };

  static final QueryField ID = QueryField(fieldName: \\"testModel.id\\");
  static final QueryField FLOATVAL = QueryField(fieldName: \\"floatVal\\");
  static final QueryField FLOATNULLABLEVAL =
      QueryField(fieldName: \\"floatNullableVal\\");
  static final QueryField FLOATLIST = QueryField(fieldName: \\"floatList\\");
  static final QueryField FLOATNULLABLELIST =
      QueryField(fieldName: \\"floatNullableList\\");
  static final QueryField NULLABLEFLOATLIST =
      QueryField(fieldName: \\"nullableFloatList\\");
  static final QueryField NULLABLEFLOATNULLABLELIST =
      QueryField(fieldName: \\"nullableFloatNullableList\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestModel\\";
    modelSchemaDefinition.pluralName = \\"TestModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.FLOATVAL,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.double)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.FLOATNULLABLEVAL,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.double)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.FLOATLIST,
        isRequired: true,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.double))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.FLOATNULLABLELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.double))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.NULLABLEFLOATLIST,
        isRequired: true,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.double))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.NULLABLEFLOATNULLABLELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.double))));
  });
}

class _TestModelModelType extends ModelType<TestModel> {
  const _TestModelModelType();

  @override
  TestModel fromJson(Map<String, dynamic> jsonData) {
    return TestModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model Directive should generate a class for a Simple Model 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const SimpleModel._internal({@required this.id, this.name, this.bar});

  factory SimpleModel({String id, String name, String bar}) {
    return SimpleModel._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  SimpleModel copyWith({String id, String name, String bar}) {
    return SimpleModel(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  SimpleModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"simpleModel.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();

  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model Directive should generate a class for a model with all optional fields except id field 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const SimpleModel._internal({@required this.id, this.name, this.bar});

  factory SimpleModel({String id, String name, String bar}) {
    return SimpleModel._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  SimpleModel copyWith({String id, String name, String bar}) {
    return SimpleModel(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  SimpleModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"simpleModel.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();

  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with custom claims 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the customClaim type in your schema. */
@immutable
class customClaim extends Model {
  static const classType = const _customClaimModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const customClaim._internal({@required this.id, this.name, this.bar});

  factory customClaim({String id, String name, String bar}) {
    return customClaim._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is customClaim &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"customClaim {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  customClaim copyWith({String id, String name, String bar}) {
    return customClaim(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  customClaim.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"customClaim.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"customClaim\\";
    modelSchemaDefinition.pluralName = \\"customClaims\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"owner\\",
          identityClaim: \\"user_id\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: customClaim.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: customClaim.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _customClaimModelType extends ModelType<customClaim> {
  const _customClaimModelType();

  @override
  customClaim fromJson(Map<String, dynamic> jsonData) {
    return customClaim.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with custom group claims 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the customClaim type in your schema. */
@immutable
class customClaim extends Model {
  static const classType = const _customClaimModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const customClaim._internal({@required this.id, this.name, this.bar});

  factory customClaim({String id, String name, String bar}) {
    return customClaim._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is customClaim &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"customClaim {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  customClaim copyWith({String id, String name, String bar}) {
    return customClaim(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  customClaim.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"customClaim.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"customClaim\\";
    modelSchemaDefinition.pluralName = \\"customClaims\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.GROUPS,
          groupClaim: \\"user_groups\\",
          groups: [
            \\"Moderator\\"
          ],
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: customClaim.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: customClaim.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _customClaimModelType extends ModelType<customClaim> {
  const _customClaimModelType();

  @override
  customClaim fromJson(Map<String, dynamic> jsonData) {
    return customClaim.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with dynamic groups 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the dynamicGroups type in your schema. */
@immutable
class dynamicGroups extends Model {
  static const classType = const _dynamicGroupsModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const dynamicGroups._internal({@required this.id, this.name, this.bar});

  factory dynamicGroups({String id, String name, String bar}) {
    return dynamicGroups._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is dynamicGroups &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"dynamicGroups {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  dynamicGroups copyWith({String id, String name, String bar}) {
    return dynamicGroups(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  dynamicGroups.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"dynamicGroups.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"dynamicGroups\\";
    modelSchemaDefinition.pluralName = \\"dynamicGroups\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.GROUPS,
          groupClaim: \\"cognito:groups\\",
          groupsField: \\"groups\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: dynamicGroups.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: dynamicGroups.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _dynamicGroupsModelType extends ModelType<dynamicGroups> {
  const _dynamicGroupsModelType();

  @override
  dynamicGroups fromJson(Map<String, dynamic> jsonData) {
    return dynamicGroups.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with owner auth 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the simpleOwnerAuth type in your schema. */
@immutable
class simpleOwnerAuth extends Model {
  static const classType = const _simpleOwnerAuthModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const simpleOwnerAuth._internal({@required this.id, this.name, this.bar});

  factory simpleOwnerAuth({String id, String name, String bar}) {
    return simpleOwnerAuth._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is simpleOwnerAuth &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"simpleOwnerAuth {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  simpleOwnerAuth copyWith({String id, String name, String bar}) {
    return simpleOwnerAuth(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  simpleOwnerAuth.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"simpleOwnerAuth.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"simpleOwnerAuth\\";
    modelSchemaDefinition.pluralName = \\"simpleOwnerAuths\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"owner\\",
          identityClaim: \\"cognito:username\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: simpleOwnerAuth.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: simpleOwnerAuth.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _simpleOwnerAuthModelType extends ModelType<simpleOwnerAuth> {
  const _simpleOwnerAuthModelType();

  @override
  simpleOwnerAuth fromJson(Map<String, dynamic> jsonData) {
    return simpleOwnerAuth.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with owner auth allowing others to read: 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the allowRead type in your schema. */
@immutable
class allowRead extends Model {
  static const classType = const _allowReadModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const allowRead._internal({@required this.id, this.name, this.bar});

  factory allowRead({String id, String name, String bar}) {
    return allowRead._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is allowRead &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"allowRead {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  allowRead copyWith({String id, String name, String bar}) {
    return allowRead(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  allowRead.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"allowRead.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"allowRead\\";
    modelSchemaDefinition.pluralName = \\"allowReads\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"owner\\",
          identityClaim: \\"cognito:username\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.DELETE,
            ModelOperation.UPDATE
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: allowRead.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: allowRead.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _allowReadModelType extends ModelType<allowRead> {
  const _allowReadModelType();

  @override
  allowRead fromJson(Map<String, dynamic> jsonData) {
    return allowRead.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with private authorization 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the privateType type in your schema. */
@immutable
class privateType extends Model {
  static const classType = const _privateTypeModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const privateType._internal({@required this.id, this.name, this.bar});

  factory privateType({String id, String name, String bar}) {
    return privateType._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is privateType &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"privateType {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  privateType copyWith({String id, String name, String bar}) {
    return privateType(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  privateType.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"privateType.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"privateType\\";
    modelSchemaDefinition.pluralName = \\"privateTypes\\";

    modelSchemaDefinition.authRules = [
      AuthRule(authStrategy: AuthStrategy.PRIVATE, operations: [
        ModelOperation.CREATE,
        ModelOperation.UPDATE,
        ModelOperation.DELETE,
        ModelOperation.READ
      ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: privateType.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: privateType.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _privateTypeModelType extends ModelType<privateType> {
  const _privateTypeModelType();

  @override
  privateType fromJson(Map<String, dynamic> jsonData) {
    return privateType.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with public authorization 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the publicType type in your schema. */
@immutable
class publicType extends Model {
  static const classType = const _publicTypeModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const publicType._internal({@required this.id, this.name, this.bar});

  factory publicType({String id, String name, String bar}) {
    return publicType._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is publicType &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"publicType {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  publicType copyWith({String id, String name, String bar}) {
    return publicType(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  publicType.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"publicType.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"publicType\\";
    modelSchemaDefinition.pluralName = \\"publicTypes\\";

    modelSchemaDefinition.authRules = [
      AuthRule(authStrategy: AuthStrategy.PUBLIC, operations: [
        ModelOperation.CREATE,
        ModelOperation.UPDATE,
        ModelOperation.DELETE,
        ModelOperation.READ
      ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: publicType.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: publicType.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _publicTypeModelType extends ModelType<publicType> {
  const _publicTypeModelType();

  @override
  publicType fromJson(Map<String, dynamic> jsonData) {
    return publicType.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with static groups 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the staticGroups type in your schema. */
@immutable
class staticGroups extends Model {
  static const classType = const _staticGroupsModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const staticGroups._internal({@required this.id, this.name, this.bar});

  factory staticGroups({String id, String name, String bar}) {
    return staticGroups._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is staticGroups &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"staticGroups {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  staticGroups copyWith({String id, String name, String bar}) {
    return staticGroups(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  staticGroups.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"staticGroups.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"staticGroups\\";
    modelSchemaDefinition.pluralName = \\"staticGroups\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.GROUPS,
          groupClaim: \\"cognito:groups\\",
          groups: [
            \\"Admin\\"
          ],
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: staticGroups.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: staticGroups.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _staticGroupsModelType extends ModelType<staticGroups> {
  const _staticGroupsModelType();

  @override
  staticGroups fromJson(Map<String, dynamic> jsonData) {
    return staticGroups.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should include authRules in schema when owner auth is used with ownerField 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String title;
  final String author;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Post._internal(
      {@required this.id, @required this.title, @required this.author});

  factory Post({String id, @required String title, @required String author}) {
    return Post._internal(
        id: id == null ? UUID.getUUID() : id, title: title, author: author);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
        id == other.id &&
        title == other.title &&
        author == other.author;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$title\\" + \\", \\");
    buffer.write(\\"author=\\" + \\"$author\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Post copyWith({String id, String title, String author}) {
    return Post(
        id: id ?? this.id,
        title: title ?? this.title,
        author: author ?? this.author);
  }

  Post.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        title = json['title'],
        author = json['author'];

  Map<String, dynamic> toJson() => {'id': id, 'title': title, 'author': author};

  static final QueryField ID = QueryField(fieldName: \\"post.id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField AUTHOR = QueryField(fieldName: \\"author\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"author\\",
          identityClaim: \\"cognito:username\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.TITLE,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.AUTHOR,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();

  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should support multiple auth rules 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String title;
  final String owner;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Post._internal(
      {@required this.id, @required this.title, @required this.owner});

  factory Post({String id, @required String title, @required String owner}) {
    return Post._internal(
        id: id == null ? UUID.getUUID() : id, title: title, owner: owner);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
        id == other.id &&
        title == other.title &&
        owner == other.owner;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$title\\" + \\", \\");
    buffer.write(\\"owner=\\" + \\"$owner\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Post copyWith({String id, String title, String owner}) {
    return Post(
        id: id ?? this.id,
        title: title ?? this.title,
        owner: owner ?? this.owner);
  }

  Post.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        title = json['title'],
        owner = json['owner'];

  Map<String, dynamic> toJson() => {'id': id, 'title': title, 'owner': owner};

  static final QueryField ID = QueryField(fieldName: \\"post.id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField OWNER = QueryField(fieldName: \\"owner\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.GROUPS,
          groupClaim: \\"cognito:groups\\",
          groups: [
            \\"admin\\"
          ],
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ]),
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"owner\\",
          identityClaim: \\"cognito:username\\",
          operations: [ModelOperation.CREATE, ModelOperation.UPDATE]),
      AuthRule(authStrategy: AuthStrategy.PUBLIC, operations: [
        ModelOperation.CREATE,
        ModelOperation.UPDATE,
        ModelOperation.DELETE,
        ModelOperation.READ
      ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.TITLE,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.OWNER,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();

  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should generate classes for models with one to many connection 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Todo type in your schema. */
@immutable
class Todo extends Model {
  static const classType = const _TodoModelType();
  final String id;
  final List<Task> tasks;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Todo._internal({@required this.id, this.tasks});

  factory Todo({String id, List<Task> tasks}) {
    return Todo._internal(
        id: id == null ? UUID.getUUID() : id,
        tasks: tasks != null ? List.unmodifiable(tasks) : tasks);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Todo &&
        id == other.id &&
        DeepCollectionEquality().equals(tasks, other.tasks);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Todo {\\");
    buffer.write(\\"id=\\" + \\"$id\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Todo copyWith({String id, List<Task> tasks}) {
    return Todo(id: id ?? this.id, tasks: tasks ?? this.tasks);
  }

  Todo.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        tasks = json['tasks'] is List
            ? (json['tasks'] as List)
                .map((e) => Task.fromJson(new Map<String, dynamic>.from(e)))
                .toList()
            : null;

  Map<String, dynamic> toJson() =>
      {'id': id, 'tasks': tasks?.map((e) => e?.toJson())?.toList()};

  static final QueryField ID = QueryField(fieldName: \\"todo.id\\");
  static final QueryField TASKS = QueryField(
      fieldName: \\"tasks\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Task).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Todo\\";
    modelSchemaDefinition.pluralName = \\"Todos\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
        key: Todo.TASKS,
        isRequired: false,
        ofModelName: (Task).toString(),
        associatedKey: Task.TODO));
  });
}

class _TodoModelType extends ModelType<Todo> {
  const _TodoModelType();

  @override
  Todo fromJson(Map<String, dynamic> jsonData) {
    return Todo.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should generate classes for models with one to many connection 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Task type in your schema. */
@immutable
class Task extends Model {
  static const classType = const _TaskModelType();
  final String id;
  final Todo todo;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Task._internal({@required this.id, this.todo});

  factory Task({String id, Todo todo}) {
    return Task._internal(id: id == null ? UUID.getUUID() : id, todo: todo);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Task && id == other.id && todo == other.todo;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Task {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"todo=\\" + (todo != null ? todo.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Task copyWith({String id, Todo todo}) {
    return Task(id: id ?? this.id, todo: todo ?? this.todo);
  }

  Task.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        todo = json['todo'] != null
            ? Todo.fromJson(new Map<String, dynamic>.from(json['todo']))
            : null;

  Map<String, dynamic> toJson() => {'id': id, 'todo': todo?.toJson()};

  static final QueryField ID = QueryField(fieldName: \\"task.id\\");
  static final QueryField TODO = QueryField(
      fieldName: \\"todo\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Todo).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Task\\";
    modelSchemaDefinition.pluralName = \\"Tasks\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
        key: Task.TODO,
        isRequired: false,
        targetName: \\"taskTodoId\\",
        ofModelName: (Todo).toString()));
  });
}

class _TaskModelType extends ModelType<Task> {
  const _TaskModelType();

  @override
  Task fromJson(Map<String, dynamic> jsonData) {
    return Task.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should support connection directive with keyName and fields 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Blog type in your schema. */
@immutable
class Blog extends Model {
  static const classType = const _BlogModelType();
  final String id;
  final String name;
  final List<Post> posts;
  final List<String> test;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Blog._internal(
      {@required this.id, @required this.name, this.posts, this.test});

  factory Blog(
      {String id, @required String name, List<Post> posts, List<String> test}) {
    return Blog._internal(
        id: id == null ? UUID.getUUID() : id,
        name: name,
        posts: posts != null ? List.unmodifiable(posts) : posts,
        test: test != null ? List.unmodifiable(test) : test);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Blog &&
        id == other.id &&
        name == other.name &&
        DeepCollectionEquality().equals(posts, other.posts) &&
        DeepCollectionEquality().equals(test, other.test);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Blog {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"test=\\" + (test != null ? test.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Blog copyWith({String id, String name, List<Post> posts, List<String> test}) {
    return Blog(
        id: id ?? this.id,
        name: name ?? this.name,
        posts: posts ?? this.posts,
        test: test ?? this.test);
  }

  Blog.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        posts = json['posts'] is List
            ? (json['posts'] as List)
                .map((e) => Post.fromJson(new Map<String, dynamic>.from(e)))
                .toList()
            : null,
        test = json['test']?.cast<String>();

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'posts': posts?.map((e) => e?.toJson())?.toList(),
        'test': test
      };

  static final QueryField ID = QueryField(fieldName: \\"blog.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField POSTS = QueryField(
      fieldName: \\"posts\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Post).toString()));
  static final QueryField TEST = QueryField(fieldName: \\"test\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Blog\\";
    modelSchemaDefinition.pluralName = \\"Blogs\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Blog.NAME,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
        key: Blog.POSTS,
        isRequired: false,
        ofModelName: (Post).toString(),
        associatedKey: Post.BLOG));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Blog.TEST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.string))));
  });
}

class _BlogModelType extends ModelType<Blog> {
  const _BlogModelType();

  @override
  Blog fromJson(Map<String, dynamic> jsonData) {
    return Blog.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should support connection directive with keyName and fields 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final Post post;
  final String content;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Comment._internal(
      {@required this.id, this.post, @required this.content});

  factory Comment({String id, Post post, @required String content}) {
    return Comment._internal(
        id: id == null ? UUID.getUUID() : id, post: post, content: content);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
        id == other.id &&
        post == other.post &&
        content == other.content;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (post != null ? post.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"content=\\" + \\"$content\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Comment copyWith({String id, Post post, String content}) {
    return Comment(
        id: id ?? this.id,
        post: post ?? this.post,
        content: content ?? this.content);
  }

  Comment.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        post = json['post'] != null
            ? Post.fromJson(new Map<String, dynamic>.from(json['post']))
            : null,
        content = json['content'];

  Map<String, dynamic> toJson() =>
      {'id': id, 'post': post?.toJson(), 'content': content};

  static final QueryField ID = QueryField(fieldName: \\"comment.id\\");
  static final QueryField POST = QueryField(
      fieldName: \\"post\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Post).toString()));
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
        key: Comment.POST,
        isRequired: false,
        targetName: \\"postID\\",
        ofModelName: (Post).toString()));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Comment.CONTENT,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();

  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should support connection directive with keyName and fields 3`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String title;
  final Blog blog;
  final List<Comment> comments;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Post._internal(
      {@required this.id, @required this.title, this.blog, this.comments});

  factory Post(
      {String id, @required String title, Blog blog, List<Comment> comments}) {
    return Post._internal(
        id: id == null ? UUID.getUUID() : id,
        title: title,
        blog: blog,
        comments: comments != null ? List.unmodifiable(comments) : comments);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
        id == other.id &&
        title == other.title &&
        blog == other.blog &&
        DeepCollectionEquality().equals(comments, other.comments);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$title\\" + \\", \\");
    buffer.write(\\"blog=\\" + (blog != null ? blog.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Post copyWith({String id, String title, Blog blog, List<Comment> comments}) {
    return Post(
        id: id ?? this.id,
        title: title ?? this.title,
        blog: blog ?? this.blog,
        comments: comments ?? this.comments);
  }

  Post.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        title = json['title'],
        blog = json['blog'] != null
            ? Blog.fromJson(new Map<String, dynamic>.from(json['blog']))
            : null,
        comments = json['comments'] is List
            ? (json['comments'] as List)
                .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e)))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'blog': blog?.toJson(),
        'comments': comments?.map((e) => e?.toJson())?.toList()
      };

  static final QueryField ID = QueryField(fieldName: \\"post.id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField BLOG = QueryField(
      fieldName: \\"blog\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Blog).toString()));
  static final QueryField COMMENTS = QueryField(
      fieldName: \\"comments\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Comment).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.TITLE,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
        key: Post.BLOG,
        isRequired: false,
        targetName: \\"blogID\\",
        ofModelName: (Blog).toString()));

    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
        key: Post.COMMENTS,
        isRequired: false,
        ofModelName: (Comment).toString(),
        associatedKey: Comment.POST));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();

  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Key Directive should generate a class for model with key directive 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the authorBook type in your schema. */
@immutable
class authorBook extends Model {
  static const classType = const _authorBookModelType();
  final String id;
  final String author_id;
  final String book_id;
  final String author;
  final String book;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const authorBook._internal(
      {@required this.id,
      @required this.author_id,
      @required this.book_id,
      this.author,
      this.book});

  factory authorBook(
      {String id,
      @required String author_id,
      @required String book_id,
      String author,
      String book}) {
    return authorBook._internal(
        id: id == null ? UUID.getUUID() : id,
        author_id: author_id,
        book_id: book_id,
        author: author,
        book: book);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is authorBook &&
        id == other.id &&
        author_id == other.author_id &&
        book_id == other.book_id &&
        author == other.author &&
        book == other.book;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"authorBook {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"author_id=\\" + \\"$author_id\\" + \\", \\");
    buffer.write(\\"book_id=\\" + \\"$book_id\\" + \\", \\");
    buffer.write(\\"author=\\" + \\"$author\\" + \\", \\");
    buffer.write(\\"book=\\" + \\"$book\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  authorBook copyWith(
      {String id,
      String author_id,
      String book_id,
      String author,
      String book}) {
    return authorBook(
        id: id ?? this.id,
        author_id: author_id ?? this.author_id,
        book_id: book_id ?? this.book_id,
        author: author ?? this.author,
        book: book ?? this.book);
  }

  authorBook.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        author_id = json['author_id'],
        book_id = json['book_id'],
        author = json['author'],
        book = json['book'];

  Map<String, dynamic> toJson() => {
        'id': id,
        'author_id': author_id,
        'book_id': book_id,
        'author': author,
        'book': book
      };

  static final QueryField ID = QueryField(fieldName: \\"authorBook.id\\");
  static final QueryField AUTHOR_ID = QueryField(fieldName: \\"author_id\\");
  static final QueryField BOOK_ID = QueryField(fieldName: \\"book_id\\");
  static final QueryField AUTHOR = QueryField(fieldName: \\"author\\");
  static final QueryField BOOK = QueryField(fieldName: \\"book\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"authorBook\\";
    modelSchemaDefinition.pluralName = \\"authorBooks\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: authorBook.AUTHOR_ID,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: authorBook.BOOK_ID,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: authorBook.AUTHOR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: authorBook.BOOK,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _authorBookModelType extends ModelType<authorBook> {
  const _authorBookModelType();

  @override
  authorBook fromJson(Map<String, dynamic> jsonData) {
    return authorBook.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct model files if the null safety is enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Blog type in your schema. */
@immutable
class Blog extends Model {
  static const classType = const _BlogModelType();
  final String id;
  final String? _name;
  final List<Post>? _posts;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  String get name {
    return _name!;
  }

  List<Post>? get posts {
    return _posts;
  }

  const Blog._internal({required this.id, required name, posts})
      : _name = name,
        _posts = posts;

  factory Blog({String? id, required String name, List<Post>? posts}) {
    return Blog._internal(
        id: id == null ? UUID.getUUID() : id,
        name: name,
        posts: posts != null ? List.unmodifiable(posts) : posts);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Blog &&
        id == other.id &&
        _name == other._name &&
        DeepCollectionEquality().equals(_posts, other._posts);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Blog {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Blog copyWith({String? id, String? name, List<Post>? posts}) {
    return Blog(
        id: id ?? this.id, name: name ?? this.name, posts: posts ?? this.posts);
  }

  Blog.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        _name = json['name'],
        _posts = json['posts'] is List
            ? (json['posts'] as List)
                .map((e) => Post.fromJson(
                    new Map<String, dynamic>.from(e['serializedData'])))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': _name,
        'posts': _posts?.map((e) => e?.toJson())?.toList()
      };

  static final QueryField ID = QueryField(fieldName: \\"blog.id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField POSTS = QueryField(
      fieldName: \\"posts\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Post).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Blog\\";
    modelSchemaDefinition.pluralName = \\"Blogs\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Blog.NAME,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
        key: Blog.POSTS,
        isRequired: false,
        ofModelName: (Post).toString(),
        associatedKey: Post.BLOG));
  });
}

class _BlogModelType extends ModelType<Blog> {
  const _BlogModelType();

  @override
  Blog fromJson(Map<String, dynamic> jsonData) {
    return Blog.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct model files if the null safety is enabled 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final Post? _post;
  final String? _content;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  Post? get post {
    return _post;
  }

  String get content {
    return _content!;
  }

  const Comment._internal({required this.id, post, required content})
      : _post = post,
        _content = content;

  factory Comment({String? id, Post? post, required String content}) {
    return Comment._internal(
        id: id == null ? UUID.getUUID() : id, post: post, content: content);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
        id == other.id &&
        _post == other._post &&
        _content == other._content;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (_post != null ? _post!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Comment copyWith({String? id, Post? post, String? content}) {
    return Comment(
        id: id ?? this.id,
        post: post ?? this.post,
        content: content ?? this.content);
  }

  Comment.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        _post = json['post'] != null
            ? Post.fromJson(
                new Map<String, dynamic>.from(json['post']['serializedData']))
            : null,
        _content = json['content'];

  Map<String, dynamic> toJson() =>
      {'id': id, 'post': _post?.toJson(), 'content': _content};

  static final QueryField ID = QueryField(fieldName: \\"comment.id\\");
  static final QueryField POST = QueryField(
      fieldName: \\"post\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Post).toString()));
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
        key: Comment.POST,
        isRequired: false,
        targetName: \\"postID\\",
        ofModelName: (Post).toString()));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Comment.CONTENT,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();

  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct model files if the null safety is enabled 3`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// ignore_for_file: public_member_api_docs

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final Blog? _blog;
  final List<Comment>? _comments;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  String get title {
    return _title!;
  }

  Blog? get blog {
    return _blog;
  }

  List<Comment>? get comments {
    return _comments;
  }

  const Post._internal({required this.id, required title, blog, comments})
      : _title = title,
        _blog = blog,
        _comments = comments;

  factory Post(
      {String? id,
      required String title,
      Blog? blog,
      List<Comment>? comments}) {
    return Post._internal(
        id: id == null ? UUID.getUUID() : id,
        title: title,
        blog: blog,
        comments: comments != null ? List.unmodifiable(comments) : comments);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
        id == other.id &&
        _title == other._title &&
        _blog == other._blog &&
        DeepCollectionEquality().equals(_comments, other._comments);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"blog=\\" + (_blog != null ? _blog!.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Post copyWith(
      {String? id, String? title, Blog? blog, List<Comment>? comments}) {
    return Post(
        id: id ?? this.id,
        title: title ?? this.title,
        blog: blog ?? this.blog,
        comments: comments ?? this.comments);
  }

  Post.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        _title = json['title'],
        _blog = json['blog'] != null
            ? Blog.fromJson(
                new Map<String, dynamic>.from(json['blog']['serializedData']))
            : null,
        _comments = json['comments'] is List
            ? (json['comments'] as List)
                .map((e) => Comment.fromJson(
                    new Map<String, dynamic>.from(e['serializedData'])))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': _title,
        'blog': _blog?.toJson(),
        'comments': _comments?.map((e) => e?.toJson())?.toList()
      };

  static final QueryField ID = QueryField(fieldName: \\"post.id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField BLOG = QueryField(
      fieldName: \\"blog\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Blog).toString()));
  static final QueryField COMMENTS = QueryField(
      fieldName: \\"comments\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Comment).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.TITLE,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
        key: Post.BLOG,
        isRequired: false,
        targetName: \\"blogID\\",
        ofModelName: (Blog).toString()));

    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
        key: Post.COMMENTS,
        isRequired: false,
        ofModelName: (Comment).toString(),
        associatedKey: Comment.POST));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();

  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}
"
`;
