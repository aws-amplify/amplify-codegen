// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AppSync Dart Visitor Amplify Core dependency used in imports Should use the amplify_core dependency if dartUpdateAmplifyCoreDependency is true 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_core/amplify_core.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final int? _rating;
  final PostStatus? _status;
  final List<Comment>? _comments;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new AmplifyCodeGenModelException(
          AmplifyExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            AmplifyExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  int get rating {
    try {
      return _rating!;
    } catch(e) {
      throw new AmplifyCodeGenModelException(
          AmplifyExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            AmplifyExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  PostStatus get status {
    try {
      return _status!;
    } catch(e) {
      throw new AmplifyCodeGenModelException(
          AmplifyExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            AmplifyExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Comment>? get comments {
    return _comments;
  }
  
  const Post._internal({required this.id, required title, required rating, required status, comments}): _title = title, _rating = rating, _status = status, _comments = comments;
  
  factory Post({String? id, required String title, required int rating, required PostStatus status, List<Comment>? comments}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      rating: rating,
      status: status,
      comments: comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      _rating == other._rating &&
      _status == other._status &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"rating=\\" + (_rating != null ? _rating!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"status=\\" + (_status != null ? enumToString(_status)! : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, int? rating, PostStatus? status, List<Comment>? comments}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      rating: rating ?? this.rating,
      status: status ?? this.status,
      comments: comments ?? this.comments);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _rating = (json['rating'] as num?)?.toInt(),
      _status = enumFromString<PostStatus>(json['status'], PostStatus.values),
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'rating': _rating, 'status': enumToString(_status), 'comments': _comments?.map((Comment? e) => e?.toJson()).toList()
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField RATING = QueryField(fieldName: \\"rating\\");
  static final QueryField STATUS = QueryField(fieldName: \\"status\\");
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Comment).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.RATING,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.STATUS,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.COMMENTS,
      isRequired: false,
      ofModelName: (Comment).toString(),
      associatedKey: Comment.POST
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}

/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final Post? _post;
  final String? _content;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  Post get post {
    try {
      return _post!;
    } catch(e) {
      throw new AmplifyCodeGenModelException(
          AmplifyExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            AmplifyExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get content {
    try {
      return _content!;
    } catch(e) {
      throw new AmplifyCodeGenModelException(
          AmplifyExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            AmplifyExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Comment._internal({required this.id, required post, required content}): _post = post, _content = content;
  
  factory Comment({String? id, required Post post, required String content}) {
    return Comment._internal(
      id: id == null ? UUID.getUUID() : id,
      post: post,
      content: content);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
      id == other.id &&
      _post == other._post &&
      _content == other._content;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (_post != null ? _post!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment copyWith({String? id, Post? post, String? content}) {
    return Comment(
      id: id ?? this.id,
      post: post ?? this.post,
      content: content ?? this.content);
  }
  
  Comment.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _post = json['post']?['serializedData'] != null
        ? Post.fromJson(new Map<String, dynamic>.from(json['post']['serializedData']))
        : null,
      _content = json['content'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'post': _post?.toJson(), 'content': _content
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField POST = QueryField(
    fieldName: \\"post\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Post).toString()));
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"postID\\", \\"content\\"], name: \\"byPost\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Comment.POST,
      isRequired: true,
      targetName: \\"postID\\",
      ofModelName: (Post).toString()
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.CONTENT,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();
  
  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Amplify Core dependency used in imports Should use the older flutter datastore interface dependency if dartUpdateAmplifyCoreDependency is false 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final int? _rating;
  final PostStatus? _status;
  final List<Comment>? _comments;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  int get rating {
    try {
      return _rating!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  PostStatus get status {
    try {
      return _status!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Comment>? get comments {
    return _comments;
  }
  
  const Post._internal({required this.id, required title, required rating, required status, comments}): _title = title, _rating = rating, _status = status, _comments = comments;
  
  factory Post({String? id, required String title, required int rating, required PostStatus status, List<Comment>? comments}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      rating: rating,
      status: status,
      comments: comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      _rating == other._rating &&
      _status == other._status &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"rating=\\" + (_rating != null ? _rating!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"status=\\" + (_status != null ? enumToString(_status)! : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, int? rating, PostStatus? status, List<Comment>? comments}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      rating: rating ?? this.rating,
      status: status ?? this.status,
      comments: comments ?? this.comments);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _rating = (json['rating'] as num?)?.toInt(),
      _status = enumFromString<PostStatus>(json['status'], PostStatus.values),
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'rating': _rating, 'status': enumToString(_status), 'comments': _comments?.map((Comment? e) => e?.toJson()).toList()
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField RATING = QueryField(fieldName: \\"rating\\");
  static final QueryField STATUS = QueryField(fieldName: \\"status\\");
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Comment).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.RATING,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.STATUS,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.COMMENTS,
      isRequired: false,
      ofModelName: (Comment).toString(),
      associatedKey: Comment.POST
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}

/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final Post? _post;
  final String? _content;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  Post get post {
    try {
      return _post!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get content {
    try {
      return _content!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Comment._internal({required this.id, required post, required content}): _post = post, _content = content;
  
  factory Comment({String? id, required Post post, required String content}) {
    return Comment._internal(
      id: id == null ? UUID.getUUID() : id,
      post: post,
      content: content);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
      id == other.id &&
      _post == other._post &&
      _content == other._content;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (_post != null ? _post!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment copyWith({String? id, Post? post, String? content}) {
    return Comment(
      id: id ?? this.id,
      post: post ?? this.post,
      content: content ?? this.content);
  }
  
  Comment.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _post = json['post']?['serializedData'] != null
        ? Post.fromJson(new Map<String, dynamic>.from(json['post']['serializedData']))
        : null,
      _content = json['content'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'post': _post?.toJson(), 'content': _content
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField POST = QueryField(
    fieldName: \\"post\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Post).toString()));
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"postID\\", \\"content\\"], name: \\"byPost\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Comment.POST,
      isRequired: true,
      targetName: \\"postID\\",
      ofModelName: (Post).toString()
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.CONTENT,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();
  
  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for Address with nullsafety disabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Address type in your schema. */
@immutable
class Address {
  final String line1;
  final String line2;
  final String city;
  final String state;
  final String postalCode;

  const Address._internal(
      {@required this.line1,
      this.line2,
      @required this.city,
      @required this.state,
      @required this.postalCode});

  factory Address(
      {@required String line1,
      String line2,
      @required String city,
      @required String state,
      @required String postalCode}) {
    return Address._internal(
        line1: line1,
        line2: line2,
        city: city,
        state: state,
        postalCode: postalCode);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Address &&
        line1 == other.line1 &&
        line2 == other.line2 &&
        city == other.city &&
        state == other.state &&
        postalCode == other.postalCode;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Address {\\");
    buffer.write(\\"line1=\\" + \\"$line1\\" + \\", \\");
    buffer.write(\\"line2=\\" + \\"$line2\\" + \\", \\");
    buffer.write(\\"city=\\" + \\"$city\\" + \\", \\");
    buffer.write(\\"state=\\" + \\"$state\\" + \\", \\");
    buffer.write(\\"postalCode=\\" + \\"$postalCode\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Address copyWith(
      {String line1,
      String line2,
      String city,
      String state,
      String postalCode}) {
    return Address(
        line1: line1 ?? this.line1,
        line2: line2 ?? this.line2,
        city: city ?? this.city,
        state: state ?? this.state,
        postalCode: postalCode ?? this.postalCode);
  }

  Address.fromJson(Map<String, dynamic> json)
      : line1 = json['line1'],
        line2 = json['line2'],
        city = json['city'],
        state = json['state'],
        postalCode = json['postalCode'];

  Map<String, dynamic> toJson() => {
        'line1': line1,
        'line2': line2,
        'city': city,
        'state': state,
        'postalCode': postalCode
      };

  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Address\\";
    modelSchemaDefinition.pluralName = \\"Addresses\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
        fieldName: 'line1',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
        fieldName: 'line2',
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
        fieldName: 'city',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
        fieldName: 'state',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
        fieldName: 'postalCode',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}
"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for Address with nullsafety enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Address type in your schema. */
@immutable
class Address {
  final String? _line1;
  final String? _line2;
  final String? _city;
  final String? _state;
  final String? _postalCode;

  String get line1 {
    try {
      return _line1!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String? get line2 {
    return _line2;
  }
  
  String get city {
    try {
      return _city!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get state {
    try {
      return _state!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get postalCode {
    try {
      return _postalCode!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Address._internal({required line1, line2, required city, required state, required postalCode}): _line1 = line1, _line2 = line2, _city = city, _state = state, _postalCode = postalCode;
  
  factory Address({required String line1, String? line2, required String city, required String state, required String postalCode}) {
    return Address._internal(
      line1: line1,
      line2: line2,
      city: city,
      state: state,
      postalCode: postalCode);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Address &&
      _line1 == other._line1 &&
      _line2 == other._line2 &&
      _city == other._city &&
      _state == other._state &&
      _postalCode == other._postalCode;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Address {\\");
    buffer.write(\\"line1=\\" + \\"$_line1\\" + \\", \\");
    buffer.write(\\"line2=\\" + \\"$_line2\\" + \\", \\");
    buffer.write(\\"city=\\" + \\"$_city\\" + \\", \\");
    buffer.write(\\"state=\\" + \\"$_state\\" + \\", \\");
    buffer.write(\\"postalCode=\\" + \\"$_postalCode\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Address copyWith({String? line1, String? line2, String? city, String? state, String? postalCode}) {
    return Address(
      line1: line1 ?? this.line1,
      line2: line2 ?? this.line2,
      city: city ?? this.city,
      state: state ?? this.state,
      postalCode: postalCode ?? this.postalCode);
  }
  
  Address.fromJson(Map<String, dynamic> json)  
    : _line1 = json['line1'],
      _line2 = json['line2'],
      _city = json['city'],
      _state = json['state'],
      _postalCode = json['postalCode'];
  
  Map<String, dynamic> toJson() => {
    'line1': _line1, 'line2': _line2, 'city': _city, 'state': _state, 'postalCode': _postalCode
  };

  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Address\\";
    modelSchemaDefinition.pluralName = \\"Addresses\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'line1',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'line2',
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'city',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'state',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'postalCode',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for Contact with nullsafety disabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Contact type in your schema. */
@immutable
class Contact {
  final String contactName;
  final Phone phone;
  final List<Address> mailingAddresses;

  const Contact._internal(
      {@required this.contactName,
      @required this.phone,
      this.mailingAddresses});

  factory Contact(
      {@required String contactName,
      @required Phone phone,
      List<Address> mailingAddresses}) {
    return Contact._internal(
        contactName: contactName,
        phone: phone,
        mailingAddresses: mailingAddresses != null
            ? List<Address>.unmodifiable(mailingAddresses)
            : mailingAddresses);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Contact &&
        contactName == other.contactName &&
        phone == other.phone &&
        DeepCollectionEquality()
            .equals(mailingAddresses, other.mailingAddresses);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Contact {\\");
    buffer.write(\\"contactName=\\" + \\"$contactName\\" + \\", \\");
    buffer.write(\\"phone=\\" + (phone != null ? phone.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"mailingAddresses=\\" +
        (mailingAddresses != null ? mailingAddresses.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Contact copyWith(
      {String contactName, Phone phone, List<Address> mailingAddresses}) {
    return Contact(
        contactName: contactName ?? this.contactName,
        phone: phone ?? this.phone,
        mailingAddresses: mailingAddresses ?? this.mailingAddresses);
  }

  Contact.fromJson(Map<String, dynamic> json)
      : contactName = json['contactName'],
        phone = json['phone'] != null
            ? Phone.fromJson(new Map<String, dynamic>.from(json['phone']))
            : null,
        mailingAddresses = json['mailingAddresses'] is List
            ? (json['mailingAddresses'] as List)
                .map((e) => Address.fromJson(
                    new Map<String, dynamic>.from(e['serializedData'])))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'contactName': contactName,
        'phone': phone?.toJson(),
        'mailingAddresses':
            mailingAddresses?.map((Address e) => e?.toJson())?.toList()
      };

  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Contact\\";
    modelSchemaDefinition.pluralName = \\"Contacts\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
        fieldName: 'contactName',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
        fieldName: 'phone',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.embedded,
            ofCustomTypeName: 'Phone')));

    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
        fieldName: 'mailingAddresses',
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.embeddedCollection,
            ofCustomTypeName: 'Address')));
  });
}
"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for Contact with nullsafety enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Contact type in your schema. */
@immutable
class Contact {
  final String? _contactName;
  final Phone? _phone;
  final List<Address>? _mailingAddresses;

  String get contactName {
    try {
      return _contactName!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Phone get phone {
    try {
      return _phone!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Address>? get mailingAddresses {
    return _mailingAddresses;
  }
  
  const Contact._internal({required contactName, required phone, mailingAddresses}): _contactName = contactName, _phone = phone, _mailingAddresses = mailingAddresses;
  
  factory Contact({required String contactName, required Phone phone, List<Address>? mailingAddresses}) {
    return Contact._internal(
      contactName: contactName,
      phone: phone,
      mailingAddresses: mailingAddresses != null ? List<Address>.unmodifiable(mailingAddresses) : mailingAddresses);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Contact &&
      _contactName == other._contactName &&
      _phone == other._phone &&
      DeepCollectionEquality().equals(_mailingAddresses, other._mailingAddresses);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Contact {\\");
    buffer.write(\\"contactName=\\" + \\"$_contactName\\" + \\", \\");
    buffer.write(\\"phone=\\" + (_phone != null ? _phone!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"mailingAddresses=\\" + (_mailingAddresses != null ? _mailingAddresses!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Contact copyWith({String? contactName, Phone? phone, List<Address>? mailingAddresses}) {
    return Contact(
      contactName: contactName ?? this.contactName,
      phone: phone ?? this.phone,
      mailingAddresses: mailingAddresses ?? this.mailingAddresses);
  }
  
  Contact.fromJson(Map<String, dynamic> json)  
    : _contactName = json['contactName'],
      _phone = json['phone']?['serializedData'] != null
        ? Phone.fromJson(new Map<String, dynamic>.from(json['phone']['serializedData']))
        : null,
      _mailingAddresses = json['mailingAddresses'] is List
        ? (json['mailingAddresses'] as List)
          .where((e) => e != null)
          .map((e) => Address.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'contactName': _contactName, 'phone': _phone?.toJson(), 'mailingAddresses': _mailingAddresses?.map((Address? e) => e?.toJson()).toList()
  };

  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Contact\\";
    modelSchemaDefinition.pluralName = \\"Contacts\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.customTypeField(
      fieldName: 'contactName',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
      fieldName: 'phone',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.embedded, ofCustomTypeName: 'Phone')
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
      fieldName: 'mailingAddresses',
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.embeddedCollection, ofCustomTypeName: 'Address')
    ));
  });
}"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for ModelProvider with nullsafety disabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'Person.dart';
import 'Address.dart';
import 'Contact.dart';
import 'Phone.dart';

export 'Address.dart';
export 'Contact.dart';
export 'Person.dart';
export 'Phone.dart';

class ModelProvider implements ModelProviderInterface {
  @override
  String version = \\"b65f704d832381d9985dd162ae40c075\\";
  @override
  List<ModelSchema> modelSchemas = [Person.schema];
  static final ModelProvider _instance = ModelProvider();
  @override
  List<ModelSchema> customTypeSchemas = [
    Address.schema,
    Contact.schema,
    Phone.schema
  ];

  static ModelProvider get instance => _instance;

  ModelType getModelTypeByModelName(String modelName) {
    switch (modelName) {
      case \\"Person\\":
        return Person.classType;
      default:
        throw Exception(
            \\"Failed to find model in model provider for model name: \\" +
                modelName);
    }
  }
}
"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for ModelProvider with nullsafety enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'Person.dart';
import 'Address.dart';
import 'Contact.dart';
import 'Phone.dart';

export 'Address.dart';
export 'Contact.dart';
export 'Person.dart';
export 'Phone.dart';

class ModelProvider implements ModelProviderInterface {
  @override
  String version = \\"b65f704d832381d9985dd162ae40c075\\";
  @override
  List<ModelSchema> modelSchemas = [Person.schema];
  static final ModelProvider _instance = ModelProvider();
  @override
  List<ModelSchema> customTypeSchemas = [Address.schema, Contact.schema, Phone.schema];

  static ModelProvider get instance => _instance;
  
  ModelType getModelTypeByModelName(String modelName) {
    switch(modelName) {
      case \\"Person\\":
        return Person.classType;
      default:
        throw Exception(\\"Failed to find model in model provider for model name: \\" + modelName);
    }
  }
}"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for Person with nullsafety disabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Person type in your schema. */
@immutable
class Person extends Model {
  static const classType = const _PersonModelType();
  final String id;
  final String name;
  final Phone phone;
  final List<Address> mailingAddresses;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Person._internal(
      {@required this.id,
      @required this.name,
      @required this.phone,
      this.mailingAddresses});

  factory Person(
      {String id,
      @required String name,
      @required Phone phone,
      List<Address> mailingAddresses}) {
    return Person._internal(
        id: id == null ? UUID.getUUID() : id,
        name: name,
        phone: phone,
        mailingAddresses: mailingAddresses != null
            ? List<Address>.unmodifiable(mailingAddresses)
            : mailingAddresses);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Person &&
        id == other.id &&
        name == other.name &&
        phone == other.phone &&
        DeepCollectionEquality()
            .equals(mailingAddresses, other.mailingAddresses);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Person {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"phone=\\" + (phone != null ? phone.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"mailingAddresses=\\" +
        (mailingAddresses != null ? mailingAddresses.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Person copyWith(
      {String id, String name, Phone phone, List<Address> mailingAddresses}) {
    return Person(
        id: id ?? this.id,
        name: name ?? this.name,
        phone: phone ?? this.phone,
        mailingAddresses: mailingAddresses ?? this.mailingAddresses);
  }

  Person.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        phone = json['phone'] != null
            ? Phone.fromJson(new Map<String, dynamic>.from(json['phone']))
            : null,
        mailingAddresses = json['mailingAddresses'] is List
            ? (json['mailingAddresses'] as List)
                .map((e) => Address.fromJson(
                    new Map<String, dynamic>.from(e['serializedData'])))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'phone': phone?.toJson(),
        'mailingAddresses':
            mailingAddresses?.map((Address e) => e?.toJson())?.toList()
      };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField PHONE = QueryField(fieldName: \\"phone\\");
  static final QueryField MAILINGADDRESSES =
      QueryField(fieldName: \\"mailingAddresses\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Person\\";
    modelSchemaDefinition.pluralName = \\"People\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Person.NAME,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
        fieldName: 'phone',
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.embedded,
            ofCustomTypeName: 'Phone')));

    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
        fieldName: 'mailingAddresses',
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.embeddedCollection,
            ofCustomTypeName: 'Address')));
  });
}

class _PersonModelType extends ModelType<Person> {
  const _PersonModelType();

  @override
  Person fromJson(Map<String, dynamic> jsonData) {
    return Person.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should generated correct dart class for Person with nullsafety enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Person type in your schema. */
@immutable
class Person extends Model {
  static const classType = const _PersonModelType();
  final String id;
  final String? _name;
  final Phone? _phone;
  final List<Address>? _mailingAddresses;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Phone get phone {
    try {
      return _phone!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Address>? get mailingAddresses {
    return _mailingAddresses;
  }
  
  const Person._internal({required this.id, required name, required phone, mailingAddresses}): _name = name, _phone = phone, _mailingAddresses = mailingAddresses;
  
  factory Person({String? id, required String name, required Phone phone, List<Address>? mailingAddresses}) {
    return Person._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      phone: phone,
      mailingAddresses: mailingAddresses != null ? List<Address>.unmodifiable(mailingAddresses) : mailingAddresses);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Person &&
      id == other.id &&
      _name == other._name &&
      _phone == other._phone &&
      DeepCollectionEquality().equals(_mailingAddresses, other._mailingAddresses);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Person {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"phone=\\" + (_phone != null ? _phone!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"mailingAddresses=\\" + (_mailingAddresses != null ? _mailingAddresses!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Person copyWith({String? id, String? name, Phone? phone, List<Address>? mailingAddresses}) {
    return Person(
      id: id ?? this.id,
      name: name ?? this.name,
      phone: phone ?? this.phone,
      mailingAddresses: mailingAddresses ?? this.mailingAddresses);
  }
  
  Person.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _phone = json['phone']?['serializedData'] != null
        ? Phone.fromJson(new Map<String, dynamic>.from(json['phone']['serializedData']))
        : null,
      _mailingAddresses = json['mailingAddresses'] is List
        ? (json['mailingAddresses'] as List)
          .where((e) => e != null)
          .map((e) => Address.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'phone': _phone?.toJson(), 'mailingAddresses': _mailingAddresses?.map((Address? e) => e?.toJson()).toList()
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField PHONE = QueryField(fieldName: \\"phone\\");
  static final QueryField MAILINGADDRESSES = QueryField(fieldName: \\"mailingAddresses\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Person\\";
    modelSchemaDefinition.pluralName = \\"People\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Person.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
      fieldName: 'phone',
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.embedded, ofCustomTypeName: 'Phone')
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.embedded(
      fieldName: 'mailingAddresses',
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.embeddedCollection, ofCustomTypeName: 'Address')
    ));
  });
}

class _PersonModelType extends ModelType<Person> {
  const _PersonModelType();
  
  @override
  Person fromJson(Map<String, dynamic> jsonData) {
    return Person.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor CustomType (non-model) Tests should not generate custom type field in model provider if non model feature is disabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'Person.dart';
import 'Address.dart';
import 'Contact.dart';
import 'Phone.dart';

export 'Address.dart';
export 'Contact.dart';
export 'Person.dart';
export 'Phone.dart';

class ModelProvider implements ModelProviderInterface {
  @override
  String version = \\"b65f704d832381d9985dd162ae40c075\\";
  @override
  List<ModelSchema> modelSchemas = [Person.schema];
  static final ModelProvider _instance = ModelProvider();

  static ModelProvider get instance => _instance;
  
  ModelType getModelTypeByModelName(String modelName) {
    switch(modelName) {
      case \\"Person\\":
        return Person.classType;
      default:
        throw Exception(\\"Failed to find model in model provider for model name: \\" + modelName);
    }
  }
}"
`;

exports[`AppSync Dart Visitor Dart Specific Tests should generate the model provider 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'SimpleModel.dart';

export 'SimpleModel.dart';

class ModelProvider implements ModelProviderInterface {
  @override
  String version = \\"20078c21a81919792555926e238b194e\\";
  @override
  List<ModelSchema> modelSchemas = [SimpleModel.schema];
  static final ModelProvider _instance = ModelProvider();

  static ModelProvider get instance => _instance;

  ModelType getModelTypeByModelName(String modelName) {
    switch (modelName) {
      case \\"SimpleModel\\":
        return SimpleModel.classType;
      default:
        throw Exception(
            \\"Failed to find model in model provider for model name: \\" +
                modelName);
    }
  }
}
"
`;

exports[`AppSync Dart Visitor Enum Generation should generate a class for enum type 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final Status status;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const SimpleModel._internal({@required this.id, this.status});

  factory SimpleModel({String id, Status status}) {
    return SimpleModel._internal(
        id: id == null ? UUID.getUUID() : id, status: status);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel && id == other.id && status == other.status;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"status=\\" + (status != null ? enumToString(status) : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  SimpleModel copyWith({String id, Status status}) {
    return SimpleModel(id: id ?? this.id, status: status ?? this.status);
  }

  SimpleModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        status = enumFromString<Status>(json['status'], Status.values);

  Map<String, dynamic> toJson() => {'id': id, 'status': enumToString(status)};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField STATUS = QueryField(fieldName: \\"status\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.STATUS,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();

  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Enum Generation should generate a class for enum type 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

enum Status { yes, no, maybe }
"
`;

exports[`AppSync Dart Visitor Field tests should generate correct output for appsync scalar types of time and int 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the TemporalTimeModel type in your schema. */
@immutable
class TemporalTimeModel extends Model {
  static const classType = const _TemporalTimeModelModelType();
  final String id;
  final TemporalDate date;
  final TemporalTime time;
  final TemporalDateTime dateTime;
  final TemporalTimestamp timestamp;
  final int intNum;
  final List<TemporalDate> dateList;
  final List<TemporalTime> timeList;
  final List<TemporalDateTime> dateTimeList;
  final List<TemporalTimestamp> timestampList;
  final List<int> intList;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const TemporalTimeModel._internal(
      {@required this.id,
      this.date,
      this.time,
      this.dateTime,
      this.timestamp,
      this.intNum,
      this.dateList,
      this.timeList,
      this.dateTimeList,
      this.timestampList,
      this.intList});

  factory TemporalTimeModel(
      {String id,
      TemporalDate date,
      TemporalTime time,
      TemporalDateTime dateTime,
      TemporalTimestamp timestamp,
      int intNum,
      List<TemporalDate> dateList,
      List<TemporalTime> timeList,
      List<TemporalDateTime> dateTimeList,
      List<TemporalTimestamp> timestampList,
      List<int> intList}) {
    return TemporalTimeModel._internal(
        id: id == null ? UUID.getUUID() : id,
        date: date,
        time: time,
        dateTime: dateTime,
        timestamp: timestamp,
        intNum: intNum,
        dateList: dateList != null
            ? List<TemporalDate>.unmodifiable(dateList)
            : dateList,
        timeList: timeList != null
            ? List<TemporalTime>.unmodifiable(timeList)
            : timeList,
        dateTimeList: dateTimeList != null
            ? List<TemporalDateTime>.unmodifiable(dateTimeList)
            : dateTimeList,
        timestampList: timestampList != null
            ? List<TemporalTimestamp>.unmodifiable(timestampList)
            : timestampList,
        intList: intList != null ? List<int>.unmodifiable(intList) : intList);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TemporalTimeModel &&
        id == other.id &&
        date == other.date &&
        time == other.time &&
        dateTime == other.dateTime &&
        timestamp == other.timestamp &&
        intNum == other.intNum &&
        DeepCollectionEquality().equals(dateList, other.dateList) &&
        DeepCollectionEquality().equals(timeList, other.timeList) &&
        DeepCollectionEquality().equals(dateTimeList, other.dateTimeList) &&
        DeepCollectionEquality().equals(timestampList, other.timestampList) &&
        DeepCollectionEquality().equals(intList, other.intList);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"TemporalTimeModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"date=\\" + (date != null ? date.format() : \\"null\\") + \\", \\");
    buffer.write(\\"time=\\" + (time != null ? time.format() : \\"null\\") + \\", \\");
    buffer.write(
        \\"dateTime=\\" + (dateTime != null ? dateTime.format() : \\"null\\") + \\", \\");
    buffer.write(\\"timestamp=\\" +
        (timestamp != null ? timestamp.toString() : \\"null\\") +
        \\", \\");
    buffer.write(
        \\"intNum=\\" + (intNum != null ? intNum.toString() : \\"null\\") + \\", \\");
    buffer.write(
        \\"dateList=\\" + (dateList != null ? dateList.toString() : \\"null\\") + \\", \\");
    buffer.write(
        \\"timeList=\\" + (timeList != null ? timeList.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"dateTimeList=\\" +
        (dateTimeList != null ? dateTimeList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"timestampList=\\" +
        (timestampList != null ? timestampList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"intList=\\" + (intList != null ? intList.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  TemporalTimeModel copyWith(
      {String id,
      TemporalDate date,
      TemporalTime time,
      TemporalDateTime dateTime,
      TemporalTimestamp timestamp,
      int intNum,
      List<TemporalDate> dateList,
      List<TemporalTime> timeList,
      List<TemporalDateTime> dateTimeList,
      List<TemporalTimestamp> timestampList,
      List<int> intList}) {
    return TemporalTimeModel(
        id: id ?? this.id,
        date: date ?? this.date,
        time: time ?? this.time,
        dateTime: dateTime ?? this.dateTime,
        timestamp: timestamp ?? this.timestamp,
        intNum: intNum ?? this.intNum,
        dateList: dateList ?? this.dateList,
        timeList: timeList ?? this.timeList,
        dateTimeList: dateTimeList ?? this.dateTimeList,
        timestampList: timestampList ?? this.timestampList,
        intList: intList ?? this.intList);
  }

  TemporalTimeModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        date =
            json['date'] != null ? TemporalDate.fromString(json['date']) : null,
        time =
            json['time'] != null ? TemporalTime.fromString(json['time']) : null,
        dateTime = json['dateTime'] != null
            ? TemporalDateTime.fromString(json['dateTime'])
            : null,
        timestamp = json['timestamp'] != null
            ? TemporalTimestamp.fromSeconds(json['timestamp'])
            : null,
        intNum = (json['intNum'] as num)?.toInt(),
        dateList = (json['dateList'] as List)
            ?.map((e) => TemporalDate.fromString(e))
            .toList(),
        timeList = (json['timeList'] as List)
            ?.map((e) => TemporalTime.fromString(e))
            .toList(),
        dateTimeList = (json['dateTimeList'] as List)
            ?.map((e) => TemporalDateTime.fromString(e))
            .toList(),
        timestampList = (json['timestampList'] as List)
            ?.map((e) => TemporalTimestamp.fromSeconds(e))
            .toList(),
        intList =
            (json['intList'] as List)?.map((e) => (e as num).toInt()).toList();

  Map<String, dynamic> toJson() => {
        'id': id,
        'date': date?.format(),
        'time': time?.format(),
        'dateTime': dateTime?.format(),
        'timestamp': timestamp?.toSeconds(),
        'intNum': intNum,
        'dateList': dateList?.map((e) => e.format()).toList(),
        'timeList': timeList?.map((e) => e.format()).toList(),
        'dateTimeList': dateTimeList?.map((e) => e.format()).toList(),
        'timestampList': timestampList?.map((e) => e.toSeconds()).toList(),
        'intList': intList
      };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField DATE = QueryField(fieldName: \\"date\\");
  static final QueryField TIME = QueryField(fieldName: \\"time\\");
  static final QueryField DATETIME = QueryField(fieldName: \\"dateTime\\");
  static final QueryField TIMESTAMP = QueryField(fieldName: \\"timestamp\\");
  static final QueryField INTNUM = QueryField(fieldName: \\"intNum\\");
  static final QueryField DATELIST = QueryField(fieldName: \\"dateList\\");
  static final QueryField TIMELIST = QueryField(fieldName: \\"timeList\\");
  static final QueryField DATETIMELIST = QueryField(fieldName: \\"dateTimeList\\");
  static final QueryField TIMESTAMPLIST =
      QueryField(fieldName: \\"timestampList\\");
  static final QueryField INTLIST = QueryField(fieldName: \\"intList\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TemporalTimeModel\\";
    modelSchemaDefinition.pluralName = \\"TemporalTimeModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.DATE,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.date)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.TIME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.time)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.DATETIME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.TIMESTAMP,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.timestamp)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.INTNUM,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.int)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.DATELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.date))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.TIMELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.time))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.DATETIMELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.dateTime))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.TIMESTAMPLIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.timestamp))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TemporalTimeModel.INTLIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.int))));
  });
}

class _TemporalTimeModelModelType extends ModelType<TemporalTimeModel> {
  const _TemporalTimeModelModelType();

  @override
  TemporalTimeModel fromJson(Map<String, dynamic> jsonData) {
    return TemporalTimeModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Field tests should generate correct output for enum field w/o list or nullable 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the TestEnumModel type in your schema. */
@immutable
class TestEnumModel extends Model {
  static const classType = const _TestEnumModelModelType();
  final String id;
  final TestEnum enumVal;
  final TestEnum nullableEnumVal;
  final List<TestEnum> enumList;
  final List<TestEnum> enumNullableList;
  final List<TestEnum> nullableEnumList;
  final List<TestEnum> nullableEnumNullableList;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const TestEnumModel._internal(
      {@required this.id,
      @required this.enumVal,
      this.nullableEnumVal,
      @required this.enumList,
      this.enumNullableList,
      @required this.nullableEnumList,
      this.nullableEnumNullableList});

  factory TestEnumModel(
      {String id,
      @required TestEnum enumVal,
      TestEnum nullableEnumVal,
      @required List<TestEnum> enumList,
      List<TestEnum> enumNullableList,
      @required List<TestEnum> nullableEnumList,
      List<TestEnum> nullableEnumNullableList}) {
    return TestEnumModel._internal(
        id: id == null ? UUID.getUUID() : id,
        enumVal: enumVal,
        nullableEnumVal: nullableEnumVal,
        enumList:
            enumList != null ? List<TestEnum>.unmodifiable(enumList) : enumList,
        enumNullableList: enumNullableList != null
            ? List<TestEnum>.unmodifiable(enumNullableList)
            : enumNullableList,
        nullableEnumList: nullableEnumList != null
            ? List<TestEnum>.unmodifiable(nullableEnumList)
            : nullableEnumList,
        nullableEnumNullableList: nullableEnumNullableList != null
            ? List<TestEnum>.unmodifiable(nullableEnumNullableList)
            : nullableEnumNullableList);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestEnumModel &&
        id == other.id &&
        enumVal == other.enumVal &&
        nullableEnumVal == other.nullableEnumVal &&
        DeepCollectionEquality().equals(enumList, other.enumList) &&
        DeepCollectionEquality()
            .equals(enumNullableList, other.enumNullableList) &&
        DeepCollectionEquality()
            .equals(nullableEnumList, other.nullableEnumList) &&
        DeepCollectionEquality()
            .equals(nullableEnumNullableList, other.nullableEnumNullableList);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"TestEnumModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(
        \\"enumVal=\\" + (enumVal != null ? enumToString(enumVal) : \\"null\\") + \\", \\");
    buffer.write(\\"nullableEnumVal=\\" +
        (nullableEnumVal != null ? enumToString(nullableEnumVal) : \\"null\\") +
        \\", \\");
    buffer.write(
        \\"enumList=\\" + enumList?.map((e) => enumToString(e)).toString() + \\", \\");
    buffer.write(\\"enumNullableList=\\" +
        enumNullableList?.map((e) => enumToString(e)).toString() +
        \\", \\");
    buffer.write(\\"nullableEnumList=\\" +
        nullableEnumList?.map((e) => enumToString(e)).toString() +
        \\", \\");
    buffer.write(\\"nullableEnumNullableList=\\" +
        nullableEnumNullableList?.map((e) => enumToString(e)).toString());
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  TestEnumModel copyWith(
      {String id,
      TestEnum enumVal,
      TestEnum nullableEnumVal,
      List<TestEnum> enumList,
      List<TestEnum> enumNullableList,
      List<TestEnum> nullableEnumList,
      List<TestEnum> nullableEnumNullableList}) {
    return TestEnumModel(
        id: id ?? this.id,
        enumVal: enumVal ?? this.enumVal,
        nullableEnumVal: nullableEnumVal ?? this.nullableEnumVal,
        enumList: enumList ?? this.enumList,
        enumNullableList: enumNullableList ?? this.enumNullableList,
        nullableEnumList: nullableEnumList ?? this.nullableEnumList,
        nullableEnumNullableList:
            nullableEnumNullableList ?? this.nullableEnumNullableList);
  }

  TestEnumModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        enumVal = enumFromString<TestEnum>(json['enumVal'], TestEnum.values),
        nullableEnumVal =
            enumFromString<TestEnum>(json['nullableEnumVal'], TestEnum.values),
        enumList = json['enumList'] is List
            ? (json['enumList'] as List)
                .map((e) => enumFromString<TestEnum>(e, TestEnum.values))
                .toList()
            : null,
        enumNullableList = json['enumNullableList'] is List
            ? (json['enumNullableList'] as List)
                .map((e) => enumFromString<TestEnum>(e, TestEnum.values))
                .toList()
            : null,
        nullableEnumList = json['nullableEnumList'] is List
            ? (json['nullableEnumList'] as List)
                .map((e) => enumFromString<TestEnum>(e, TestEnum.values))
                .toList()
            : null,
        nullableEnumNullableList = json['nullableEnumNullableList'] is List
            ? (json['nullableEnumNullableList'] as List)
                .map((e) => enumFromString<TestEnum>(e, TestEnum.values))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'enumVal': enumToString(enumVal),
        'nullableEnumVal': enumToString(nullableEnumVal),
        'enumList': enumList?.map((e) => enumToString(e)).toList(),
        'enumNullableList':
            enumNullableList?.map((e) => enumToString(e)).toList(),
        'nullableEnumList':
            nullableEnumList?.map((e) => enumToString(e)).toList(),
        'nullableEnumNullableList':
            nullableEnumNullableList?.map((e) => enumToString(e)).toList()
      };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField ENUMVAL = QueryField(fieldName: \\"enumVal\\");
  static final QueryField NULLABLEENUMVAL =
      QueryField(fieldName: \\"nullableEnumVal\\");
  static final QueryField ENUMLIST = QueryField(fieldName: \\"enumList\\");
  static final QueryField ENUMNULLABLELIST =
      QueryField(fieldName: \\"enumNullableList\\");
  static final QueryField NULLABLEENUMLIST =
      QueryField(fieldName: \\"nullableEnumList\\");
  static final QueryField NULLABLEENUMNULLABLELIST =
      QueryField(fieldName: \\"nullableEnumNullableList\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestEnumModel\\";
    modelSchemaDefinition.pluralName = \\"TestEnumModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.ENUMVAL,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.NULLABLEENUMVAL,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.enumeration)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.ENUMLIST,
        isRequired: true,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.ENUMNULLABLELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.NULLABLEENUMLIST,
        isRequired: true,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestEnumModel.NULLABLEENUMNULLABLELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.enumeration))));
  });
}

class _TestEnumModelModelType extends ModelType<TestEnumModel> {
  const _TestEnumModelModelType();

  @override
  TestEnumModel fromJson(Map<String, dynamic> jsonData) {
    return TestEnumModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Field tests should generate correct output for regular field w/o list or nullable 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the TestModel type in your schema. */
@immutable
class TestModel extends Model {
  static const classType = const _TestModelModelType();
  final String id;
  final double floatVal;
  final double floatNullableVal;
  final List<double> floatList;
  final List<double> floatNullableList;
  final List<double> nullableFloatList;
  final List<double> nullableFloatNullableList;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const TestModel._internal(
      {@required this.id,
      @required this.floatVal,
      this.floatNullableVal,
      @required this.floatList,
      this.floatNullableList,
      @required this.nullableFloatList,
      this.nullableFloatNullableList});

  factory TestModel(
      {String id,
      @required double floatVal,
      double floatNullableVal,
      @required List<double> floatList,
      List<double> floatNullableList,
      @required List<double> nullableFloatList,
      List<double> nullableFloatNullableList}) {
    return TestModel._internal(
        id: id == null ? UUID.getUUID() : id,
        floatVal: floatVal,
        floatNullableVal: floatNullableVal,
        floatList: floatList != null
            ? List<double>.unmodifiable(floatList)
            : floatList,
        floatNullableList: floatNullableList != null
            ? List<double>.unmodifiable(floatNullableList)
            : floatNullableList,
        nullableFloatList: nullableFloatList != null
            ? List<double>.unmodifiable(nullableFloatList)
            : nullableFloatList,
        nullableFloatNullableList: nullableFloatNullableList != null
            ? List<double>.unmodifiable(nullableFloatNullableList)
            : nullableFloatNullableList);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestModel &&
        id == other.id &&
        floatVal == other.floatVal &&
        floatNullableVal == other.floatNullableVal &&
        DeepCollectionEquality().equals(floatList, other.floatList) &&
        DeepCollectionEquality()
            .equals(floatNullableList, other.floatNullableList) &&
        DeepCollectionEquality()
            .equals(nullableFloatList, other.nullableFloatList) &&
        DeepCollectionEquality()
            .equals(nullableFloatNullableList, other.nullableFloatNullableList);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"TestModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(
        \\"floatVal=\\" + (floatVal != null ? floatVal.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableVal=\\" +
        (floatNullableVal != null ? floatNullableVal.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"floatList=\\" +
        (floatList != null ? floatList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"floatNullableList=\\" +
        (floatNullableList != null ? floatNullableList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"nullableFloatList=\\" +
        (nullableFloatList != null ? nullableFloatList.toString() : \\"null\\") +
        \\", \\");
    buffer.write(\\"nullableFloatNullableList=\\" +
        (nullableFloatNullableList != null
            ? nullableFloatNullableList.toString()
            : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  TestModel copyWith(
      {String id,
      double floatVal,
      double floatNullableVal,
      List<double> floatList,
      List<double> floatNullableList,
      List<double> nullableFloatList,
      List<double> nullableFloatNullableList}) {
    return TestModel(
        id: id ?? this.id,
        floatVal: floatVal ?? this.floatVal,
        floatNullableVal: floatNullableVal ?? this.floatNullableVal,
        floatList: floatList ?? this.floatList,
        floatNullableList: floatNullableList ?? this.floatNullableList,
        nullableFloatList: nullableFloatList ?? this.nullableFloatList,
        nullableFloatNullableList:
            nullableFloatNullableList ?? this.nullableFloatNullableList);
  }

  TestModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        floatVal = (json['floatVal'] as num)?.toDouble(),
        floatNullableVal = (json['floatNullableVal'] as num)?.toDouble(),
        floatList = (json['floatList'] as List)
            ?.map((e) => (e as num).toDouble())
            .toList(),
        floatNullableList = (json['floatNullableList'] as List)
            ?.map((e) => (e as num).toDouble())
            .toList(),
        nullableFloatList = (json['nullableFloatList'] as List)
            ?.map((e) => (e as num).toDouble())
            .toList(),
        nullableFloatNullableList = (json['nullableFloatNullableList'] as List)
            ?.map((e) => (e as num).toDouble())
            .toList();

  Map<String, dynamic> toJson() => {
        'id': id,
        'floatVal': floatVal,
        'floatNullableVal': floatNullableVal,
        'floatList': floatList,
        'floatNullableList': floatNullableList,
        'nullableFloatList': nullableFloatList,
        'nullableFloatNullableList': nullableFloatNullableList
      };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField FLOATVAL = QueryField(fieldName: \\"floatVal\\");
  static final QueryField FLOATNULLABLEVAL =
      QueryField(fieldName: \\"floatNullableVal\\");
  static final QueryField FLOATLIST = QueryField(fieldName: \\"floatList\\");
  static final QueryField FLOATNULLABLELIST =
      QueryField(fieldName: \\"floatNullableList\\");
  static final QueryField NULLABLEFLOATLIST =
      QueryField(fieldName: \\"nullableFloatList\\");
  static final QueryField NULLABLEFLOATNULLABLELIST =
      QueryField(fieldName: \\"nullableFloatNullableList\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestModel\\";
    modelSchemaDefinition.pluralName = \\"TestModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.FLOATVAL,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.double)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.FLOATNULLABLEVAL,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.double)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.FLOATLIST,
        isRequired: true,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.double))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.FLOATNULLABLELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.double))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.NULLABLEFLOATLIST,
        isRequired: true,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.double))));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TestModel.NULLABLEFLOATNULLABLELIST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.double))));
  });
}

class _TestModelModelType extends ModelType<TestModel> {
  const _TestModelModelType();

  @override
  TestModel fromJson(Map<String, dynamic> jsonData) {
    return TestModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Many To Many V2 Tests Should generate the intermediate model successfully with nullsafety disabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String title;
  final String content;
  final List<PostTags> tags;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Post._internal(
      {@required this.id, @required this.title, this.content, this.tags});

  factory Post(
      {String id,
      @required String title,
      String content,
      List<PostTags> tags}) {
    return Post._internal(
        id: id == null ? UUID.getUUID() : id,
        title: title,
        content: content,
        tags: tags != null ? List<PostTags>.unmodifiable(tags) : tags);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
        id == other.id &&
        title == other.title &&
        content == other.content &&
        DeepCollectionEquality().equals(tags, other.tags);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$title\\" + \\", \\");
    buffer.write(\\"content=\\" + \\"$content\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Post copyWith(
      {String id, String title, String content, List<PostTags> tags}) {
    return Post(
        id: id ?? this.id,
        title: title ?? this.title,
        content: content ?? this.content,
        tags: tags ?? this.tags);
  }

  Post.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        title = json['title'],
        content = json['content'],
        tags = json['tags'] is List
            ? (json['tags'] as List)
                .map((e) => PostTags.fromJson(new Map<String, dynamic>.from(e)))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'content': content,
        'tags': tags?.map((PostTags e) => e?.toJson())?.toList()
      };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static final QueryField TAGS = QueryField(
      fieldName: \\"tags\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (PostTags).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.TITLE,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.CONTENT,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
        key: Post.TAGS,
        isRequired: false,
        ofModelName: (PostTags).toString(),
        associatedKey: PostTags.POST));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();

  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}

/** This is an auto generated class representing the Tag type in your schema. */
@immutable
class Tag extends Model {
  static const classType = const _TagModelType();
  final String id;
  final String label;
  final List<PostTags> posts;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Tag._internal({@required this.id, @required this.label, this.posts});

  factory Tag({String id, @required String label, List<PostTags> posts}) {
    return Tag._internal(
        id: id == null ? UUID.getUUID() : id,
        label: label,
        posts: posts != null ? List<PostTags>.unmodifiable(posts) : posts);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Tag &&
        id == other.id &&
        label == other.label &&
        DeepCollectionEquality().equals(posts, other.posts);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Tag {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"label=\\" + \\"$label\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Tag copyWith({String id, String label, List<PostTags> posts}) {
    return Tag(
        id: id ?? this.id,
        label: label ?? this.label,
        posts: posts ?? this.posts);
  }

  Tag.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        label = json['label'],
        posts = json['posts'] is List
            ? (json['posts'] as List)
                .map((e) => PostTags.fromJson(new Map<String, dynamic>.from(e)))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'label': label,
        'posts': posts?.map((PostTags e) => e?.toJson())?.toList()
      };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField LABEL = QueryField(fieldName: \\"label\\");
  static final QueryField POSTS = QueryField(
      fieldName: \\"posts\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (PostTags).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Tag\\";
    modelSchemaDefinition.pluralName = \\"Tags\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Tag.LABEL,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
        key: Tag.POSTS,
        isRequired: false,
        ofModelName: (PostTags).toString(),
        associatedKey: PostTags.TAG));
  });
}

class _TagModelType extends ModelType<Tag> {
  const _TagModelType();

  @override
  Tag fromJson(Map<String, dynamic> jsonData) {
    return Tag.fromJson(jsonData);
  }
}

/** This is an auto generated class representing the PostTags type in your schema. */
@immutable
class PostTags extends Model {
  static const classType = const _PostTagsModelType();
  final String id;
  final Post post;
  final Tag tag;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const PostTags._internal(
      {@required this.id, @required this.post, @required this.tag});

  factory PostTags({String id, @required Post post, @required Tag tag}) {
    return PostTags._internal(
        id: id == null ? UUID.getUUID() : id, post: post, tag: tag);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is PostTags &&
        id == other.id &&
        post == other.post &&
        tag == other.tag;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"PostTags {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (post != null ? post.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"tag=\\" + (tag != null ? tag.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  PostTags copyWith({String id, Post post, Tag tag}) {
    return PostTags(
        id: id ?? this.id, post: post ?? this.post, tag: tag ?? this.tag);
  }

  PostTags.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        post = json['post'] != null
            ? Post.fromJson(new Map<String, dynamic>.from(json['post']))
            : null,
        tag = json['tag'] != null
            ? Tag.fromJson(new Map<String, dynamic>.from(json['tag']))
            : null;

  Map<String, dynamic> toJson() =>
      {'id': id, 'post': post?.toJson(), 'tag': tag?.toJson()};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField POST = QueryField(
      fieldName: \\"post\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Post).toString()));
  static final QueryField TAG = QueryField(
      fieldName: \\"tag\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Tag).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"PostTags\\";
    modelSchemaDefinition.pluralName = \\"PostTags\\";

    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"postID\\"], name: \\"byPost\\"),
      ModelIndex(fields: const [\\"tagID\\"], name: \\"byTag\\")
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
        key: PostTags.POST,
        isRequired: true,
        targetName: \\"postID\\",
        ofModelName: (Post).toString()));

    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
        key: PostTags.TAG,
        isRequired: true,
        targetName: \\"tagID\\",
        ofModelName: (Tag).toString()));
  });
}

class _PostTagsModelType extends ModelType<PostTags> {
  const _PostTagsModelType();

  @override
  PostTags fromJson(Map<String, dynamic> jsonData) {
    return PostTags.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Many To Many V2 Tests Should generate the intermediate model successfully with nullsafety enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final String? _content;
  final List<PostTags>? _tags;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String? get content {
    return _content;
  }
  
  List<PostTags>? get tags {
    return _tags;
  }
  
  const Post._internal({required this.id, required title, content, tags}): _title = title, _content = content, _tags = tags;
  
  factory Post({String? id, required String title, String? content, List<PostTags>? tags}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      content: content,
      tags: tags != null ? List<PostTags>.unmodifiable(tags) : tags);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      _content == other._content &&
      DeepCollectionEquality().equals(_tags, other._tags);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, String? content, List<PostTags>? tags}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      content: content ?? this.content,
      tags: tags ?? this.tags);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _content = json['content'],
      _tags = json['tags'] is List
        ? (json['tags'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => PostTags.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'content': _content, 'tags': _tags?.map((PostTags? e) => e?.toJson()).toList()
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static final QueryField TAGS = QueryField(
    fieldName: \\"tags\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (PostTags).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.CONTENT,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.TAGS,
      isRequired: false,
      ofModelName: (PostTags).toString(),
      associatedKey: PostTags.POST
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}

/** This is an auto generated class representing the Tag type in your schema. */
@immutable
class Tag extends Model {
  static const classType = const _TagModelType();
  final String id;
  final String? _label;
  final List<PostTags>? _posts;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get label {
    try {
      return _label!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<PostTags>? get posts {
    return _posts;
  }
  
  const Tag._internal({required this.id, required label, posts}): _label = label, _posts = posts;
  
  factory Tag({String? id, required String label, List<PostTags>? posts}) {
    return Tag._internal(
      id: id == null ? UUID.getUUID() : id,
      label: label,
      posts: posts != null ? List<PostTags>.unmodifiable(posts) : posts);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Tag &&
      id == other.id &&
      _label == other._label &&
      DeepCollectionEquality().equals(_posts, other._posts);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Tag {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"label=\\" + \\"$_label\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Tag copyWith({String? id, String? label, List<PostTags>? posts}) {
    return Tag(
      id: id ?? this.id,
      label: label ?? this.label,
      posts: posts ?? this.posts);
  }
  
  Tag.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _label = json['label'],
      _posts = json['posts'] is List
        ? (json['posts'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => PostTags.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'label': _label, 'posts': _posts?.map((PostTags? e) => e?.toJson()).toList()
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField LABEL = QueryField(fieldName: \\"label\\");
  static final QueryField POSTS = QueryField(
    fieldName: \\"posts\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (PostTags).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Tag\\";
    modelSchemaDefinition.pluralName = \\"Tags\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Tag.LABEL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Tag.POSTS,
      isRequired: false,
      ofModelName: (PostTags).toString(),
      associatedKey: PostTags.TAG
    ));
  });
}

class _TagModelType extends ModelType<Tag> {
  const _TagModelType();
  
  @override
  Tag fromJson(Map<String, dynamic> jsonData) {
    return Tag.fromJson(jsonData);
  }
}

/** This is an auto generated class representing the PostTags type in your schema. */
@immutable
class PostTags extends Model {
  static const classType = const _PostTagsModelType();
  final String id;
  final Post? _post;
  final Tag? _tag;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  Post get post {
    try {
      return _post!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Tag get tag {
    try {
      return _tag!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const PostTags._internal({required this.id, required post, required tag}): _post = post, _tag = tag;
  
  factory PostTags({String? id, required Post post, required Tag tag}) {
    return PostTags._internal(
      id: id == null ? UUID.getUUID() : id,
      post: post,
      tag: tag);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is PostTags &&
      id == other.id &&
      _post == other._post &&
      _tag == other._tag;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"PostTags {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (_post != null ? _post!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"tag=\\" + (_tag != null ? _tag!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  PostTags copyWith({String? id, Post? post, Tag? tag}) {
    return PostTags(
      id: id ?? this.id,
      post: post ?? this.post,
      tag: tag ?? this.tag);
  }
  
  PostTags.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _post = json['post']?['serializedData'] != null
        ? Post.fromJson(new Map<String, dynamic>.from(json['post']['serializedData']))
        : null,
      _tag = json['tag']?['serializedData'] != null
        ? Tag.fromJson(new Map<String, dynamic>.from(json['tag']['serializedData']))
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'post': _post?.toJson(), 'tag': _tag?.toJson()
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField POST = QueryField(
    fieldName: \\"post\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Post).toString()));
  static final QueryField TAG = QueryField(
    fieldName: \\"tag\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Tag).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"PostTags\\";
    modelSchemaDefinition.pluralName = \\"PostTags\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"postID\\"], name: \\"byPost\\"),
      ModelIndex(fields: const [\\"tagID\\"], name: \\"byTag\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: PostTags.POST,
      isRequired: true,
      targetName: \\"postID\\",
      ofModelName: (Post).toString()
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: PostTags.TAG,
      isRequired: true,
      targetName: \\"tagID\\",
      ofModelName: (Tag).toString()
    ));
  });
}

class _PostTagsModelType extends ModelType<PostTags> {
  const _PostTagsModelType();
  
  @override
  PostTags fromJson(Map<String, dynamic> jsonData) {
    return PostTags.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Model Directive should generate a class for a Simple Model 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const SimpleModel._internal({@required this.id, this.name, this.bar});

  factory SimpleModel({String id, String name, String bar}) {
    return SimpleModel._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  SimpleModel copyWith({String id, String name, String bar}) {
    return SimpleModel(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  SimpleModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();

  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model Directive should generate a class for a model with all optional fields except id field 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const SimpleModel._internal({@required this.id, this.name, this.bar});

  factory SimpleModel({String id, String name, String bar}) {
    return SimpleModel._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  SimpleModel copyWith({String id, String name, String bar}) {
    return SimpleModel(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  SimpleModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();

  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate AuthRule with provider information when enabled inserting auth provider to auth when nullsafety is disabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the TodoWithAuth type in your schema. */
@immutable
class TodoWithAuth extends Model {
  static const classType = const _TodoWithAuthModelType();
  final String id;
  final String name;
  final TemporalDateTime createdAt;
  final TemporalDateTime updatedAt;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const TodoWithAuth._internal(
      {@required this.id, @required this.name, this.createdAt, this.updatedAt});

  factory TodoWithAuth({String id, @required String name}) {
    return TodoWithAuth._internal(
        id: id == null ? UUID.getUUID() : id, name: name);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TodoWithAuth && id == other.id && name == other.name;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"TodoWithAuth {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"createdAt=\\" +
        (createdAt != null ? createdAt.format() : \\"null\\") +
        \\", \\");
    buffer.write(
        \\"updatedAt=\\" + (updatedAt != null ? updatedAt.format() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  TodoWithAuth copyWith({String id, String name}) {
    return TodoWithAuth._internal(id: id ?? this.id, name: name ?? this.name);
  }

  TodoWithAuth.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        createdAt = json['createdAt'] != null
            ? TemporalDateTime.fromString(json['createdAt'])
            : null,
        updatedAt = json['updatedAt'] != null
            ? TemporalDateTime.fromString(json['updatedAt'])
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'createdAt': createdAt?.format(),
        'updatedAt': updatedAt?.format()
      };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TodoWithAuth\\";
    modelSchemaDefinition.pluralName = \\"TodoWithAuths\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.GROUPS,
          groupClaim: \\"cognito:groups\\",
          groups: [\\"admin\\"],
          provider: AuthRuleProvider.USERPOOLS,
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ]),
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"owner\\",
          identityClaim: \\"cognito:username\\",
          provider: AuthRuleProvider.USERPOOLS,
          operations: [ModelOperation.CREATE, ModelOperation.UPDATE]),
      AuthRule(
          authStrategy: AuthStrategy.PUBLIC,
          provider: AuthRuleProvider.APIKEY,
          operations: [ModelOperation.READ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: TodoWithAuth.NAME,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
        fieldName: 'createdAt',
        isRequired: false,
        isReadOnly: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)));

    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
        fieldName: 'updatedAt',
        isRequired: false,
        isReadOnly: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)));
  });
}

class _TodoWithAuthModelType extends ModelType<TodoWithAuth> {
  const _TodoWithAuthModelType();

  @override
  TodoWithAuth fromJson(Map<String, dynamic> jsonData) {
    return TodoWithAuth.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate AuthRule with provider information when enabled inserting auth provider to auth when nullsafety is enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TodoWithAuth type in your schema. */
@immutable
class TodoWithAuth extends Model {
  static const classType = const _TodoWithAuthModelType();
  final String id;
  final String? _name;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const TodoWithAuth._internal({required this.id, required name, createdAt, updatedAt}): _name = name, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory TodoWithAuth({String? id, required String name}) {
    return TodoWithAuth._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TodoWithAuth &&
      id == other.id &&
      _name == other._name;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TodoWithAuth {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TodoWithAuth copyWith({String? id, String? name}) {
    return TodoWithAuth._internal(
      id: id ?? this.id,
      name: name ?? this.name);
  }
  
  TodoWithAuth.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TodoWithAuth\\";
    modelSchemaDefinition.pluralName = \\"TodoWithAuths\\";
    
    modelSchemaDefinition.authRules = [
      AuthRule(
        authStrategy: AuthStrategy.GROUPS,
        groupClaim: \\"cognito:groups\\",
        groups: [ \\"admin\\" ],
        provider: AuthRuleProvider.USERPOOLS,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE,
          ModelOperation.DELETE,
          ModelOperation.READ
        ]),
      AuthRule(
        authStrategy: AuthStrategy.OWNER,
        ownerField: \\"owner\\",
        identityClaim: \\"cognito:username\\",
        provider: AuthRuleProvider.USERPOOLS,
        operations: [
          ModelOperation.CREATE,
          ModelOperation.UPDATE
        ]),
      AuthRule(
        authStrategy: AuthStrategy.PUBLIC,
        provider: AuthRuleProvider.APIKEY,
        operations: [
          ModelOperation.READ
        ])
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TodoWithAuth.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _TodoWithAuthModelType extends ModelType<TodoWithAuth> {
  const _TodoWithAuthModelType();
  
  @override
  TodoWithAuth fromJson(Map<String, dynamic> jsonData) {
    return TodoWithAuth.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with custom claims 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the customClaim type in your schema. */
@immutable
class customClaim extends Model {
  static const classType = const _customClaimModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const customClaim._internal({@required this.id, this.name, this.bar});

  factory customClaim({String id, String name, String bar}) {
    return customClaim._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is customClaim &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"customClaim {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  customClaim copyWith({String id, String name, String bar}) {
    return customClaim(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  customClaim.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"customClaim\\";
    modelSchemaDefinition.pluralName = \\"customClaims\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"owner\\",
          identityClaim: \\"user_id\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: customClaim.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: customClaim.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _customClaimModelType extends ModelType<customClaim> {
  const _customClaimModelType();

  @override
  customClaim fromJson(Map<String, dynamic> jsonData) {
    return customClaim.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with custom group claims 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the customClaim type in your schema. */
@immutable
class customClaim extends Model {
  static const classType = const _customClaimModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const customClaim._internal({@required this.id, this.name, this.bar});

  factory customClaim({String id, String name, String bar}) {
    return customClaim._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is customClaim &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"customClaim {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  customClaim copyWith({String id, String name, String bar}) {
    return customClaim(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  customClaim.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"customClaim\\";
    modelSchemaDefinition.pluralName = \\"customClaims\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.GROUPS,
          groupClaim: \\"user_groups\\",
          groups: [
            \\"Moderator\\"
          ],
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: customClaim.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: customClaim.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _customClaimModelType extends ModelType<customClaim> {
  const _customClaimModelType();

  @override
  customClaim fromJson(Map<String, dynamic> jsonData) {
    return customClaim.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with dynamic groups 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the dynamicGroups type in your schema. */
@immutable
class dynamicGroups extends Model {
  static const classType = const _dynamicGroupsModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const dynamicGroups._internal({@required this.id, this.name, this.bar});

  factory dynamicGroups({String id, String name, String bar}) {
    return dynamicGroups._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is dynamicGroups &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"dynamicGroups {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  dynamicGroups copyWith({String id, String name, String bar}) {
    return dynamicGroups(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  dynamicGroups.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"dynamicGroups\\";
    modelSchemaDefinition.pluralName = \\"dynamicGroups\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.GROUPS,
          groupClaim: \\"cognito:groups\\",
          groupsField: \\"groups\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: dynamicGroups.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: dynamicGroups.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _dynamicGroupsModelType extends ModelType<dynamicGroups> {
  const _dynamicGroupsModelType();

  @override
  dynamicGroups fromJson(Map<String, dynamic> jsonData) {
    return dynamicGroups.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with owner auth 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the simpleOwnerAuth type in your schema. */
@immutable
class simpleOwnerAuth extends Model {
  static const classType = const _simpleOwnerAuthModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const simpleOwnerAuth._internal({@required this.id, this.name, this.bar});

  factory simpleOwnerAuth({String id, String name, String bar}) {
    return simpleOwnerAuth._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is simpleOwnerAuth &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"simpleOwnerAuth {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  simpleOwnerAuth copyWith({String id, String name, String bar}) {
    return simpleOwnerAuth(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  simpleOwnerAuth.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"simpleOwnerAuth\\";
    modelSchemaDefinition.pluralName = \\"simpleOwnerAuths\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"owner\\",
          identityClaim: \\"cognito:username\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: simpleOwnerAuth.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: simpleOwnerAuth.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _simpleOwnerAuthModelType extends ModelType<simpleOwnerAuth> {
  const _simpleOwnerAuthModelType();

  @override
  simpleOwnerAuth fromJson(Map<String, dynamic> jsonData) {
    return simpleOwnerAuth.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with owner auth allowing others to read: 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the allowRead type in your schema. */
@immutable
class allowRead extends Model {
  static const classType = const _allowReadModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const allowRead._internal({@required this.id, this.name, this.bar});

  factory allowRead({String id, String name, String bar}) {
    return allowRead._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is allowRead &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"allowRead {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  allowRead copyWith({String id, String name, String bar}) {
    return allowRead(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  allowRead.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"allowRead\\";
    modelSchemaDefinition.pluralName = \\"allowReads\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"owner\\",
          identityClaim: \\"cognito:username\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.DELETE,
            ModelOperation.UPDATE
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: allowRead.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: allowRead.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _allowReadModelType extends ModelType<allowRead> {
  const _allowReadModelType();

  @override
  allowRead fromJson(Map<String, dynamic> jsonData) {
    return allowRead.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with private authorization 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the privateType type in your schema. */
@immutable
class privateType extends Model {
  static const classType = const _privateTypeModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const privateType._internal({@required this.id, this.name, this.bar});

  factory privateType({String id, String name, String bar}) {
    return privateType._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is privateType &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"privateType {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  privateType copyWith({String id, String name, String bar}) {
    return privateType(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  privateType.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"privateType\\";
    modelSchemaDefinition.pluralName = \\"privateTypes\\";

    modelSchemaDefinition.authRules = [
      AuthRule(authStrategy: AuthStrategy.PRIVATE, operations: [
        ModelOperation.CREATE,
        ModelOperation.UPDATE,
        ModelOperation.DELETE,
        ModelOperation.READ
      ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: privateType.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: privateType.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _privateTypeModelType extends ModelType<privateType> {
  const _privateTypeModelType();

  @override
  privateType fromJson(Map<String, dynamic> jsonData) {
    return privateType.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with public authorization 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the publicType type in your schema. */
@immutable
class publicType extends Model {
  static const classType = const _publicTypeModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const publicType._internal({@required this.id, this.name, this.bar});

  factory publicType({String id, String name, String bar}) {
    return publicType._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is publicType &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"publicType {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  publicType copyWith({String id, String name, String bar}) {
    return publicType(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  publicType.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"publicType\\";
    modelSchemaDefinition.pluralName = \\"publicTypes\\";

    modelSchemaDefinition.authRules = [
      AuthRule(authStrategy: AuthStrategy.PUBLIC, operations: [
        ModelOperation.CREATE,
        ModelOperation.UPDATE,
        ModelOperation.DELETE,
        ModelOperation.READ
      ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: publicType.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: publicType.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _publicTypeModelType extends ModelType<publicType> {
  const _publicTypeModelType();

  @override
  publicType fromJson(Map<String, dynamic> jsonData) {
    return publicType.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should generate class with static groups 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the staticGroups type in your schema. */
@immutable
class staticGroups extends Model {
  static const classType = const _staticGroupsModelType();
  final String id;
  final String name;
  final String bar;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const staticGroups._internal({@required this.id, this.name, this.bar});

  factory staticGroups({String id, String name, String bar}) {
    return staticGroups._internal(
        id: id == null ? UUID.getUUID() : id, name: name, bar: bar);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is staticGroups &&
        id == other.id &&
        name == other.name &&
        bar == other.bar;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"staticGroups {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"bar=\\" + \\"$bar\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  staticGroups copyWith({String id, String name, String bar}) {
    return staticGroups(
        id: id ?? this.id, name: name ?? this.name, bar: bar ?? this.bar);
  }

  staticGroups.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        bar = json['bar'];

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'bar': bar};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BAR = QueryField(fieldName: \\"bar\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"staticGroups\\";
    modelSchemaDefinition.pluralName = \\"staticGroups\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.GROUPS,
          groupClaim: \\"cognito:groups\\",
          groups: [
            \\"Admin\\"
          ],
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: staticGroups.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: staticGroups.BAR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _staticGroupsModelType extends ModelType<staticGroups> {
  const _staticGroupsModelType();

  @override
  staticGroups fromJson(Map<String, dynamic> jsonData) {
    return staticGroups.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should include authRules in schema when owner auth is used with ownerField 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String title;
  final String author;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Post._internal(
      {@required this.id, @required this.title, @required this.author});

  factory Post({String id, @required String title, @required String author}) {
    return Post._internal(
        id: id == null ? UUID.getUUID() : id, title: title, author: author);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
        id == other.id &&
        title == other.title &&
        author == other.author;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$title\\" + \\", \\");
    buffer.write(\\"author=\\" + \\"$author\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Post copyWith({String id, String title, String author}) {
    return Post(
        id: id ?? this.id,
        title: title ?? this.title,
        author: author ?? this.author);
  }

  Post.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        title = json['title'],
        author = json['author'];

  Map<String, dynamic> toJson() => {'id': id, 'title': title, 'author': author};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField AUTHOR = QueryField(fieldName: \\"author\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"author\\",
          identityClaim: \\"cognito:username\\",
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.TITLE,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.AUTHOR,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();

  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Auth Directive should support multiple auth rules 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String title;
  final String owner;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Post._internal(
      {@required this.id, @required this.title, @required this.owner});

  factory Post({String id, @required String title, @required String owner}) {
    return Post._internal(
        id: id == null ? UUID.getUUID() : id, title: title, owner: owner);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
        id == other.id &&
        title == other.title &&
        owner == other.owner;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$title\\" + \\", \\");
    buffer.write(\\"owner=\\" + \\"$owner\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Post copyWith({String id, String title, String owner}) {
    return Post(
        id: id ?? this.id,
        title: title ?? this.title,
        owner: owner ?? this.owner);
  }

  Post.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        title = json['title'],
        owner = json['owner'];

  Map<String, dynamic> toJson() => {'id': id, 'title': title, 'owner': owner};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField OWNER = QueryField(fieldName: \\"owner\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";

    modelSchemaDefinition.authRules = [
      AuthRule(
          authStrategy: AuthStrategy.GROUPS,
          groupClaim: \\"cognito:groups\\",
          groups: [
            \\"admin\\"
          ],
          operations: [
            ModelOperation.CREATE,
            ModelOperation.UPDATE,
            ModelOperation.DELETE,
            ModelOperation.READ
          ]),
      AuthRule(
          authStrategy: AuthStrategy.OWNER,
          ownerField: \\"owner\\",
          identityClaim: \\"cognito:username\\",
          operations: [ModelOperation.CREATE, ModelOperation.UPDATE]),
      AuthRule(authStrategy: AuthStrategy.PUBLIC, operations: [
        ModelOperation.CREATE,
        ModelOperation.UPDATE,
        ModelOperation.DELETE,
        ModelOperation.READ
      ])
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.TITLE,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.OWNER,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();

  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should generate classes for models with one to many connection 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Todo type in your schema. */
@immutable
class Todo extends Model {
  static const classType = const _TodoModelType();
  final String id;
  final List<Task> tasks;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Todo._internal({@required this.id, this.tasks});

  factory Todo({String id, List<Task> tasks}) {
    return Todo._internal(
        id: id == null ? UUID.getUUID() : id,
        tasks: tasks != null ? List<Task>.unmodifiable(tasks) : tasks);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Todo &&
        id == other.id &&
        DeepCollectionEquality().equals(tasks, other.tasks);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Todo {\\");
    buffer.write(\\"id=\\" + \\"$id\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Todo copyWith({String id, List<Task> tasks}) {
    return Todo(id: id ?? this.id, tasks: tasks ?? this.tasks);
  }

  Todo.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        tasks = json['tasks'] is List
            ? (json['tasks'] as List)
                .map((e) => Task.fromJson(new Map<String, dynamic>.from(e)))
                .toList()
            : null;

  Map<String, dynamic> toJson() =>
      {'id': id, 'tasks': tasks?.map((Task e) => e?.toJson())?.toList()};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TASKS = QueryField(
      fieldName: \\"tasks\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Task).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Todo\\";
    modelSchemaDefinition.pluralName = \\"Todos\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
        key: Todo.TASKS,
        isRequired: false,
        ofModelName: (Task).toString(),
        associatedKey: Task.TODO));
  });
}

class _TodoModelType extends ModelType<Todo> {
  const _TodoModelType();

  @override
  Todo fromJson(Map<String, dynamic> jsonData) {
    return Todo.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should generate classes for models with one to many connection 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Task type in your schema. */
@immutable
class Task extends Model {
  static const classType = const _TaskModelType();
  final String id;
  final Todo todo;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Task._internal({@required this.id, this.todo});

  factory Task({String id, Todo todo}) {
    return Task._internal(id: id == null ? UUID.getUUID() : id, todo: todo);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Task && id == other.id && todo == other.todo;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Task {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"todo=\\" + (todo != null ? todo.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Task copyWith({String id, Todo todo}) {
    return Task(id: id ?? this.id, todo: todo ?? this.todo);
  }

  Task.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        todo = json['todo'] != null
            ? Todo.fromJson(new Map<String, dynamic>.from(json['todo']))
            : null;

  Map<String, dynamic> toJson() => {'id': id, 'todo': todo?.toJson()};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TODO = QueryField(
      fieldName: \\"todo\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Todo).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Task\\";
    modelSchemaDefinition.pluralName = \\"Tasks\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
        key: Task.TODO,
        isRequired: false,
        targetName: \\"taskTodoId\\",
        ofModelName: (Todo).toString()));
  });
}

class _TaskModelType extends ModelType<Task> {
  const _TaskModelType();

  @override
  Task fromJson(Map<String, dynamic> jsonData) {
    return Task.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should support connection directive with keyName and fields 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Blog type in your schema. */
@immutable
class Blog extends Model {
  static const classType = const _BlogModelType();
  final String id;
  final String name;
  final List<Post> posts;
  final List<String> test;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Blog._internal(
      {@required this.id, @required this.name, this.posts, this.test});

  factory Blog(
      {String id, @required String name, List<Post> posts, List<String> test}) {
    return Blog._internal(
        id: id == null ? UUID.getUUID() : id,
        name: name,
        posts: posts != null ? List<Post>.unmodifiable(posts) : posts,
        test: test != null ? List<String>.unmodifiable(test) : test);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Blog &&
        id == other.id &&
        name == other.name &&
        DeepCollectionEquality().equals(posts, other.posts) &&
        DeepCollectionEquality().equals(test, other.test);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Blog {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"test=\\" + (test != null ? test.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Blog copyWith({String id, String name, List<Post> posts, List<String> test}) {
    return Blog(
        id: id ?? this.id,
        name: name ?? this.name,
        posts: posts ?? this.posts,
        test: test ?? this.test);
  }

  Blog.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        posts = json['posts'] is List
            ? (json['posts'] as List)
                .map((e) => Post.fromJson(new Map<String, dynamic>.from(e)))
                .toList()
            : null,
        test = json['test']?.cast<String>();

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'posts': posts?.map((Post e) => e?.toJson())?.toList(),
        'test': test
      };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField POSTS = QueryField(
      fieldName: \\"posts\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Post).toString()));
  static final QueryField TEST = QueryField(fieldName: \\"test\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Blog\\";
    modelSchemaDefinition.pluralName = \\"Blogs\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Blog.NAME,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
        key: Blog.POSTS,
        isRequired: false,
        ofModelName: (Post).toString(),
        associatedKey: Post.BLOG));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Blog.TEST,
        isRequired: false,
        isArray: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.collection,
            ofModelName: describeEnum(ModelFieldTypeEnum.string))));
  });
}

class _BlogModelType extends ModelType<Blog> {
  const _BlogModelType();

  @override
  Blog fromJson(Map<String, dynamic> jsonData) {
    return Blog.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should support connection directive with keyName and fields 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final Post post;
  final String content;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Comment._internal(
      {@required this.id, this.post, @required this.content});

  factory Comment({String id, Post post, @required String content}) {
    return Comment._internal(
        id: id == null ? UUID.getUUID() : id, post: post, content: content);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
        id == other.id &&
        post == other.post &&
        content == other.content;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (post != null ? post.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"content=\\" + \\"$content\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Comment copyWith({String id, Post post, String content}) {
    return Comment(
        id: id ?? this.id,
        post: post ?? this.post,
        content: content ?? this.content);
  }

  Comment.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        post = json['post'] != null
            ? Post.fromJson(new Map<String, dynamic>.from(json['post']))
            : null,
        content = json['content'];

  Map<String, dynamic> toJson() =>
      {'id': id, 'post': post?.toJson(), 'content': content};

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField POST = QueryField(
      fieldName: \\"post\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Post).toString()));
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";

    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"postID\\", \\"content\\"], name: \\"byPost\\")
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
        key: Comment.POST,
        isRequired: false,
        targetName: \\"postID\\",
        ofModelName: (Post).toString()));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Comment.CONTENT,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();

  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Connection Directive should support connection directive with keyName and fields 3`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String title;
  final Blog blog;
  final List<Comment> comments;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const Post._internal(
      {@required this.id, @required this.title, this.blog, this.comments});

  factory Post(
      {String id, @required String title, Blog blog, List<Comment> comments}) {
    return Post._internal(
        id: id == null ? UUID.getUUID() : id,
        title: title,
        blog: blog,
        comments:
            comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
        id == other.id &&
        title == other.title &&
        blog == other.blog &&
        DeepCollectionEquality().equals(comments, other.comments);
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$title\\" + \\", \\");
    buffer.write(\\"blog=\\" + (blog != null ? blog.toString() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  Post copyWith({String id, String title, Blog blog, List<Comment> comments}) {
    return Post(
        id: id ?? this.id,
        title: title ?? this.title,
        blog: blog ?? this.blog,
        comments: comments ?? this.comments);
  }

  Post.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        title = json['title'],
        blog = json['blog'] != null
            ? Blog.fromJson(new Map<String, dynamic>.from(json['blog']))
            : null,
        comments = json['comments'] is List
            ? (json['comments'] as List)
                .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e)))
                .toList()
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'blog': blog?.toJson(),
        'comments': comments?.map((Comment e) => e?.toJson())?.toList()
      };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField BLOG = QueryField(
      fieldName: \\"blog\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Blog).toString()));
  static final QueryField COMMENTS = QueryField(
      fieldName: \\"comments\\",
      fieldType: ModelFieldType(ModelFieldTypeEnum.model,
          ofModelName: (Comment).toString()));
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";

    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"blogID\\"], name: \\"byBlog\\")
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: Post.TITLE,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
        key: Post.BLOG,
        isRequired: false,
        targetName: \\"blogID\\",
        ofModelName: (Blog).toString()));

    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
        key: Post.COMMENTS,
        isRequired: false,
        ofModelName: (Comment).toString(),
        associatedKey: Comment.POST));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();

  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Model with Key Directive should generate a class for model with key directive 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the authorBook type in your schema. */
@immutable
class authorBook extends Model {
  static const classType = const _authorBookModelType();
  final String id;
  final String author_id;
  final String book_id;
  final String author;
  final String book;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const authorBook._internal(
      {@required this.id,
      @required this.author_id,
      @required this.book_id,
      this.author,
      this.book});

  factory authorBook(
      {String id,
      @required String author_id,
      @required String book_id,
      String author,
      String book}) {
    return authorBook._internal(
        id: id == null ? UUID.getUUID() : id,
        author_id: author_id,
        book_id: book_id,
        author: author,
        book: book);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is authorBook &&
        id == other.id &&
        author_id == other.author_id &&
        book_id == other.book_id &&
        author == other.author &&
        book == other.book;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"authorBook {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"author_id=\\" + \\"$author_id\\" + \\", \\");
    buffer.write(\\"book_id=\\" + \\"$book_id\\" + \\", \\");
    buffer.write(\\"author=\\" + \\"$author\\" + \\", \\");
    buffer.write(\\"book=\\" + \\"$book\\");
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  authorBook copyWith(
      {String id,
      String author_id,
      String book_id,
      String author,
      String book}) {
    return authorBook(
        id: id ?? this.id,
        author_id: author_id ?? this.author_id,
        book_id: book_id ?? this.book_id,
        author: author ?? this.author,
        book: book ?? this.book);
  }

  authorBook.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        author_id = json['author_id'],
        book_id = json['book_id'],
        author = json['author'],
        book = json['book'];

  Map<String, dynamic> toJson() => {
        'id': id,
        'author_id': author_id,
        'book_id': book_id,
        'author': author,
        'book': book
      };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField AUTHOR_ID = QueryField(fieldName: \\"author_id\\");
  static final QueryField BOOK_ID = QueryField(fieldName: \\"book_id\\");
  static final QueryField AUTHOR = QueryField(fieldName: \\"author\\");
  static final QueryField BOOK = QueryField(fieldName: \\"book\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"authorBook\\";
    modelSchemaDefinition.pluralName = \\"authorBooks\\";

    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"author_id\\"], name: \\"byAuthor\\"),
      ModelIndex(fields: const [\\"book_id\\"], name: \\"byBook\\")
    ];

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: authorBook.AUTHOR_ID,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: authorBook.BOOK_ID,
        isRequired: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: authorBook.AUTHOR,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: authorBook.BOOK,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));
  });
}

class _authorBookModelType extends ModelType<authorBook> {
  const _authorBookModelType();

  @override
  authorBook fromJson(Map<String, dynamic> jsonData) {
    return authorBook.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct internal constructor for a model has only ID field 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TestModel type in your schema. */
@immutable
class TestModel extends Model {
  static const classType = const _TestModelModelType();
  final String id;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  const TestModel._internal({required this.id});
  
  factory TestModel({String? id}) {
    return TestModel._internal(
      id: id == null ? UUID.getUUID() : id);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestModel &&
      id == other.id;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TestModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TestModel copyWith({String? id}) {
    return TestModel(
      id: id ?? this.id);
  }
  
  TestModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'];
  
  Map<String, dynamic> toJson() => {
    'id': id
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestModel\\";
    modelSchemaDefinition.pluralName = \\"TestModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
  });
}

class _TestModelModelType extends ModelType<TestModel> {
  const _TestModelModelType();
  
  @override
  TestModel fromJson(Map<String, dynamic> jsonData) {
    return TestModel.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct model files if the null safety is enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Blog type in your schema. */
@immutable
class Blog extends Model {
  static const classType = const _BlogModelType();
  final String id;
  final String? _name;
  final List<Post>? _posts;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Post>? get posts {
    return _posts;
  }
  
  const Blog._internal({required this.id, required name, posts}): _name = name, _posts = posts;
  
  factory Blog({String? id, required String name, List<Post>? posts}) {
    return Blog._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      posts: posts != null ? List<Post>.unmodifiable(posts) : posts);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Blog &&
      id == other.id &&
      _name == other._name &&
      DeepCollectionEquality().equals(_posts, other._posts);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Blog {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Blog copyWith({String? id, String? name, List<Post>? posts}) {
    return Blog(
      id: id ?? this.id,
      name: name ?? this.name,
      posts: posts ?? this.posts);
  }
  
  Blog.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _posts = json['posts'] is List
        ? (json['posts'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Post.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'posts': _posts?.map((Post? e) => e?.toJson()).toList()
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField POSTS = QueryField(
    fieldName: \\"posts\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Post).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Blog\\";
    modelSchemaDefinition.pluralName = \\"Blogs\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Blog.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Blog.POSTS,
      isRequired: false,
      ofModelName: (Post).toString(),
      associatedKey: Post.BLOG
    ));
  });
}

class _BlogModelType extends ModelType<Blog> {
  const _BlogModelType();
  
  @override
  Blog fromJson(Map<String, dynamic> jsonData) {
    return Blog.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct model files if the null safety is enabled 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final Post? _post;
  final String? _content;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  Post? get post {
    return _post;
  }
  
  String get content {
    try {
      return _content!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Comment._internal({required this.id, post, required content}): _post = post, _content = content;
  
  factory Comment({String? id, Post? post, required String content}) {
    return Comment._internal(
      id: id == null ? UUID.getUUID() : id,
      post: post,
      content: content);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
      id == other.id &&
      _post == other._post &&
      _content == other._content;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"post=\\" + (_post != null ? _post!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment copyWith({String? id, Post? post, String? content}) {
    return Comment(
      id: id ?? this.id,
      post: post ?? this.post,
      content: content ?? this.content);
  }
  
  Comment.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _post = json['post']?['serializedData'] != null
        ? Post.fromJson(new Map<String, dynamic>.from(json['post']['serializedData']))
        : null,
      _content = json['content'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'post': _post?.toJson(), 'content': _content
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField POST = QueryField(
    fieldName: \\"post\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Post).toString()));
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"postID\\", \\"content\\"], name: \\"byPost\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Comment.POST,
      isRequired: false,
      targetName: \\"postID\\",
      ofModelName: (Post).toString()
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.CONTENT,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();
  
  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct model files if the null safety is enabled 3`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final Blog? _blog;
  final List<Comment>? _comments;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Blog? get blog {
    return _blog;
  }
  
  List<Comment>? get comments {
    return _comments;
  }
  
  const Post._internal({required this.id, required title, blog, comments}): _title = title, _blog = blog, _comments = comments;
  
  factory Post({String? id, required String title, Blog? blog, List<Comment>? comments}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      blog: blog,
      comments: comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      _blog == other._blog &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"blog=\\" + (_blog != null ? _blog!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, Blog? blog, List<Comment>? comments}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      blog: blog ?? this.blog,
      comments: comments ?? this.comments);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _blog = json['blog']?['serializedData'] != null
        ? Blog.fromJson(new Map<String, dynamic>.from(json['blog']['serializedData']))
        : null,
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'blog': _blog?.toJson(), 'comments': _comments?.map((Comment? e) => e?.toJson()).toList()
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField BLOG = QueryField(
    fieldName: \\"blog\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Blog).toString()));
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Comment).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"blogID\\"], name: \\"byBlog\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Post.BLOG,
      isRequired: false,
      targetName: \\"blogID\\",
      ofModelName: (Blog).toString()
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.COMMENTS,
      isRequired: false,
      ofModelName: (Comment).toString(),
      associatedKey: Comment.POST
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct null safe output for regular field w/o list or nullable 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TestModel type in your schema. */
@immutable
class TestModel extends Model {
  static const classType = const _TestModelModelType();
  final String id;
  final double? _floatVal;
  final double? _floatNullableVal;
  final List<double>? _floatList;
  final List<double>? _floatNullableList;
  final List<double>? _nullableFloatList;
  final List<double>? _nullableFloatNullableList;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  double get floatVal {
    try {
      return _floatVal!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  double? get floatNullableVal {
    return _floatNullableVal;
  }
  
  List<double> get floatList {
    try {
      return _floatList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<double>? get floatNullableList {
    return _floatNullableList;
  }
  
  List<double> get nullableFloatList {
    try {
      return _nullableFloatList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<double>? get nullableFloatNullableList {
    return _nullableFloatNullableList;
  }
  
  const TestModel._internal({required this.id, required floatVal, floatNullableVal, required floatList, floatNullableList, required nullableFloatList, nullableFloatNullableList}): _floatVal = floatVal, _floatNullableVal = floatNullableVal, _floatList = floatList, _floatNullableList = floatNullableList, _nullableFloatList = nullableFloatList, _nullableFloatNullableList = nullableFloatNullableList;
  
  factory TestModel({String? id, required double floatVal, double? floatNullableVal, required List<double> floatList, List<double>? floatNullableList, required List<double> nullableFloatList, List<double>? nullableFloatNullableList}) {
    return TestModel._internal(
      id: id == null ? UUID.getUUID() : id,
      floatVal: floatVal,
      floatNullableVal: floatNullableVal,
      floatList: floatList != null ? List<double>.unmodifiable(floatList) : floatList,
      floatNullableList: floatNullableList != null ? List<double>.unmodifiable(floatNullableList) : floatNullableList,
      nullableFloatList: nullableFloatList != null ? List<double>.unmodifiable(nullableFloatList) : nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList != null ? List<double>.unmodifiable(nullableFloatNullableList) : nullableFloatNullableList);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestModel &&
      id == other.id &&
      _floatVal == other._floatVal &&
      _floatNullableVal == other._floatNullableVal &&
      DeepCollectionEquality().equals(_floatList, other._floatList) &&
      DeepCollectionEquality().equals(_floatNullableList, other._floatNullableList) &&
      DeepCollectionEquality().equals(_nullableFloatList, other._nullableFloatList) &&
      DeepCollectionEquality().equals(_nullableFloatNullableList, other._nullableFloatNullableList);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TestModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"floatVal=\\" + (_floatVal != null ? _floatVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableVal=\\" + (_floatNullableVal != null ? _floatNullableVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatList=\\" + (_floatList != null ? _floatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableList=\\" + (_floatNullableList != null ? _floatNullableList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatList=\\" + (_nullableFloatList != null ? _nullableFloatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatNullableList=\\" + (_nullableFloatNullableList != null ? _nullableFloatNullableList!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TestModel copyWith({String? id, double? floatVal, double? floatNullableVal, List<double>? floatList, List<double>? floatNullableList, List<double>? nullableFloatList, List<double>? nullableFloatNullableList}) {
    return TestModel(
      id: id ?? this.id,
      floatVal: floatVal ?? this.floatVal,
      floatNullableVal: floatNullableVal ?? this.floatNullableVal,
      floatList: floatList ?? this.floatList,
      floatNullableList: floatNullableList ?? this.floatNullableList,
      nullableFloatList: nullableFloatList ?? this.nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList ?? this.nullableFloatNullableList);
  }
  
  TestModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _floatVal = (json['floatVal'] as num?)?.toDouble(),
      _floatNullableVal = (json['floatNullableVal'] as num?)?.toDouble(),
      _floatList = (json['floatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _floatNullableList = (json['floatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatList = (json['nullableFloatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatNullableList = (json['nullableFloatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList();
  
  Map<String, dynamic> toJson() => {
    'id': id, 'floatVal': _floatVal, 'floatNullableVal': _floatNullableVal, 'floatList': _floatList, 'floatNullableList': _floatNullableList, 'nullableFloatList': _nullableFloatList, 'nullableFloatNullableList': _nullableFloatNullableList
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField FLOATVAL = QueryField(fieldName: \\"floatVal\\");
  static final QueryField FLOATNULLABLEVAL = QueryField(fieldName: \\"floatNullableVal\\");
  static final QueryField FLOATLIST = QueryField(fieldName: \\"floatList\\");
  static final QueryField FLOATNULLABLELIST = QueryField(fieldName: \\"floatNullableList\\");
  static final QueryField NULLABLEFLOATLIST = QueryField(fieldName: \\"nullableFloatList\\");
  static final QueryField NULLABLEFLOATNULLABLELIST = QueryField(fieldName: \\"nullableFloatNullableList\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestModel\\";
    modelSchemaDefinition.pluralName = \\"TestModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATVAL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLEVAL,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
  });
}

class _TestModelModelType extends ModelType<TestModel> {
  const _TestModelModelType();
  
  @override
  TestModel fromJson(Map<String, dynamic> jsonData) {
    return TestModel.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Null Safety Tests should generate correct null safe output for regular scalar/list fields 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the TestModel type in your schema. */
@immutable
class TestModel extends Model {
  static const classType = const _TestModelModelType();
  final String id;
  final double? _floatVal;
  final double? _floatNullableVal;
  final List<double>? _floatList;
  final List<double>? _floatNullableList;
  final List<double>? _nullableFloatList;
  final List<double>? _nullableFloatNullableList;
  final int? _intVal;
  final int? _intNullableVal;
  final List<int>? _intList;
  final List<int>? _intNullableList;
  final List<int>? _nullableIntList;
  final List<int>? _nullableIntNullableList;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  double get floatVal {
    try {
      return _floatVal!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  double? get floatNullableVal {
    return _floatNullableVal;
  }
  
  List<double> get floatList {
    try {
      return _floatList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<double>? get floatNullableList {
    return _floatNullableList;
  }
  
  List<double> get nullableFloatList {
    try {
      return _nullableFloatList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<double>? get nullableFloatNullableList {
    return _nullableFloatNullableList;
  }
  
  int get intVal {
    try {
      return _intVal!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  int? get intNullableVal {
    return _intNullableVal;
  }
  
  List<int> get intList {
    try {
      return _intList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<int>? get intNullableList {
    return _intNullableList;
  }
  
  List<int> get nullableIntList {
    try {
      return _nullableIntList!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<int>? get nullableIntNullableList {
    return _nullableIntNullableList;
  }
  
  const TestModel._internal({required this.id, required floatVal, floatNullableVal, required floatList, floatNullableList, required nullableFloatList, nullableFloatNullableList, required intVal, intNullableVal, required intList, intNullableList, required nullableIntList, nullableIntNullableList}): _floatVal = floatVal, _floatNullableVal = floatNullableVal, _floatList = floatList, _floatNullableList = floatNullableList, _nullableFloatList = nullableFloatList, _nullableFloatNullableList = nullableFloatNullableList, _intVal = intVal, _intNullableVal = intNullableVal, _intList = intList, _intNullableList = intNullableList, _nullableIntList = nullableIntList, _nullableIntNullableList = nullableIntNullableList;
  
  factory TestModel({String? id, required double floatVal, double? floatNullableVal, required List<double> floatList, List<double>? floatNullableList, required List<double> nullableFloatList, List<double>? nullableFloatNullableList, required int intVal, int? intNullableVal, required List<int> intList, List<int>? intNullableList, required List<int> nullableIntList, List<int>? nullableIntNullableList}) {
    return TestModel._internal(
      id: id == null ? UUID.getUUID() : id,
      floatVal: floatVal,
      floatNullableVal: floatNullableVal,
      floatList: floatList != null ? List<double>.unmodifiable(floatList) : floatList,
      floatNullableList: floatNullableList != null ? List<double>.unmodifiable(floatNullableList) : floatNullableList,
      nullableFloatList: nullableFloatList != null ? List<double>.unmodifiable(nullableFloatList) : nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList != null ? List<double>.unmodifiable(nullableFloatNullableList) : nullableFloatNullableList,
      intVal: intVal,
      intNullableVal: intNullableVal,
      intList: intList != null ? List<int>.unmodifiable(intList) : intList,
      intNullableList: intNullableList != null ? List<int>.unmodifiable(intNullableList) : intNullableList,
      nullableIntList: nullableIntList != null ? List<int>.unmodifiable(nullableIntList) : nullableIntList,
      nullableIntNullableList: nullableIntNullableList != null ? List<int>.unmodifiable(nullableIntNullableList) : nullableIntNullableList);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TestModel &&
      id == other.id &&
      _floatVal == other._floatVal &&
      _floatNullableVal == other._floatNullableVal &&
      DeepCollectionEquality().equals(_floatList, other._floatList) &&
      DeepCollectionEquality().equals(_floatNullableList, other._floatNullableList) &&
      DeepCollectionEquality().equals(_nullableFloatList, other._nullableFloatList) &&
      DeepCollectionEquality().equals(_nullableFloatNullableList, other._nullableFloatNullableList) &&
      _intVal == other._intVal &&
      _intNullableVal == other._intNullableVal &&
      DeepCollectionEquality().equals(_intList, other._intList) &&
      DeepCollectionEquality().equals(_intNullableList, other._intNullableList) &&
      DeepCollectionEquality().equals(_nullableIntList, other._nullableIntList) &&
      DeepCollectionEquality().equals(_nullableIntNullableList, other._nullableIntNullableList);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"TestModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"floatVal=\\" + (_floatVal != null ? _floatVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableVal=\\" + (_floatNullableVal != null ? _floatNullableVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatList=\\" + (_floatList != null ? _floatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"floatNullableList=\\" + (_floatNullableList != null ? _floatNullableList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatList=\\" + (_nullableFloatList != null ? _nullableFloatList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableFloatNullableList=\\" + (_nullableFloatNullableList != null ? _nullableFloatNullableList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intVal=\\" + (_intVal != null ? _intVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intNullableVal=\\" + (_intNullableVal != null ? _intNullableVal!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intList=\\" + (_intList != null ? _intList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"intNullableList=\\" + (_intNullableList != null ? _intNullableList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableIntList=\\" + (_nullableIntList != null ? _nullableIntList!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"nullableIntNullableList=\\" + (_nullableIntNullableList != null ? _nullableIntNullableList!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  TestModel copyWith({String? id, double? floatVal, double? floatNullableVal, List<double>? floatList, List<double>? floatNullableList, List<double>? nullableFloatList, List<double>? nullableFloatNullableList, int? intVal, int? intNullableVal, List<int>? intList, List<int>? intNullableList, List<int>? nullableIntList, List<int>? nullableIntNullableList}) {
    return TestModel(
      id: id ?? this.id,
      floatVal: floatVal ?? this.floatVal,
      floatNullableVal: floatNullableVal ?? this.floatNullableVal,
      floatList: floatList ?? this.floatList,
      floatNullableList: floatNullableList ?? this.floatNullableList,
      nullableFloatList: nullableFloatList ?? this.nullableFloatList,
      nullableFloatNullableList: nullableFloatNullableList ?? this.nullableFloatNullableList,
      intVal: intVal ?? this.intVal,
      intNullableVal: intNullableVal ?? this.intNullableVal,
      intList: intList ?? this.intList,
      intNullableList: intNullableList ?? this.intNullableList,
      nullableIntList: nullableIntList ?? this.nullableIntList,
      nullableIntNullableList: nullableIntNullableList ?? this.nullableIntNullableList);
  }
  
  TestModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _floatVal = (json['floatVal'] as num?)?.toDouble(),
      _floatNullableVal = (json['floatNullableVal'] as num?)?.toDouble(),
      _floatList = (json['floatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _floatNullableList = (json['floatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatList = (json['nullableFloatList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _nullableFloatNullableList = (json['nullableFloatNullableList'] as List?)?.map((e) => (e as num).toDouble()).toList(),
      _intVal = (json['intVal'] as num?)?.toInt(),
      _intNullableVal = (json['intNullableVal'] as num?)?.toInt(),
      _intList = (json['intList'] as List?)?.map((e) => (e as num).toInt()).toList(),
      _intNullableList = (json['intNullableList'] as List?)?.map((e) => (e as num).toInt()).toList(),
      _nullableIntList = (json['nullableIntList'] as List?)?.map((e) => (e as num).toInt()).toList(),
      _nullableIntNullableList = (json['nullableIntNullableList'] as List?)?.map((e) => (e as num).toInt()).toList();
  
  Map<String, dynamic> toJson() => {
    'id': id, 'floatVal': _floatVal, 'floatNullableVal': _floatNullableVal, 'floatList': _floatList, 'floatNullableList': _floatNullableList, 'nullableFloatList': _nullableFloatList, 'nullableFloatNullableList': _nullableFloatNullableList, 'intVal': _intVal, 'intNullableVal': _intNullableVal, 'intList': _intList, 'intNullableList': _intNullableList, 'nullableIntList': _nullableIntList, 'nullableIntNullableList': _nullableIntNullableList
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField FLOATVAL = QueryField(fieldName: \\"floatVal\\");
  static final QueryField FLOATNULLABLEVAL = QueryField(fieldName: \\"floatNullableVal\\");
  static final QueryField FLOATLIST = QueryField(fieldName: \\"floatList\\");
  static final QueryField FLOATNULLABLELIST = QueryField(fieldName: \\"floatNullableList\\");
  static final QueryField NULLABLEFLOATLIST = QueryField(fieldName: \\"nullableFloatList\\");
  static final QueryField NULLABLEFLOATNULLABLELIST = QueryField(fieldName: \\"nullableFloatNullableList\\");
  static final QueryField INTVAL = QueryField(fieldName: \\"intVal\\");
  static final QueryField INTNULLABLEVAL = QueryField(fieldName: \\"intNullableVal\\");
  static final QueryField INTLIST = QueryField(fieldName: \\"intList\\");
  static final QueryField INTNULLABLELIST = QueryField(fieldName: \\"intNullableList\\");
  static final QueryField NULLABLEINTLIST = QueryField(fieldName: \\"nullableIntList\\");
  static final QueryField NULLABLEINTNULLABLELIST = QueryField(fieldName: \\"nullableIntNullableList\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"TestModel\\";
    modelSchemaDefinition.pluralName = \\"TestModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATVAL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLEVAL,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.double)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.FLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEFLOATNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.double))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.INTVAL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.INTNULLABLEVAL,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.INTLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.int))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.INTNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.int))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEINTLIST,
      isRequired: true,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.int))
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: TestModel.NULLABLEINTNULLABLELIST,
      isRequired: false,
      isArray: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum.int))
    ));
  });
}

class _TestModelModelType extends ModelType<TestModel> {
  const _TestModelModelType();
  
  @override
  TestModel fromJson(Map<String, dynamic> jsonData) {
    return TestModel.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor Read-only Field Tests should generate the read-only timestamp fields when isTimestampFields is true 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';

/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String name;
  final TemporalDateTime createdAt;
  final TemporalDateTime updatedAt;

  @override
  getInstanceType() => classType;

  @override
  String getId() {
    return id;
  }

  const SimpleModel._internal(
      {@required this.id, this.name, this.createdAt, this.updatedAt});

  factory SimpleModel({String id, String name}) {
    return SimpleModel._internal(
        id: id == null ? UUID.getUUID() : id, name: name);
  }

  bool equals(Object other) {
    return this == other;
  }

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel && id == other.id && name == other.name;
  }

  @override
  int get hashCode => toString().hashCode;

  @override
  String toString() {
    var buffer = new StringBuffer();

    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$name\\" + \\", \\");
    buffer.write(\\"createdAt=\\" +
        (createdAt != null ? createdAt.format() : \\"null\\") +
        \\", \\");
    buffer.write(
        \\"updatedAt=\\" + (updatedAt != null ? updatedAt.format() : \\"null\\"));
    buffer.write(\\"}\\");

    return buffer.toString();
  }

  SimpleModel copyWith({String id, String name}) {
    return SimpleModel._internal(id: id ?? this.id, name: name ?? this.name);
  }

  SimpleModel.fromJson(Map<String, dynamic> json)
      : id = json['id'],
        name = json['name'],
        createdAt = json['createdAt'] != null
            ? TemporalDateTime.fromString(json['createdAt'])
            : null,
        updatedAt = json['updatedAt'] != null
            ? TemporalDateTime.fromString(json['updatedAt'])
            : null;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'createdAt': createdAt?.format(),
        'updatedAt': updatedAt?.format()
      };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static var schema =
      Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";

    modelSchemaDefinition.addField(ModelFieldDefinition.id());

    modelSchemaDefinition.addField(ModelFieldDefinition.field(
        key: SimpleModel.NAME,
        isRequired: false,
        ofType: ModelFieldType(ModelFieldTypeEnum.string)));

    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
        fieldName: 'createdAt',
        isRequired: false,
        isReadOnly: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)));

    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
        fieldName: 'updatedAt',
        isRequired: false,
        isReadOnly: true,
        ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();

  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
}
"
`;

exports[`AppSync Dart Visitor Read-only and Null Safety Combined Tests should generate the read-only timestamp fields when isTimestampFields is true and with null safety 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the SimpleModel type in your schema. */
@immutable
class SimpleModel extends Model {
  static const classType = const _SimpleModelModelType();
  final String id;
  final String? _name;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const SimpleModel._internal({required this.id, name, createdAt, updatedAt}): _name = name, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory SimpleModel({String? id, String? name}) {
    return SimpleModel._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SimpleModel &&
      id == other.id &&
      _name == other._name;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"SimpleModel {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  SimpleModel copyWith({String? id, String? name}) {
    return SimpleModel._internal(
      id: id ?? this.id,
      name: name ?? this.name);
  }
  
  SimpleModel.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };

  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"SimpleModel\\";
    modelSchemaDefinition.pluralName = \\"SimpleModels\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: SimpleModel.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _SimpleModelModelType extends ModelType<SimpleModel> {
  const _SimpleModelModelType();
  
  @override
  SimpleModel fromJson(Map<String, dynamic> jsonData) {
    return SimpleModel.fromJson(jsonData);
  }
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct model and helper class for model that is NOT using custom primary key 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the ModelWithImplicitID type in your schema. */
@immutable
class ModelWithImplicitID extends Model {
  static const classType = const _ModelWithImplicitIDModelType();
  final String id;
  final String? _title;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  ModelWithImplicitIDModelIdentifier get modelIdentifier {
      return ModelWithImplicitIDModelIdentifier(
        id: id
      );
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const ModelWithImplicitID._internal({required this.id, required title, createdAt, updatedAt}): _title = title, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory ModelWithImplicitID({String? id, required String title}) {
    return ModelWithImplicitID._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ModelWithImplicitID &&
      id == other.id &&
      _title == other._title;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"ModelWithImplicitID {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  ModelWithImplicitID copyWith({String? title}) {
    return ModelWithImplicitID._internal(
      id: id,
      title: title ?? this.title);
  }
  
  ModelWithImplicitID.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };

  static final QueryModelIdentifier<ModelWithImplicitIDModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ModelWithImplicitIDModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"ModelWithImplicitID\\";
    modelSchemaDefinition.pluralName = \\"ModelWithImplicitIDS\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithImplicitID.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _ModelWithImplicitIDModelType extends ModelType<ModelWithImplicitID> {
  const _ModelWithImplicitIDModelType();
  
  @override
  ModelWithImplicitID fromJson(Map<String, dynamic> jsonData) {
    return ModelWithImplicitID.fromJson(jsonData);
  }
}

/** 
 * This is an auto generated class representing the model identifier
 * of [ModelWithImplicitID] in your schema.
 */
@immutable
class ModelWithImplicitIDModelIdentifier implements ModelIdentifier<ModelWithImplicitID> {
  final String id;

  /** Create an instance of ModelWithImplicitIDModelIdentifier using [id] the primary key. */
  const ModelWithImplicitIDModelIdentifier({
    required this.id});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ModelWithImplicitIDModelIdentifier(id: $id)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ModelWithImplicitIDModelIdentifier &&
      id == other.id;
  }
  
  @override
  int get hashCode =>
    id.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct model and helper class for model that is NOT using custom primary key 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the ModelWithExplicitID type in your schema. */
@immutable
class ModelWithExplicitID extends Model {
  static const classType = const _ModelWithExplicitIDModelType();
  final String id;
  final String? _title;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  ModelWithExplicitIDModelIdentifier get modelIdentifier {
      return ModelWithExplicitIDModelIdentifier(
        id: id
      );
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const ModelWithExplicitID._internal({required this.id, required title, createdAt, updatedAt}): _title = title, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory ModelWithExplicitID({String? id, required String title}) {
    return ModelWithExplicitID._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ModelWithExplicitID &&
      id == other.id &&
      _title == other._title;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"ModelWithExplicitID {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  ModelWithExplicitID copyWith({String? title}) {
    return ModelWithExplicitID._internal(
      id: id,
      title: title ?? this.title);
  }
  
  ModelWithExplicitID.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };

  static final QueryModelIdentifier<ModelWithExplicitIDModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ModelWithExplicitIDModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"ModelWithExplicitID\\";
    modelSchemaDefinition.pluralName = \\"ModelWithExplicitIDS\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitID.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _ModelWithExplicitIDModelType extends ModelType<ModelWithExplicitID> {
  const _ModelWithExplicitIDModelType();
  
  @override
  ModelWithExplicitID fromJson(Map<String, dynamic> jsonData) {
    return ModelWithExplicitID.fromJson(jsonData);
  }
}

/** 
 * This is an auto generated class representing the model identifier
 * of [ModelWithExplicitID] in your schema.
 */
@immutable
class ModelWithExplicitIDModelIdentifier implements ModelIdentifier<ModelWithExplicitID> {
  final String id;

  /** Create an instance of ModelWithExplicitIDModelIdentifier using [id] the primary key. */
  const ModelWithExplicitIDModelIdentifier({
    required this.id});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ModelWithExplicitIDModelIdentifier(id: $id)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ModelWithExplicitIDModelIdentifier &&
      id == other.id;
  }
  
  @override
  int get hashCode =>
    id.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct model and helper class for model that is NOT using custom primary key 3`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the ModelWithExplicitIDAndSDI type in your schema. */
@immutable
class ModelWithExplicitIDAndSDI extends Model {
  static const classType = const _ModelWithExplicitIDAndSDIModelType();
  final String id;
  final String? _parentID;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  ModelWithExplicitIDAndSDIModelIdentifier get modelIdentifier {
      return ModelWithExplicitIDAndSDIModelIdentifier(
        id: id
      );
  }
  
  String? get parentID {
    return _parentID;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const ModelWithExplicitIDAndSDI._internal({required this.id, parentID, createdAt, updatedAt}): _parentID = parentID, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory ModelWithExplicitIDAndSDI({String? id, String? parentID}) {
    return ModelWithExplicitIDAndSDI._internal(
      id: id == null ? UUID.getUUID() : id,
      parentID: parentID);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ModelWithExplicitIDAndSDI &&
      id == other.id &&
      _parentID == other._parentID;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"ModelWithExplicitIDAndSDI {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"parentID=\\" + \\"$_parentID\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  ModelWithExplicitIDAndSDI copyWith({String? parentID}) {
    return ModelWithExplicitIDAndSDI._internal(
      id: id,
      parentID: parentID ?? this.parentID);
  }
  
  ModelWithExplicitIDAndSDI.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _parentID = json['parentID'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'parentID': _parentID, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };

  static final QueryModelIdentifier<ModelWithExplicitIDAndSDIModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ModelWithExplicitIDAndSDIModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField PARENTID = QueryField(fieldName: \\"parentID\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"ModelWithExplicitIDAndSDI\\";
    modelSchemaDefinition.pluralName = \\"ModelWithExplicitIDAndSDIS\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"parentID\\"], name: \\"byParent\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitIDAndSDI.PARENTID,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _ModelWithExplicitIDAndSDIModelType extends ModelType<ModelWithExplicitIDAndSDI> {
  const _ModelWithExplicitIDAndSDIModelType();
  
  @override
  ModelWithExplicitIDAndSDI fromJson(Map<String, dynamic> jsonData) {
    return ModelWithExplicitIDAndSDI.fromJson(jsonData);
  }
}

/** 
 * This is an auto generated class representing the model identifier
 * of [ModelWithExplicitIDAndSDI] in your schema.
 */
@immutable
class ModelWithExplicitIDAndSDIModelIdentifier implements ModelIdentifier<ModelWithExplicitIDAndSDI> {
  final String id;

  /** Create an instance of ModelWithExplicitIDAndSDIModelIdentifier using [id] the primary key. */
  const ModelWithExplicitIDAndSDIModelIdentifier({
    required this.id});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ModelWithExplicitIDAndSDIModelIdentifier(id: $id)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ModelWithExplicitIDAndSDIModelIdentifier &&
      id == other.id;
  }
  
  @override
  int get hashCode =>
    id.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct model and helper class for model that is using \`id\` field as primary key plus sort keys 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the ModelWithIDPlusSortKeys type in your schema. */
@immutable
class ModelWithIDPlusSortKeys extends Model {
  static const classType = const _ModelWithIDPlusSortKeysModelType();
  final String id;
  final String? _title;
  final int? _rating;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  ModelWithIDPlusSortKeysModelIdentifier get modelIdentifier {
    try {
      return ModelWithIDPlusSortKeysModelIdentifier(
        id: id,
        title: _title!,
        rating: _rating!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  int get rating {
    try {
      return _rating!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const ModelWithIDPlusSortKeys._internal({required this.id, required title, required rating, createdAt, updatedAt}): _title = title, _rating = rating, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory ModelWithIDPlusSortKeys({String? id, required String title, required int rating}) {
    return ModelWithIDPlusSortKeys._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      rating: rating);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ModelWithIDPlusSortKeys &&
      id == other.id &&
      _title == other._title &&
      _rating == other._rating;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"ModelWithIDPlusSortKeys {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"rating=\\" + (_rating != null ? _rating!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  ModelWithIDPlusSortKeys copyWith() {
    return ModelWithIDPlusSortKeys._internal(
      id: id,
      title: title,
      rating: rating);
  }
  
  ModelWithIDPlusSortKeys.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _rating = (json['rating'] as num?)?.toInt(),
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'rating': _rating, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };

  static final QueryModelIdentifier<ModelWithIDPlusSortKeysModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ModelWithIDPlusSortKeysModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField RATING = QueryField(fieldName: \\"rating\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"ModelWithIDPlusSortKeys\\";
    modelSchemaDefinition.pluralName = \\"ModelWithIDPlusSortKeys\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"id\\", \\"title\\", \\"rating\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithIDPlusSortKeys.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithIDPlusSortKeys.RATING,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _ModelWithIDPlusSortKeysModelType extends ModelType<ModelWithIDPlusSortKeys> {
  const _ModelWithIDPlusSortKeysModelType();
  
  @override
  ModelWithIDPlusSortKeys fromJson(Map<String, dynamic> jsonData) {
    return ModelWithIDPlusSortKeys.fromJson(jsonData);
  }
}

/** 
 * This is an auto generated class representing the model identifier
 * of [ModelWithIDPlusSortKeys] in your schema.
 */
@immutable
class ModelWithIDPlusSortKeysModelIdentifier implements ModelIdentifier<ModelWithIDPlusSortKeys> {
  final String id;
  final String title;
  final int rating;

  /** 
   * Create an instance of ModelWithIDPlusSortKeysModelIdentifier using [id] the primary key.
   * And [title], [rating] the sort keys.
   */
  const ModelWithIDPlusSortKeysModelIdentifier({
    required this.id,
    required this.title,
    required this.rating});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id,
    'title': title,
    'rating': rating
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ModelWithIDPlusSortKeysModelIdentifier(id: $id, title: $title, rating: $rating)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ModelWithIDPlusSortKeysModelIdentifier &&
      id == other.id &&
      title == other.title &&
      rating == other.rating;
  }
  
  @override
  int get hashCode =>
    id.hashCode ^
    title.hashCode ^
    rating.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct model and helper class for model that is using custom primary key 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the ModelWithExplicitlyDefinedPK type in your schema. */
@immutable
class ModelWithExplicitlyDefinedPK extends Model {
  static const classType = const _ModelWithExplicitlyDefinedPKModelType();
  final String? _modelID;
  final String? _title;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => modelIdentifier.serializeAsString();
  
  ModelWithExplicitlyDefinedPKModelIdentifier get modelIdentifier {
    try {
      return ModelWithExplicitlyDefinedPKModelIdentifier(
        modelID: _modelID!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get modelID {
    try {
      return _modelID!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const ModelWithExplicitlyDefinedPK._internal({required modelID, required title, createdAt, updatedAt}): _modelID = modelID, _title = title, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory ModelWithExplicitlyDefinedPK({required String modelID, required String title}) {
    return ModelWithExplicitlyDefinedPK._internal(
      modelID: modelID,
      title: title);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ModelWithExplicitlyDefinedPK &&
      _modelID == other._modelID &&
      _title == other._title;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"ModelWithExplicitlyDefinedPK {\\");
    buffer.write(\\"modelID=\\" + \\"$_modelID\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  ModelWithExplicitlyDefinedPK copyWith({String? title}) {
    return ModelWithExplicitlyDefinedPK._internal(
      modelID: modelID,
      title: title ?? this.title);
  }
  
  ModelWithExplicitlyDefinedPK.fromJson(Map<String, dynamic> json)  
    : _modelID = json['modelID'],
      _title = json['title'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'modelID': _modelID, 'title': _title, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };

  static final QueryModelIdentifier<ModelWithExplicitlyDefinedPKModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ModelWithExplicitlyDefinedPKModelIdentifier>();
  static final QueryField MODELID = QueryField(fieldName: \\"modelID\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"ModelWithExplicitlyDefinedPK\\";
    modelSchemaDefinition.pluralName = \\"ModelWithExplicitlyDefinedPKS\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"modelID\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitlyDefinedPK.MODELID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitlyDefinedPK.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _ModelWithExplicitlyDefinedPKModelType extends ModelType<ModelWithExplicitlyDefinedPK> {
  const _ModelWithExplicitlyDefinedPKModelType();
  
  @override
  ModelWithExplicitlyDefinedPK fromJson(Map<String, dynamic> jsonData) {
    return ModelWithExplicitlyDefinedPK.fromJson(jsonData);
  }
}

/** 
 * This is an auto generated class representing the model identifier
 * of [ModelWithExplicitlyDefinedPK] in your schema.
 */
@immutable
class ModelWithExplicitlyDefinedPKModelIdentifier implements ModelIdentifier<ModelWithExplicitlyDefinedPK> {
  final String modelID;

  /** Create an instance of ModelWithExplicitlyDefinedPKModelIdentifier using [modelID] the primary key. */
  const ModelWithExplicitlyDefinedPKModelIdentifier({
    required this.modelID});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'modelID': modelID
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ModelWithExplicitlyDefinedPKModelIdentifier(modelID: $modelID)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ModelWithExplicitlyDefinedPKModelIdentifier &&
      modelID == other.modelID;
  }
  
  @override
  int get hashCode =>
    modelID.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct model and helper class for model that is using custom primary key 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey type in your schema. */
@immutable
class ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey extends Model {
  static const classType = const _ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelType();
  final String? _modelID;
  final String? _title;
  final int? _rating;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => modelIdentifier.serializeAsString();
  
  ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier get modelIdentifier {
    try {
      return ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier(
        modelID: _modelID!,
        title: _title!,
        rating: _rating!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get modelID {
    try {
      return _modelID!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  int get rating {
    try {
      return _rating!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey._internal({required modelID, required title, required rating, createdAt, updatedAt}): _modelID = modelID, _title = title, _rating = rating, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey({required String modelID, required String title, required int rating}) {
    return ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey._internal(
      modelID: modelID,
      title: title,
      rating: rating);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey &&
      _modelID == other._modelID &&
      _title == other._title &&
      _rating == other._rating;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey {\\");
    buffer.write(\\"modelID=\\" + \\"$_modelID\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"rating=\\" + (_rating != null ? _rating!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey copyWith() {
    return ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey._internal(
      modelID: modelID,
      title: title,
      rating: rating);
  }
  
  ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey.fromJson(Map<String, dynamic> json)  
    : _modelID = json['modelID'],
      _title = json['title'],
      _rating = (json['rating'] as num?)?.toInt(),
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'modelID': _modelID, 'title': _title, 'rating': _rating, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };

  static final QueryModelIdentifier<ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier>();
  static final QueryField MODELID = QueryField(fieldName: \\"modelID\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField RATING = QueryField(fieldName: \\"rating\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey\\";
    modelSchemaDefinition.pluralName = \\"ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeys\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"modelID\\", \\"title\\", \\"rating\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey.MODELID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey.RATING,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.int)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelType extends ModelType<ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey> {
  const _ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelType();
  
  @override
  ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey fromJson(Map<String, dynamic> jsonData) {
    return ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey.fromJson(jsonData);
  }
}

/** 
 * This is an auto generated class representing the model identifier
 * of [ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey] in your schema.
 */
@immutable
class ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier implements ModelIdentifier<ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKey> {
  final String modelID;
  final String title;
  final int rating;

  /** 
   * Create an instance of ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier using [modelID] the primary key.
   * And [title], [rating] the sort keys.
   */
  const ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier({
    required this.modelID,
    required this.title,
    required this.rating});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'modelID': modelID,
    'title': title,
    'rating': rating
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier(modelID: $modelID, title: $title, rating: $rating)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ModelWithExplicitlyDefinedPKPlusSortKeysAsCompositeKeyModelIdentifier &&
      modelID == other.modelID &&
      title == other.title &&
      rating == other.rating;
  }
  
  @override
  int get hashCode =>
    modelID.hashCode ^
    title.hashCode ^
    rating.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct models for hasMany uni relation when custom PK is enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final List<Comment>? _comments;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  PostModelIdentifier get modelIdentifier {
    try {
      return PostModelIdentifier(
        id: id,
        title: _title!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Comment>? get comments {
    return _comments;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const Post._internal({required this.id, required title, comments, createdAt, updatedAt}): _title = title, _comments = comments, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory Post({String? id, required String title, List<Comment>? comments}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      comments: comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({List<Comment>? comments}) {
    return Post._internal(
      id: id,
      title: title,
      comments: comments ?? this.comments);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null,
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'comments': _comments?.map((Comment? e) => e?.toJson()).toList(), 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };

  static final QueryModelIdentifier<PostModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<PostModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Comment).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"id\\", \\"title\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.COMMENTS,
      isRequired: false,
      ofModelName: (Comment).toString(),
      associatedKey: Comment.POSTCOMMENTSID
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}

/** 
 * This is an auto generated class representing the model identifier
 * of [Post] in your schema.
 */
@immutable
class PostModelIdentifier implements ModelIdentifier<Post> {
  final String id;
  final String title;

  /** 
   * Create an instance of PostModelIdentifier using [id] the primary key.
   * And [title] the sort key.
   */
  const PostModelIdentifier({
    required this.id,
    required this.title});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id,
    'title': title
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'PostModelIdentifier(id: $id, title: $title)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is PostModelIdentifier &&
      id == other.id &&
      title == other.title;
  }
  
  @override
  int get hashCode =>
    id.hashCode ^
    title.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct models for hasMany uni relation when custom PK is enabled 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final String? _content;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;
  final String? _postCommentsId;
  final String? _postCommentsTitle;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  CommentModelIdentifier get modelIdentifier {
    try {
      return CommentModelIdentifier(
        id: id,
        content: _content!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get content {
    try {
      return _content!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  String? get postCommentsId {
    return _postCommentsId;
  }
  
  String? get postCommentsTitle {
    return _postCommentsTitle;
  }
  
  const Comment._internal({required this.id, required content, createdAt, updatedAt, postCommentsId, postCommentsTitle}): _content = content, _createdAt = createdAt, _updatedAt = updatedAt, _postCommentsId = postCommentsId, _postCommentsTitle = postCommentsTitle;
  
  factory Comment({String? id, required String content, String? postCommentsId, String? postCommentsTitle}) {
    return Comment._internal(
      id: id == null ? UUID.getUUID() : id,
      content: content,
      postCommentsId: postCommentsId,
      postCommentsTitle: postCommentsTitle);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
      id == other.id &&
      _content == other._content &&
      _postCommentsId == other._postCommentsId &&
      _postCommentsTitle == other._postCommentsTitle;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"postCommentsId=\\" + \\"$_postCommentsId\\" + \\", \\");
    buffer.write(\\"postCommentsTitle=\\" + \\"$_postCommentsTitle\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment copyWith({String? postCommentsId, String? postCommentsTitle}) {
    return Comment._internal(
      id: id,
      content: content,
      postCommentsId: postCommentsId ?? this.postCommentsId,
      postCommentsTitle: postCommentsTitle ?? this.postCommentsTitle);
  }
  
  Comment.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _content = json['content'],
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null,
      _postCommentsId = json['postCommentsId'],
      _postCommentsTitle = json['postCommentsTitle'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'content': _content, 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format(), 'postCommentsId': _postCommentsId, 'postCommentsTitle': _postCommentsTitle
  };

  static final QueryModelIdentifier<CommentModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<CommentModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static final QueryField POSTCOMMENTSID = QueryField(fieldName: \\"postCommentsId\\");
  static final QueryField POSTCOMMENTSTITLE = QueryField(fieldName: \\"postCommentsTitle\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"id\\", \\"content\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.CONTENT,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.POSTCOMMENTSID,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.POSTCOMMENTSTITLE,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();
  
  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
}

/** 
 * This is an auto generated class representing the model identifier
 * of [Comment] in your schema.
 */
@immutable
class CommentModelIdentifier implements ModelIdentifier<Comment> {
  final String id;
  final String content;

  /** 
   * Create an instance of CommentModelIdentifier using [id] the primary key.
   * And [content] the sort key.
   */
  const CommentModelIdentifier({
    required this.id,
    required this.content});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id,
    'content': content
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'CommentModelIdentifier(id: $id, content: $content)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is CommentModelIdentifier &&
      id == other.id &&
      content == other.content;
  }
  
  @override
  int get hashCode =>
    id.hashCode ^
    content.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct models for hasOne/belongsTo relation when custom PK is enabled 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Project type in your schema. */
@immutable
class Project extends Model {
  static const classType = const _ProjectModelType();
  final String? _projectId;
  final String? _name;
  final Team? _team;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;
  final String? _projectTeamTeamId;
  final String? _projectTeamName;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => modelIdentifier.serializeAsString();
  
  ProjectModelIdentifier get modelIdentifier {
    try {
      return ProjectModelIdentifier(
        projectId: _projectId!,
        name: _name!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get projectId {
    try {
      return _projectId!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Team? get team {
    return _team;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  String? get projectTeamTeamId {
    return _projectTeamTeamId;
  }
  
  String? get projectTeamName {
    return _projectTeamName;
  }
  
  const Project._internal({required projectId, required name, team, createdAt, updatedAt, projectTeamTeamId, projectTeamName}): _projectId = projectId, _name = name, _team = team, _createdAt = createdAt, _updatedAt = updatedAt, _projectTeamTeamId = projectTeamTeamId, _projectTeamName = projectTeamName;
  
  factory Project({required String projectId, required String name, Team? team, String? projectTeamTeamId, String? projectTeamName}) {
    return Project._internal(
      projectId: projectId,
      name: name,
      team: team,
      projectTeamTeamId: projectTeamTeamId,
      projectTeamName: projectTeamName);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Project &&
      _projectId == other._projectId &&
      _name == other._name &&
      _team == other._team &&
      _projectTeamTeamId == other._projectTeamTeamId &&
      _projectTeamName == other._projectTeamName;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Project {\\");
    buffer.write(\\"projectId=\\" + \\"$_projectId\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"projectTeamTeamId=\\" + \\"$_projectTeamTeamId\\" + \\", \\");
    buffer.write(\\"projectTeamName=\\" + \\"$_projectTeamName\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Project copyWith({Team? team, String? projectTeamTeamId, String? projectTeamName}) {
    return Project._internal(
      projectId: projectId,
      name: name,
      team: team ?? this.team,
      projectTeamTeamId: projectTeamTeamId ?? this.projectTeamTeamId,
      projectTeamName: projectTeamName ?? this.projectTeamName);
  }
  
  Project.fromJson(Map<String, dynamic> json)  
    : _projectId = json['projectId'],
      _name = json['name'],
      _team = json['team']?['serializedData'] != null
        ? Team.fromJson(new Map<String, dynamic>.from(json['team']['serializedData']))
        : null,
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null,
      _projectTeamTeamId = json['projectTeamTeamId'],
      _projectTeamName = json['projectTeamName'];
  
  Map<String, dynamic> toJson() => {
    'projectId': _projectId, 'name': _name, 'team': _team?.toJson(), 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format(), 'projectTeamTeamId': _projectTeamTeamId, 'projectTeamName': _projectTeamName
  };

  static final QueryModelIdentifier<ProjectModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ProjectModelIdentifier>();
  static final QueryField PROJECTID = QueryField(fieldName: \\"projectId\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField TEAM = QueryField(
    fieldName: \\"team\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Team).toString()));
  static final QueryField PROJECTTEAMTEAMID = QueryField(fieldName: \\"projectTeamTeamId\\");
  static final QueryField PROJECTTEAMNAME = QueryField(fieldName: \\"projectTeamName\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Project\\";
    modelSchemaDefinition.pluralName = \\"Projects\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"projectId\\", \\"name\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project.PROJECTID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasOne(
      key: Project.TEAM,
      isRequired: false,
      ofModelName: (Team).toString(),
      associatedKey: Team.PROJECT
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project.PROJECTTEAMTEAMID,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project.PROJECTTEAMNAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _ProjectModelType extends ModelType<Project> {
  const _ProjectModelType();
  
  @override
  Project fromJson(Map<String, dynamic> jsonData) {
    return Project.fromJson(jsonData);
  }
}

/** 
 * This is an auto generated class representing the model identifier
 * of [Project] in your schema.
 */
@immutable
class ProjectModelIdentifier implements ModelIdentifier<Project> {
  final String projectId;
  final String name;

  /** 
   * Create an instance of ProjectModelIdentifier using [projectId] the primary key.
   * And [name] the sort key.
   */
  const ProjectModelIdentifier({
    required this.projectId,
    required this.name});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'projectId': projectId,
    'name': name
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'ProjectModelIdentifier(projectId: $projectId, name: $name)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is ProjectModelIdentifier &&
      projectId == other.projectId &&
      name == other.name;
  }
  
  @override
  int get hashCode =>
    projectId.hashCode ^
    name.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct models for hasOne/belongsTo relation when custom PK is enabled 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Team type in your schema. */
@immutable
class Team extends Model {
  static const classType = const _TeamModelType();
  final String? _teamId;
  final String? _name;
  final Project? _project;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => modelIdentifier.serializeAsString();
  
  TeamModelIdentifier get modelIdentifier {
    try {
      return TeamModelIdentifier(
        teamId: _teamId!,
        name: _name!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get teamId {
    try {
      return _teamId!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Project? get project {
    return _project;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const Team._internal({required teamId, required name, project, createdAt, updatedAt}): _teamId = teamId, _name = name, _project = project, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory Team({required String teamId, required String name, Project? project}) {
    return Team._internal(
      teamId: teamId,
      name: name,
      project: project);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Team &&
      _teamId == other._teamId &&
      _name == other._name &&
      _project == other._project;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Team {\\");
    buffer.write(\\"teamId=\\" + \\"$_teamId\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"project=\\" + (_project != null ? _project!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Team copyWith({Project? project}) {
    return Team._internal(
      teamId: teamId,
      name: name,
      project: project ?? this.project);
  }
  
  Team.fromJson(Map<String, dynamic> json)  
    : _teamId = json['teamId'],
      _name = json['name'],
      _project = json['project']?['serializedData'] != null
        ? Project.fromJson(new Map<String, dynamic>.from(json['project']['serializedData']))
        : null,
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'teamId': _teamId, 'name': _name, 'project': _project?.toJson(), 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };

  static final QueryModelIdentifier<TeamModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<TeamModelIdentifier>();
  static final QueryField TEAMID = QueryField(fieldName: \\"teamId\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField PROJECT = QueryField(
    fieldName: \\"project\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Project).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Team\\";
    modelSchemaDefinition.pluralName = \\"Teams\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"teamId\\", \\"name\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Team.TEAMID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Team.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Team.PROJECT,
      isRequired: false,
      targetNames: [\\"teamProjectProjectId\\", \\"teamProjectName\\"],
      ofModelName: (Project).toString()
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _TeamModelType extends ModelType<Team> {
  const _TeamModelType();
  
  @override
  Team fromJson(Map<String, dynamic> jsonData) {
    return Team.fromJson(jsonData);
  }
}

/** 
 * This is an auto generated class representing the model identifier
 * of [Team] in your schema.
 */
@immutable
class TeamModelIdentifier implements ModelIdentifier<Team> {
  final String teamId;
  final String name;

  /** 
   * Create an instance of TeamModelIdentifier using [teamId] the primary key.
   * And [name] the sort key.
   */
  const TeamModelIdentifier({
    required this.teamId,
    required this.name});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'teamId': teamId,
    'name': name
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'TeamModelIdentifier(teamId: $teamId, name: $name)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is TeamModelIdentifier &&
      teamId == other.teamId &&
      name == other.name;
  }
  
  @override
  int get hashCode =>
    teamId.hashCode ^
    name.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct models for hasOne/belongsTo relation when custom PK is enabled 3`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the CpkOneToOneBidirectionalParent type in your schema. */
@immutable
class CpkOneToOneBidirectionalParent extends Model {
  static const classType = const _CpkOneToOneBidirectionalParentModelType();
  final String id;
  final String? _name;
  final CpkOneToOneBidirectionalChildExplicit? _explicitChild;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;
  final String? _cpkOneToOneBidirectionalParentExplicitChildId;
  final String? _cpkOneToOneBidirectionalParentExplicitChildName;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  CpkOneToOneBidirectionalParentModelIdentifier get modelIdentifier {
    try {
      return CpkOneToOneBidirectionalParentModelIdentifier(
        id: id,
        name: _name!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  CpkOneToOneBidirectionalChildExplicit? get explicitChild {
    return _explicitChild;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  String? get cpkOneToOneBidirectionalParentExplicitChildId {
    return _cpkOneToOneBidirectionalParentExplicitChildId;
  }
  
  String? get cpkOneToOneBidirectionalParentExplicitChildName {
    return _cpkOneToOneBidirectionalParentExplicitChildName;
  }
  
  const CpkOneToOneBidirectionalParent._internal({required this.id, required name, explicitChild, createdAt, updatedAt, cpkOneToOneBidirectionalParentExplicitChildId, cpkOneToOneBidirectionalParentExplicitChildName}): _name = name, _explicitChild = explicitChild, _createdAt = createdAt, _updatedAt = updatedAt, _cpkOneToOneBidirectionalParentExplicitChildId = cpkOneToOneBidirectionalParentExplicitChildId, _cpkOneToOneBidirectionalParentExplicitChildName = cpkOneToOneBidirectionalParentExplicitChildName;
  
  factory CpkOneToOneBidirectionalParent({String? id, required String name, CpkOneToOneBidirectionalChildExplicit? explicitChild, String? cpkOneToOneBidirectionalParentExplicitChildId, String? cpkOneToOneBidirectionalParentExplicitChildName}) {
    return CpkOneToOneBidirectionalParent._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      explicitChild: explicitChild,
      cpkOneToOneBidirectionalParentExplicitChildId: cpkOneToOneBidirectionalParentExplicitChildId,
      cpkOneToOneBidirectionalParentExplicitChildName: cpkOneToOneBidirectionalParentExplicitChildName);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CpkOneToOneBidirectionalParent &&
      id == other.id &&
      _name == other._name &&
      _explicitChild == other._explicitChild &&
      _cpkOneToOneBidirectionalParentExplicitChildId == other._cpkOneToOneBidirectionalParentExplicitChildId &&
      _cpkOneToOneBidirectionalParentExplicitChildName == other._cpkOneToOneBidirectionalParentExplicitChildName;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"CpkOneToOneBidirectionalParent {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"cpkOneToOneBidirectionalParentExplicitChildId=\\" + \\"$_cpkOneToOneBidirectionalParentExplicitChildId\\" + \\", \\");
    buffer.write(\\"cpkOneToOneBidirectionalParentExplicitChildName=\\" + \\"$_cpkOneToOneBidirectionalParentExplicitChildName\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  CpkOneToOneBidirectionalParent copyWith({CpkOneToOneBidirectionalChildExplicit? explicitChild, String? cpkOneToOneBidirectionalParentExplicitChildId, String? cpkOneToOneBidirectionalParentExplicitChildName}) {
    return CpkOneToOneBidirectionalParent._internal(
      id: id,
      name: name,
      explicitChild: explicitChild ?? this.explicitChild,
      cpkOneToOneBidirectionalParentExplicitChildId: cpkOneToOneBidirectionalParentExplicitChildId ?? this.cpkOneToOneBidirectionalParentExplicitChildId,
      cpkOneToOneBidirectionalParentExplicitChildName: cpkOneToOneBidirectionalParentExplicitChildName ?? this.cpkOneToOneBidirectionalParentExplicitChildName);
  }
  
  CpkOneToOneBidirectionalParent.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _explicitChild = json['explicitChild']?['serializedData'] != null
        ? CpkOneToOneBidirectionalChildExplicit.fromJson(new Map<String, dynamic>.from(json['explicitChild']['serializedData']))
        : null,
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null,
      _cpkOneToOneBidirectionalParentExplicitChildId = json['cpkOneToOneBidirectionalParentExplicitChildId'],
      _cpkOneToOneBidirectionalParentExplicitChildName = json['cpkOneToOneBidirectionalParentExplicitChildName'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'explicitChild': _explicitChild?.toJson(), 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format(), 'cpkOneToOneBidirectionalParentExplicitChildId': _cpkOneToOneBidirectionalParentExplicitChildId, 'cpkOneToOneBidirectionalParentExplicitChildName': _cpkOneToOneBidirectionalParentExplicitChildName
  };

  static final QueryModelIdentifier<CpkOneToOneBidirectionalParentModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<CpkOneToOneBidirectionalParentModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField EXPLICITCHILD = QueryField(
    fieldName: \\"explicitChild\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (CpkOneToOneBidirectionalChildExplicit).toString()));
  static final QueryField CPKONETOONEBIDIRECTIONALPARENTEXPLICITCHILDID = QueryField(fieldName: \\"cpkOneToOneBidirectionalParentExplicitChildId\\");
  static final QueryField CPKONETOONEBIDIRECTIONALPARENTEXPLICITCHILDNAME = QueryField(fieldName: \\"cpkOneToOneBidirectionalParentExplicitChildName\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"CpkOneToOneBidirectionalParent\\";
    modelSchemaDefinition.pluralName = \\"CpkOneToOneBidirectionalParents\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"id\\", \\"name\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: CpkOneToOneBidirectionalParent.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasOne(
      key: CpkOneToOneBidirectionalParent.EXPLICITCHILD,
      isRequired: false,
      ofModelName: (CpkOneToOneBidirectionalChildExplicit).toString(),
      associatedKey: CpkOneToOneBidirectionalChildExplicit.BELONGSTOPARENT
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: CpkOneToOneBidirectionalParent.CPKONETOONEBIDIRECTIONALPARENTEXPLICITCHILDID,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: CpkOneToOneBidirectionalParent.CPKONETOONEBIDIRECTIONALPARENTEXPLICITCHILDNAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CpkOneToOneBidirectionalParentModelType extends ModelType<CpkOneToOneBidirectionalParent> {
  const _CpkOneToOneBidirectionalParentModelType();
  
  @override
  CpkOneToOneBidirectionalParent fromJson(Map<String, dynamic> jsonData) {
    return CpkOneToOneBidirectionalParent.fromJson(jsonData);
  }
}

/** 
 * This is an auto generated class representing the model identifier
 * of [CpkOneToOneBidirectionalParent] in your schema.
 */
@immutable
class CpkOneToOneBidirectionalParentModelIdentifier implements ModelIdentifier<CpkOneToOneBidirectionalParent> {
  final String id;
  final String name;

  /** 
   * Create an instance of CpkOneToOneBidirectionalParentModelIdentifier using [id] the primary key.
   * And [name] the sort key.
   */
  const CpkOneToOneBidirectionalParentModelIdentifier({
    required this.id,
    required this.name});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id,
    'name': name
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'CpkOneToOneBidirectionalParentModelIdentifier(id: $id, name: $name)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is CpkOneToOneBidirectionalParentModelIdentifier &&
      id == other.id &&
      name == other.name;
  }
  
  @override
  int get hashCode =>
    id.hashCode ^
    name.hashCode;
}"
`;

exports[`AppSync Dart Visitor custom primary key model generation should generate correct models for hasOne/belongsTo relation when custom PK is enabled 4`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the CpkOneToOneBidirectionalChildExplicit type in your schema. */
@immutable
class CpkOneToOneBidirectionalChildExplicit extends Model {
  static const classType = const _CpkOneToOneBidirectionalChildExplicitModelType();
  final String id;
  final String? _name;
  final CpkOneToOneBidirectionalParent? _belongsToParent;
  final TemporalDateTime? _createdAt;
  final TemporalDateTime? _updatedAt;

  @override
  getInstanceType() => classType;
  
  @Deprecated('[getId] is being deprecated in favor of custom primary key feature. Use getter [modelIdentifier] to get model identifier.')
  @override
  String getId() => id;
  
  CpkOneToOneBidirectionalChildExplicitModelIdentifier get modelIdentifier {
    try {
      return CpkOneToOneBidirectionalChildExplicitModelIdentifier(
        id: id,
        name: _name!
      );
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  CpkOneToOneBidirectionalParent? get belongsToParent {
    return _belongsToParent;
  }
  
  TemporalDateTime? get createdAt {
    return _createdAt;
  }
  
  TemporalDateTime? get updatedAt {
    return _updatedAt;
  }
  
  const CpkOneToOneBidirectionalChildExplicit._internal({required this.id, required name, belongsToParent, createdAt, updatedAt}): _name = name, _belongsToParent = belongsToParent, _createdAt = createdAt, _updatedAt = updatedAt;
  
  factory CpkOneToOneBidirectionalChildExplicit({String? id, required String name, CpkOneToOneBidirectionalParent? belongsToParent}) {
    return CpkOneToOneBidirectionalChildExplicit._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      belongsToParent: belongsToParent);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CpkOneToOneBidirectionalChildExplicit &&
      id == other.id &&
      _name == other._name &&
      _belongsToParent == other._belongsToParent;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"CpkOneToOneBidirectionalChildExplicit {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"belongsToParent=\\" + (_belongsToParent != null ? _belongsToParent!.toString() : \\"null\\") + \\", \\");
    buffer.write(\\"createdAt=\\" + (_createdAt != null ? _createdAt!.format() : \\"null\\") + \\", \\");
    buffer.write(\\"updatedAt=\\" + (_updatedAt != null ? _updatedAt!.format() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  CpkOneToOneBidirectionalChildExplicit copyWith({CpkOneToOneBidirectionalParent? belongsToParent}) {
    return CpkOneToOneBidirectionalChildExplicit._internal(
      id: id,
      name: name,
      belongsToParent: belongsToParent ?? this.belongsToParent);
  }
  
  CpkOneToOneBidirectionalChildExplicit.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _belongsToParent = json['belongsToParent']?['serializedData'] != null
        ? CpkOneToOneBidirectionalParent.fromJson(new Map<String, dynamic>.from(json['belongsToParent']['serializedData']))
        : null,
      _createdAt = json['createdAt'] != null ? TemporalDateTime.fromString(json['createdAt']) : null,
      _updatedAt = json['updatedAt'] != null ? TemporalDateTime.fromString(json['updatedAt']) : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'belongsToParent': _belongsToParent?.toJson(), 'createdAt': _createdAt?.format(), 'updatedAt': _updatedAt?.format()
  };

  static final QueryModelIdentifier<CpkOneToOneBidirectionalChildExplicitModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<CpkOneToOneBidirectionalChildExplicitModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField BELONGSTOPARENT = QueryField(
    fieldName: \\"belongsToParent\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (CpkOneToOneBidirectionalParent).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"CpkOneToOneBidirectionalChildExplicit\\";
    modelSchemaDefinition.pluralName = \\"CpkOneToOneBidirectionalChildExplicits\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"id\\", \\"name\\"], name: null)
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: CpkOneToOneBidirectionalChildExplicit.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: CpkOneToOneBidirectionalChildExplicit.BELONGSTOPARENT,
      isRequired: false,
      targetNames: [\\"belongsToParentID\\", \\"belongsToParentName\\"],
      ofModelName: (CpkOneToOneBidirectionalParent).toString()
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'createdAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.nonQueryField(
      fieldName: 'updatedAt',
      isRequired: false,
      isReadOnly: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.dateTime)
    ));
  });
}

class _CpkOneToOneBidirectionalChildExplicitModelType extends ModelType<CpkOneToOneBidirectionalChildExplicit> {
  const _CpkOneToOneBidirectionalChildExplicitModelType();
  
  @override
  CpkOneToOneBidirectionalChildExplicit fromJson(Map<String, dynamic> jsonData) {
    return CpkOneToOneBidirectionalChildExplicit.fromJson(jsonData);
  }
}

/** 
 * This is an auto generated class representing the model identifier
 * of [CpkOneToOneBidirectionalChildExplicit] in your schema.
 */
@immutable
class CpkOneToOneBidirectionalChildExplicitModelIdentifier implements ModelIdentifier<CpkOneToOneBidirectionalChildExplicit> {
  final String id;
  final String name;

  /** 
   * Create an instance of CpkOneToOneBidirectionalChildExplicitModelIdentifier using [id] the primary key.
   * And [name] the sort key.
   */
  const CpkOneToOneBidirectionalChildExplicitModelIdentifier({
    required this.id,
    required this.name});
  
  @override
  Map<String, dynamic> serializeAsMap() => (<String, dynamic>{
    'id': id,
    'name': name
  });
  
  @override
  List<Map<String, dynamic>> serializeAsList() => serializeAsMap()
    .entries
    .map((entry) => (<String, dynamic>{ entry.key: entry.value }))
    .toList();
  
  @override
  String serializeAsString() => serializeAsMap().values.join('#');
  
  @override
  String toString() => 'CpkOneToOneBidirectionalChildExplicitModelIdentifier(id: $id, name: $name)';
  
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    
    return other is CpkOneToOneBidirectionalChildExplicitModelIdentifier &&
      id == other.id &&
      name == other.name;
  }
  
  @override
  int get hashCode =>
    id.hashCode ^
    name.hashCode;
}"
`;
