// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AppSyncSwiftVisitor Many To Many V2 Tests Should generate the intermediate model successfully 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation
"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate foreign key fields in hasMany uni relation for model with CPK 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post: Model {
  public let id: String
  public let title: String
  public var comments: List<Comment>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment>? = []) {
    self.init(id: id,
      title: title,
      comments: comments,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.comments = comments
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate foreign key fields in hasMany uni relation for model with CPK 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case comments
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post = Post.keys
    
    model.listPluralName = \\"Posts\\"
    model.syncPluralName = \\"Posts\\"
    
    model.attributes(
      .index(fields: [\\"id\\", \\"title\\"], name: nil),
      .primaryKey(fields: [post.id, post.title])
    )
    
    model.fields(
      .field(post.id, is: .required, ofType: .string),
      .field(post.title, is: .required, ofType: .string),
      .hasMany(post.comments, is: .optional, ofType: Comment.self, associatedWith: Comment.keys.postCommentsId),
      .field(post.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<Post> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Post: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension Post.IdentifierProtocol {
  public static func identifier(id: String,
      title: String) -> Self {
    .make(fields:[(name: \\"id\\", value: id), (name: \\"title\\", value: title)])
  }
}
extension ModelPath where ModelType == Post {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var title: FieldPath<String>   {
      string(\\"title\\") 
    }
  public var comments: ModelPath<Comment>   {
      Comment.Path(name: \\"comments\\", isCollection: true, parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate foreign key fields in hasMany uni relation for model with CPK 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Comment: Model {
  public let id: String
  public let content: String
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var postCommentsId: String?
  public var postCommentsTitle: String?
  
  public init(id: String = UUID().uuidString,
      content: String,
      postCommentsId: String? = nil,
      postCommentsTitle: String? = nil) {
    self.init(id: id,
      content: content,
      createdAt: nil,
      updatedAt: nil,
      postCommentsId: postCommentsId,
      postCommentsTitle: postCommentsTitle)
  }
  internal init(id: String = UUID().uuidString,
      content: String,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      postCommentsId: String? = nil,
      postCommentsTitle: String? = nil) {
      self.id = id
      self.content = content
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.postCommentsId = postCommentsId
      self.postCommentsTitle = postCommentsTitle
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate foreign key fields in hasMany uni relation for model with CPK 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Comment {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case createdAt
    case updatedAt
    case postCommentsId
    case postCommentsTitle
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let comment = Comment.keys
    
    model.listPluralName = \\"Comments\\"
    model.syncPluralName = \\"Comments\\"
    
    model.attributes(
      .index(fields: [\\"id\\", \\"content\\"], name: nil),
      .primaryKey(fields: [comment.id, comment.content])
    )
    
    model.fields(
      .field(comment.id, is: .required, ofType: .string),
      .field(comment.content, is: .required, ofType: .string),
      .field(comment.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment.postCommentsId, is: .optional, ofType: .string),
      .field(comment.postCommentsTitle, is: .optional, ofType: .string)
    )
    }
    public class Path: ModelPath<Comment> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Comment: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension Comment.IdentifierProtocol {
  public static func identifier(id: String,
      content: String) -> Self {
    .make(fields:[(name: \\"id\\", value: id), (name: \\"content\\", value: content)])
  }
}
extension ModelPath where ModelType == Comment {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var content: FieldPath<String>   {
      string(\\"content\\") 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
  public var postCommentsId: FieldPath<String>   {
      string(\\"postCommentsId\\") 
    }
  public var postCommentsTitle: FieldPath<String>   {
      string(\\"postCommentsTitle\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with a composite PK 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct ModelCompositePk: Model {
  public let id: String
  public let dob: Temporal.DateTime
  public var name: String?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      dob: Temporal.DateTime,
      name: String? = nil) {
    self.init(id: id,
      dob: dob,
      name: name,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      dob: Temporal.DateTime,
      name: String? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.dob = dob
      self.name = name
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with a composite PK 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension ModelCompositePk {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case dob
    case name
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let modelCompositePk = ModelCompositePk.keys
    
    model.listPluralName = \\"ModelCompositePks\\"
    model.syncPluralName = \\"ModelCompositePks\\"
    
    model.attributes(
      .index(fields: [\\"id\\", \\"dob\\"], name: nil),
      .primaryKey(fields: [modelCompositePk.id, modelCompositePk.dob])
    )
    
    model.fields(
      .field(modelCompositePk.id, is: .required, ofType: .string),
      .field(modelCompositePk.dob, is: .required, ofType: .dateTime),
      .field(modelCompositePk.name, is: .optional, ofType: .string),
      .field(modelCompositePk.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(modelCompositePk.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<ModelCompositePk> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension ModelCompositePk: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension ModelCompositePk.IdentifierProtocol {
  public static func identifier(id: String,
      dob: Temporal.DateTime) -> Self {
    .make(fields:[(name: \\"id\\", value: id), (name: \\"dob\\", value: dob)])
  }
}
extension ModelPath where ModelType == ModelCompositePk {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var dob: FieldPath<Temporal.DateTime>   {
      datetime(\\"dob\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with a custom PK 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct ModelExplicitCustomPk: Model {
  public let userId: String
  public var name: String?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(userId: String,
      name: String? = nil) {
    self.init(userId: userId,
      name: name,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(userId: String,
      name: String? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.userId = userId
      self.name = name
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with a custom PK 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension ModelExplicitCustomPk {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case userId
    case name
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let modelExplicitCustomPk = ModelExplicitCustomPk.keys
    
    model.listPluralName = \\"ModelExplicitCustomPks\\"
    model.syncPluralName = \\"ModelExplicitCustomPks\\"
    
    model.attributes(
      .index(fields: [\\"userId\\"], name: nil),
      .primaryKey(fields: [modelExplicitCustomPk.userId])
    )
    
    model.fields(
      .field(modelExplicitCustomPk.userId, is: .required, ofType: .string),
      .field(modelExplicitCustomPk.name, is: .optional, ofType: .string),
      .field(modelExplicitCustomPk.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(modelExplicitCustomPk.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<ModelExplicitCustomPk> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension ModelExplicitCustomPk: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension ModelExplicitCustomPk.IdentifierProtocol {
  public static func identifier(userId: String) -> Self {
    .make(fields:[(name: \\"userId\\", value: userId)])
  }
}
extension ModelPath where ModelType == ModelExplicitCustomPk {
  public var userId: FieldPath<String>   {
      string(\\"userId\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with explicit PK named id 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct ModelExplicitDefaultPk: Model {
  public let id: String
  public var name: String?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil) {
    self.init(id: id,
      name: name,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with explicit PK named id 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension ModelExplicitDefaultPk {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let modelExplicitDefaultPk = ModelExplicitDefaultPk.keys
    
    model.listPluralName = \\"ModelExplicitDefaultPks\\"
    model.syncPluralName = \\"ModelExplicitDefaultPks\\"
    
    model.attributes(
      .index(fields: [\\"id\\"], name: nil),
      .primaryKey(fields: [modelExplicitDefaultPk.id])
    )
    
    model.fields(
      .field(modelExplicitDefaultPk.id, is: .required, ofType: .string),
      .field(modelExplicitDefaultPk.name, is: .optional, ofType: .string),
      .field(modelExplicitDefaultPk.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(modelExplicitDefaultPk.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<ModelExplicitDefaultPk> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension ModelExplicitDefaultPk: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == ModelExplicitDefaultPk {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with implicit PK 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct ModelImplicitDefaultPk: Model {
  public let id: String
  public var name: String?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil) {
    self.init(id: id,
      name: name,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with implicit PK 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension ModelImplicitDefaultPk {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let modelImplicitDefaultPk = ModelImplicitDefaultPk.keys
    
    model.listPluralName = \\"ModelImplicitDefaultPks\\"
    model.syncPluralName = \\"ModelImplicitDefaultPks\\"
    
    model.attributes(
      .primaryKey(fields: [modelImplicitDefaultPk.id])
    )
    
    model.fields(
      .field(modelImplicitDefaultPk.id, is: .required, ofType: .string),
      .field(modelImplicitDefaultPk.name, is: .optional, ofType: .string),
      .field(modelImplicitDefaultPk.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(modelImplicitDefaultPk.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<ModelImplicitDefaultPk> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension ModelImplicitDefaultPk: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == ModelImplicitDefaultPk {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate targetNames in hasOne/belongsTo relation for models with a composite PK 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Project: Model {
  public let projectId: String
  public let name: String
  internal var _team: LazyReference<Team>
  public var team: Team?   {
      get async throws { 
        try await _team.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var projectTeamTeamId: String?
  public var projectTeamName: String?
  
  public init(projectId: String,
      name: String,
      team: Team? = nil,
      projectTeamTeamId: String? = nil,
      projectTeamName: String? = nil) {
    self.init(projectId: projectId,
      name: name,
      team: team,
      createdAt: nil,
      updatedAt: nil,
      projectTeamTeamId: projectTeamTeamId,
      projectTeamName: projectTeamName)
  }
  internal init(projectId: String,
      name: String,
      team: Team? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      projectTeamTeamId: String? = nil,
      projectTeamName: String? = nil) {
      self.projectId = projectId
      self.name = name
      self._team = LazyReference(team)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.projectTeamTeamId = projectTeamTeamId
      self.projectTeamName = projectTeamName
  }
  public mutating func setTeam(_ team: Team? = nil) {
    self._team = LazyReference(team)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      projectId = try values.decode(String.self, forKey: .projectId)
      name = try values.decode(String.self, forKey: .name)
      _team = try values.decodeIfPresent(LazyReference<Team>.self, forKey: .team) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
      projectTeamTeamId = try? values.decode(String?.self, forKey: .projectTeamTeamId)
      projectTeamName = try? values.decode(String?.self, forKey: .projectTeamName)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(projectId, forKey: .projectId)
      try container.encode(name, forKey: .name)
      try container.encode(_team, forKey: .team)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
      try container.encode(projectTeamTeamId, forKey: .projectTeamTeamId)
      try container.encode(projectTeamName, forKey: .projectTeamName)
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate targetNames in hasOne/belongsTo relation for models with a composite PK 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Project {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case projectId
    case name
    case team
    case createdAt
    case updatedAt
    case projectTeamTeamId
    case projectTeamName
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let project = Project.keys
    
    model.listPluralName = \\"Projects\\"
    model.syncPluralName = \\"Projects\\"
    
    model.attributes(
      .index(fields: [\\"projectId\\", \\"name\\"], name: nil),
      .primaryKey(fields: [project.projectId, project.name])
    )
    
    model.fields(
      .field(project.projectId, is: .required, ofType: .string),
      .field(project.name, is: .required, ofType: .string),
      .hasOne(project.team, is: .optional, ofType: Team.self, associatedWith: Team.keys.project, targetNames: [\\"projectTeamTeamId\\", \\"projectTeamName\\"]),
      .field(project.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project.projectTeamTeamId, is: .optional, ofType: .string),
      .field(project.projectTeamName, is: .optional, ofType: .string)
    )
    }
    public class Path: ModelPath<Project> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Project: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension Project.IdentifierProtocol {
  public static func identifier(projectId: String,
      name: String) -> Self {
    .make(fields:[(name: \\"projectId\\", value: projectId), (name: \\"name\\", value: name)])
  }
}
extension ModelPath where ModelType == Project {
  public var projectId: FieldPath<String>   {
      string(\\"projectId\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var team: ModelPath<Team>   {
      Team.Path(name: \\"team\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
  public var projectTeamTeamId: FieldPath<String>   {
      string(\\"projectTeamTeamId\\") 
    }
  public var projectTeamName: FieldPath<String>   {
      string(\\"projectTeamName\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate targetNames in hasOne/belongsTo relation for models with a composite PK 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Team: Model {
  public let teamId: String
  public let name: String
  internal var _project: LazyReference<Project>
  public var project: Project?   {
      get async throws { 
        try await _project.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(teamId: String,
      name: String,
      project: Project? = nil) {
    self.init(teamId: teamId,
      name: name,
      project: project,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(teamId: String,
      name: String,
      project: Project? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.teamId = teamId
      self.name = name
      self._project = LazyReference(project)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
  public mutating func setProject(_ project: Project? = nil) {
    self._project = LazyReference(project)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      teamId = try values.decode(String.self, forKey: .teamId)
      name = try values.decode(String.self, forKey: .name)
      _project = try values.decodeIfPresent(LazyReference<Project>.self, forKey: .project) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(teamId, forKey: .teamId)
      try container.encode(name, forKey: .name)
      try container.encode(_project, forKey: .project)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate targetNames in hasOne/belongsTo relation for models with a composite PK 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Team {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case teamId
    case name
    case project
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let team = Team.keys
    
    model.listPluralName = \\"Teams\\"
    model.syncPluralName = \\"Teams\\"
    
    model.attributes(
      .index(fields: [\\"teamId\\", \\"name\\"], name: nil),
      .primaryKey(fields: [team.teamId, team.name])
    )
    
    model.fields(
      .field(team.teamId, is: .required, ofType: .string),
      .field(team.name, is: .required, ofType: .string),
      .belongsTo(team.project, is: .optional, ofType: Project.self, targetNames: [\\"teamProjectProjectId\\", \\"teamProjectName\\"]),
      .field(team.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(team.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<Team> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Team: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension Team.IdentifierProtocol {
  public static func identifier(teamId: String,
      name: String) -> Self {
    .make(fields:[(name: \\"teamId\\", value: teamId), (name: \\"name\\", value: name)])
  }
}
extension ModelPath where ModelType == Team {
  public var teamId: FieldPath<String>   {
      string(\\"teamId\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var project: ModelPath<Project>   {
      Project.Path(name: \\"project\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Should handle nullability of lists appropriately 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct ListContainer: Model {
  public let id: String
  public var name: String?
  public var list: [Int?]?
  public var requiredList: [String?]
  public var requiredListOfRequired: [StatusEnum]
  public var listOfRequired: [Bool]?
  public var requiredListOfRequiredDates: [Temporal.Date]
  public var listOfRequiredFloats: [Double]?
  public var requiredListOfCustomTypes: [CustomType?]
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil,
      list: [Int?]? = nil,
      requiredList: [String?] = [],
      requiredListOfRequired: [StatusEnum] = [],
      listOfRequired: [Bool]? = nil,
      requiredListOfRequiredDates: [Temporal.Date] = [],
      listOfRequiredFloats: [Double]? = nil,
      requiredListOfCustomTypes: [CustomType?] = []) {
    self.init(id: id,
      name: name,
      list: list,
      requiredList: requiredList,
      requiredListOfRequired: requiredListOfRequired,
      listOfRequired: listOfRequired,
      requiredListOfRequiredDates: requiredListOfRequiredDates,
      listOfRequiredFloats: listOfRequiredFloats,
      requiredListOfCustomTypes: requiredListOfCustomTypes,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      list: [Int?]? = nil,
      requiredList: [String?] = [],
      requiredListOfRequired: [StatusEnum] = [],
      listOfRequired: [Bool]? = nil,
      requiredListOfRequiredDates: [Temporal.Date] = [],
      listOfRequiredFloats: [Double]? = nil,
      requiredListOfCustomTypes: [CustomType?] = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.list = list
      self.requiredList = requiredList
      self.requiredListOfRequired = requiredListOfRequired
      self.listOfRequired = listOfRequired
      self.requiredListOfRequiredDates = requiredListOfRequiredDates
      self.listOfRequiredFloats = listOfRequiredFloats
      self.requiredListOfCustomTypes = requiredListOfCustomTypes
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Should handle nullability of lists appropriately 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension ListContainer {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case list
    case requiredList
    case requiredListOfRequired
    case listOfRequired
    case requiredListOfRequiredDates
    case listOfRequiredFloats
    case requiredListOfCustomTypes
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let listContainer = ListContainer.keys
    
    model.listPluralName = \\"ListContainers\\"
    model.syncPluralName = \\"ListContainers\\"
    
    model.fields(
      .id(),
      .field(listContainer.name, is: .optional, ofType: .string),
      .field(listContainer.list, is: .optional, ofType: .embeddedCollection(of: Int.self)),
      .field(listContainer.requiredList, is: .required, ofType: .embeddedCollection(of: String.self)),
      .field(listContainer.requiredListOfRequired, is: .required, ofType: .embeddedCollection(of: StatusEnum.self)),
      .field(listContainer.listOfRequired, is: .optional, ofType: .embeddedCollection(of: Bool.self)),
      .field(listContainer.requiredListOfRequiredDates, is: .required, ofType: .embeddedCollection(of: Temporal.Date.self)),
      .field(listContainer.listOfRequiredFloats, is: .optional, ofType: .embeddedCollection(of: Double.self)),
      .field(listContainer.requiredListOfCustomTypes, is: .required, ofType: .embeddedCollection(of: CustomType.self)),
      .field(listContainer.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(listContainer.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<ListContainer> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}
extension ModelPath where ModelType == ListContainer {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var list: FieldPath<Int>   {
      int(\\"list\\") 
    }
  public var requiredList: FieldPath<String>   {
      string(\\"requiredList\\") 
    }
  public var listOfRequired: FieldPath<Bool>   {
      bool(\\"listOfRequired\\") 
    }
  public var requiredListOfRequiredDates: FieldPath<Temporal.Date>   {
      date(\\"requiredListOfRequiredDates\\") 
    }
  public var listOfRequiredFloats: FieldPath<Double>   {
      double(\\"listOfRequiredFloats\\") 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Should handle nullability of lists appropriately 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct CustomType: Embeddable {
  var name: String?
  var list: [Int?]?
  var requiredList: [String?]
  var requiredListOfRequired: [StatusEnum]
  var listOfRequired: [Bool]?
}"
`;

exports[`AppSyncSwiftVisitor Should render lists with HAS_MANY connection as optional fields 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Todo: Model {
  public let id: String
  public var title: String
  public var requiredListOfTasks: List<task>?
  public var listOfRequiredTasks: List<task>?
  public var listOfTasks: List<task>?
  public var requiredListOfRequiredTasks: List<task>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      requiredListOfTasks: List<task>? = [],
      listOfRequiredTasks: List<task> = [],
      listOfTasks: List<task>? = [],
      requiredListOfRequiredTasks: List<task> = []) {
    self.init(id: id,
      title: title,
      requiredListOfTasks: requiredListOfTasks,
      listOfRequiredTasks: listOfRequiredTasks,
      listOfTasks: listOfTasks,
      requiredListOfRequiredTasks: requiredListOfRequiredTasks,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      requiredListOfTasks: List<task>? = [],
      listOfRequiredTasks: List<task> = [],
      listOfTasks: List<task>? = [],
      requiredListOfRequiredTasks: List<task> = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.requiredListOfTasks = requiredListOfTasks
      self.listOfRequiredTasks = listOfRequiredTasks
      self.listOfTasks = listOfTasks
      self.requiredListOfRequiredTasks = requiredListOfRequiredTasks
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Should render lists with HAS_MANY connection as optional fields 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Todo {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case requiredListOfTasks
    case listOfRequiredTasks
    case listOfTasks
    case requiredListOfRequiredTasks
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let todo = Todo.keys
    
    model.listPluralName = \\"Todos\\"
    model.syncPluralName = \\"Todos\\"
    
    model.fields(
      .id(),
      .field(todo.title, is: .required, ofType: .string),
      .hasMany(todo.requiredListOfTasks, is: .optional, ofType: task.self, associatedWith: task.keys.todo),
      .hasMany(todo.listOfRequiredTasks, is: .optional, ofType: task.self, associatedWith: task.keys.todo),
      .hasMany(todo.listOfTasks, is: .optional, ofType: task.self, associatedWith: task.keys.todo),
      .hasMany(todo.requiredListOfRequiredTasks, is: .optional, ofType: task.self, associatedWith: task.keys.todo),
      .field(todo.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(todo.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<Todo> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}
extension ModelPath where ModelType == Todo {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var title: FieldPath<String>   {
      string(\\"title\\") 
    }
  public var requiredListOfTasks: ModelPath<task>   {
      task.Path(name: \\"requiredListOfTasks\\", isCollection: true, parent: self) 
    }
  public var listOfRequiredTasks: ModelPath<task>   {
      task.Path(name: \\"listOfRequiredTasks\\", isCollection: true, parent: self) 
    }
  public var listOfTasks: ModelPath<task>   {
      task.Path(name: \\"listOfTasks\\", isCollection: true, parent: self) 
    }
  public var requiredListOfRequiredTasks: ModelPath<task>   {
      task.Path(name: \\"requiredListOfRequiredTasks\\", isCollection: true, parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Should render lists with HAS_MANY connection as optional fields 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct task: Model {
  public let id: String
  public var title: String
  internal var _todo: LazyReference<Todo>
  public var todo: Todo?   {
      get async throws { 
        try await _todo.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      todo: Todo? = nil) {
    self.init(id: id,
      title: title,
      todo: todo,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      todo: Todo? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self._todo = LazyReference(todo)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
  public mutating func setTodo(_ todo: Todo? = nil) {
    self._todo = LazyReference(todo)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      id = try values.decode(String.self, forKey: .id)
      title = try values.decode(String.self, forKey: .title)
      _todo = try values.decodeIfPresent(LazyReference<Todo>.self, forKey: .todo) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(id, forKey: .id)
      try container.encode(title, forKey: .title)
      try container.encode(_todo, forKey: .todo)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
  }
}"
`;

exports[`AppSyncSwiftVisitor Should render lists with HAS_MANY connection as optional fields 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension task {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case todo
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let task = task.keys
    
    model.listPluralName = \\"tasks\\"
    model.syncPluralName = \\"tasks\\"
    
    model.fields(
      .id(),
      .field(task.title, is: .required, ofType: .string),
      .belongsTo(task.todo, is: .optional, ofType: Todo.self, targetName: \\"taskTodoId\\"),
      .field(task.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(task.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<task> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}
extension ModelPath where ModelType == task {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var title: FieldPath<String>   {
      string(\\"title\\") 
    }
  public var todo: ModelPath<Todo>   {
      Todo.Path(name: \\"todo\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor custom references double linked references 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Foo: Model {
  public let id: String
  internal var _bar1: LazyReference<Bar>
  public var bar1: Bar?   {
      get async throws { 
        try await _bar1.get()
      } 
    }
  internal var _bar2: LazyReference<Bar>
  public var bar2: Bar?   {
      get async throws { 
        try await _bar2.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var fooBar1Id: String?
  public var fooBar2Id: String?
  
  public init(id: String = UUID().uuidString,
      bar1: Bar? = nil,
      bar2: Bar? = nil,
      fooBar1Id: String? = nil,
      fooBar2Id: String? = nil) {
    self.init(id: id,
      bar1: bar1,
      bar2: bar2,
      createdAt: nil,
      updatedAt: nil,
      fooBar1Id: fooBar1Id,
      fooBar2Id: fooBar2Id)
  }
  internal init(id: String = UUID().uuidString,
      bar1: Bar? = nil,
      bar2: Bar? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      fooBar1Id: String? = nil,
      fooBar2Id: String? = nil) {
      self.id = id
      self._bar1 = LazyReference(bar1)
      self._bar2 = LazyReference(bar2)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.fooBar1Id = fooBar1Id
      self.fooBar2Id = fooBar2Id
  }
  public mutating func setBar1(_ bar1: Bar? = nil) {
    self._bar1 = LazyReference(bar1)
  }
  public mutating func setBar2(_ bar2: Bar? = nil) {
    self._bar2 = LazyReference(bar2)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      id = try values.decode(String.self, forKey: .id)
      _bar1 = try values.decodeIfPresent(LazyReference<Bar>.self, forKey: .bar1) ?? LazyReference(identifiers: nil)
      _bar2 = try values.decodeIfPresent(LazyReference<Bar>.self, forKey: .bar2) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
      fooBar1Id = try? values.decode(String?.self, forKey: .fooBar1Id)
      fooBar2Id = try? values.decode(String?.self, forKey: .fooBar2Id)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(id, forKey: .id)
      try container.encode(_bar1, forKey: .bar1)
      try container.encode(_bar2, forKey: .bar2)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
      try container.encode(fooBar1Id, forKey: .fooBar1Id)
      try container.encode(fooBar2Id, forKey: .fooBar2Id)
  }
}"
`;

exports[`AppSyncSwiftVisitor custom references double linked references 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Foo {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case bar1
    case bar2
    case createdAt
    case updatedAt
    case fooBar1Id
    case fooBar2Id
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let foo = Foo.keys
    
    model.listPluralName = \\"Foos\\"
    model.syncPluralName = \\"Foos\\"
    
    model.attributes(
      .primaryKey(fields: [foo.id])
    )
    
    model.fields(
      .field(foo.id, is: .required, ofType: .string),
      .hasOne(foo.bar1, is: .optional, ofType: Bar.self, associatedWith: Bar.keys.foo1, targetNames: [\\"fooBar1Id\\"]),
      .hasOne(foo.bar2, is: .optional, ofType: Bar.self, associatedWith: Bar.keys.foo1, targetNames: [\\"fooBar2Id\\"]),
      .field(foo.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(foo.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(foo.fooBar1Id, is: .optional, ofType: .string),
      .field(foo.fooBar2Id, is: .optional, ofType: .string)
    )
    }
    public class Path: ModelPath<Foo> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Foo: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == Foo {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var bar1: ModelPath<Bar>   {
      Bar.Path(name: \\"bar1\\", parent: self) 
    }
  public var bar2: ModelPath<Bar>   {
      Bar.Path(name: \\"bar2\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
  public var fooBar1Id: FieldPath<String>   {
      string(\\"fooBar1Id\\") 
    }
  public var fooBar2Id: FieldPath<String>   {
      string(\\"fooBar2Id\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor custom references double linked references 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Bar: Model {
  public let id: String
  public var bar1Id: String?
  public var bar2Id: String?
  internal var _foo1: LazyReference<Foo>
  public var foo1: Foo?   {
      get async throws { 
        try await _foo1.get()
      } 
    }
  internal var _foo2: LazyReference<Foo>
  public var foo2: Foo?   {
      get async throws { 
        try await _foo2.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      bar1Id: String? = nil,
      bar2Id: String? = nil,
      foo1: Foo? = nil,
      foo2: Foo? = nil) {
    self.init(id: id,
      bar1Id: bar1Id,
      bar2Id: bar2Id,
      foo1: foo1,
      foo2: foo2,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      bar1Id: String? = nil,
      bar2Id: String? = nil,
      foo1: Foo? = nil,
      foo2: Foo? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.bar1Id = bar1Id
      self.bar2Id = bar2Id
      self._foo1 = LazyReference(foo1)
      self._foo2 = LazyReference(foo2)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
  public mutating func setFoo1(_ foo1: Foo? = nil) {
    self._foo1 = LazyReference(foo1)
  }
  public mutating func setFoo2(_ foo2: Foo? = nil) {
    self._foo2 = LazyReference(foo2)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      id = try values.decode(String.self, forKey: .id)
      bar1Id = try? values.decode(String?.self, forKey: .bar1Id)
      bar2Id = try? values.decode(String?.self, forKey: .bar2Id)
      _foo1 = try values.decodeIfPresent(LazyReference<Foo>.self, forKey: .foo1) ?? LazyReference(identifiers: nil)
      _foo2 = try values.decodeIfPresent(LazyReference<Foo>.self, forKey: .foo2) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(id, forKey: .id)
      try container.encode(bar1Id, forKey: .bar1Id)
      try container.encode(bar2Id, forKey: .bar2Id)
      try container.encode(_foo1, forKey: .foo1)
      try container.encode(_foo2, forKey: .foo2)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
  }
}"
`;

exports[`AppSyncSwiftVisitor custom references double linked references 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Bar {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case bar1Id
    case bar2Id
    case foo1
    case foo2
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let bar = Bar.keys
    
    model.listPluralName = \\"Bars\\"
    model.syncPluralName = \\"Bars\\"
    
    model.attributes(
      .primaryKey(fields: [bar.id])
    )
    
    model.fields(
      .field(bar.id, is: .required, ofType: .string),
      .field(bar.bar1Id, is: .optional, ofType: .string),
      .field(bar.bar2Id, is: .optional, ofType: .string),
      .belongsTo(bar.foo1, is: .optional, ofType: Foo.self, targetNames: [\\"barFoo1Id\\"]),
      .belongsTo(bar.foo2, is: .optional, ofType: Foo.self, targetNames: [\\"barFoo2Id\\"]),
      .field(bar.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(bar.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<Bar> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Bar: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == Bar {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var bar1Id: FieldPath<String>   {
      string(\\"bar1Id\\") 
    }
  public var bar2Id: FieldPath<String>   {
      string(\\"bar2Id\\") 
    }
  public var foo1: ModelPath<Foo>   {
      Foo.Path(name: \\"foo1\\", parent: self) 
    }
  public var foo2: ModelPath<Foo>   {
      Foo.Path(name: \\"foo2\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor custom references hasMany with sortKeyFields on primary key 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Primary: Model {
  public let tenantId: String
  public let instanceId: String
  public let recordId: String
  public var content: String?
  public var related: List<Related>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(tenantId: String,
      instanceId: String,
      recordId: String,
      content: String? = nil,
      related: List<Related> = []) {
    self.init(tenantId: tenantId,
      instanceId: instanceId,
      recordId: recordId,
      content: content,
      related: related,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(tenantId: String,
      instanceId: String,
      recordId: String,
      content: String? = nil,
      related: List<Related> = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.tenantId = tenantId
      self.instanceId = instanceId
      self.recordId = recordId
      self.content = content
      self.related = related
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor custom references hasMany with sortKeyFields on primary key 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Primary {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case tenantId
    case instanceId
    case recordId
    case content
    case related
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let primary = Primary.keys
    
    model.listPluralName = \\"Primaries\\"
    model.syncPluralName = \\"Primaries\\"
    
    model.attributes(
      .index(fields: [\\"tenantId\\", \\"instanceId\\", \\"recordId\\"], name: nil),
      .primaryKey(fields: [primary.tenantId, primary.instanceId, primary.recordId])
    )
    
    model.fields(
      .field(primary.tenantId, is: .required, ofType: .string),
      .field(primary.instanceId, is: .required, ofType: .string),
      .field(primary.recordId, is: .required, ofType: .string),
      .field(primary.content, is: .optional, ofType: .string),
      .hasMany(primary.related, is: .optional, ofType: Related.self, associatedWith: Related.keys.primary),
      .field(primary.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(primary.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<Primary> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Primary: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension Primary.IdentifierProtocol {
  public static func identifier(tenantId: String,
      instanceId: String,
      recordId: String) -> Self {
    .make(fields:[(name: \\"tenantId\\", value: tenantId), (name: \\"instanceId\\", value: instanceId), (name: \\"recordId\\", value: recordId)])
  }
}
extension ModelPath where ModelType == Primary {
  public var tenantId: FieldPath<String>   {
      string(\\"tenantId\\") 
    }
  public var instanceId: FieldPath<String>   {
      string(\\"instanceId\\") 
    }
  public var recordId: FieldPath<String>   {
      string(\\"recordId\\") 
    }
  public var content: FieldPath<String>   {
      string(\\"content\\") 
    }
  public var related: ModelPath<Related>   {
      Related.Path(name: \\"related\\", isCollection: true, parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor custom references hasMany with sortKeyFields on primary key 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Related: Model {
  public let id: String
  public var content: String?
  public var primaryTenantId: String
  public var primaryInstanceId: String
  public var primaryRecordId: String
  internal var _primary: LazyReference<Primary>
  public var primary: Primary?   {
      get async throws { 
        try await _primary.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      content: String? = nil,
      primaryTenantId: String,
      primaryInstanceId: String,
      primaryRecordId: String,
      primary: Primary? = nil) {
    self.init(id: id,
      content: content,
      primaryTenantId: primaryTenantId,
      primaryInstanceId: primaryInstanceId,
      primaryRecordId: primaryRecordId,
      primary: primary,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      content: String? = nil,
      primaryTenantId: String,
      primaryInstanceId: String,
      primaryRecordId: String,
      primary: Primary? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.content = content
      self.primaryTenantId = primaryTenantId
      self.primaryInstanceId = primaryInstanceId
      self.primaryRecordId = primaryRecordId
      self._primary = LazyReference(primary)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
  public mutating func setPrimary(_ primary: Primary? = nil) {
    self._primary = LazyReference(primary)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      id = try values.decode(String.self, forKey: .id)
      content = try? values.decode(String?.self, forKey: .content)
      primaryTenantId = try values.decode(String.self, forKey: .primaryTenantId)
      primaryInstanceId = try values.decode(String.self, forKey: .primaryInstanceId)
      primaryRecordId = try values.decode(String.self, forKey: .primaryRecordId)
      _primary = try values.decodeIfPresent(LazyReference<Primary>.self, forKey: .primary) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(id, forKey: .id)
      try container.encode(content, forKey: .content)
      try container.encode(primaryTenantId, forKey: .primaryTenantId)
      try container.encode(primaryInstanceId, forKey: .primaryInstanceId)
      try container.encode(primaryRecordId, forKey: .primaryRecordId)
      try container.encode(_primary, forKey: .primary)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
  }
}"
`;

exports[`AppSyncSwiftVisitor custom references hasMany with sortKeyFields on primary key 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Related {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case primaryTenantId
    case primaryInstanceId
    case primaryRecordId
    case primary
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let related = Related.keys
    
    model.listPluralName = \\"Relateds\\"
    model.syncPluralName = \\"Relateds\\"
    
    model.attributes(
      .primaryKey(fields: [related.id])
    )
    
    model.fields(
      .field(related.id, is: .required, ofType: .string),
      .field(related.content, is: .optional, ofType: .string),
      .field(related.primaryTenantId, is: .required, ofType: .string),
      .field(related.primaryInstanceId, is: .required, ofType: .string),
      .field(related.primaryRecordId, is: .required, ofType: .string),
      .belongsTo(related.primary, is: .optional, ofType: Primary.self, targetNames: [\\"primaryRelatedTenantId\\", \\"primaryRelatedInstanceId\\", \\"primaryRelatedRecordId\\"]),
      .field(related.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(related.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<Related> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Related: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == Related {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var content: FieldPath<String>   {
      string(\\"content\\") 
    }
  public var primaryTenantId: FieldPath<String>   {
      string(\\"primaryTenantId\\") 
    }
  public var primaryInstanceId: FieldPath<String>   {
      string(\\"primaryInstanceId\\") 
    }
  public var primaryRecordId: FieldPath<String>   {
      string(\\"primaryRecordId\\") 
    }
  public var primary: ModelPath<Primary>   {
      Primary.Path(name: \\"primary\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor custom references hasOne with sortKeyFields on primary key 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Primary: Model {
  public let tenantId: String
  public let instanceId: String
  public let recordId: String
  public var content: String?
  internal var _related: LazyReference<Related>
  public var related: Related?   {
      get async throws { 
        try await _related.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var primaryRelatedId: String?
  
  public init(tenantId: String,
      instanceId: String,
      recordId: String,
      content: String? = nil,
      related: Related? = nil,
      primaryRelatedId: String? = nil) {
    self.init(tenantId: tenantId,
      instanceId: instanceId,
      recordId: recordId,
      content: content,
      related: related,
      createdAt: nil,
      updatedAt: nil,
      primaryRelatedId: primaryRelatedId)
  }
  internal init(tenantId: String,
      instanceId: String,
      recordId: String,
      content: String? = nil,
      related: Related? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      primaryRelatedId: String? = nil) {
      self.tenantId = tenantId
      self.instanceId = instanceId
      self.recordId = recordId
      self.content = content
      self._related = LazyReference(related)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.primaryRelatedId = primaryRelatedId
  }
  public mutating func setRelated(_ related: Related? = nil) {
    self._related = LazyReference(related)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      tenantId = try values.decode(String.self, forKey: .tenantId)
      instanceId = try values.decode(String.self, forKey: .instanceId)
      recordId = try values.decode(String.self, forKey: .recordId)
      content = try? values.decode(String?.self, forKey: .content)
      _related = try values.decodeIfPresent(LazyReference<Related>.self, forKey: .related) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
      primaryRelatedId = try? values.decode(String?.self, forKey: .primaryRelatedId)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(tenantId, forKey: .tenantId)
      try container.encode(instanceId, forKey: .instanceId)
      try container.encode(recordId, forKey: .recordId)
      try container.encode(content, forKey: .content)
      try container.encode(_related, forKey: .related)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
      try container.encode(primaryRelatedId, forKey: .primaryRelatedId)
  }
}"
`;

exports[`AppSyncSwiftVisitor custom references hasOne with sortKeyFields on primary key 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Primary {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case tenantId
    case instanceId
    case recordId
    case content
    case related
    case createdAt
    case updatedAt
    case primaryRelatedId
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let primary = Primary.keys
    
    model.listPluralName = \\"Primaries\\"
    model.syncPluralName = \\"Primaries\\"
    
    model.attributes(
      .index(fields: [\\"tenantId\\", \\"instanceId\\", \\"recordId\\"], name: nil),
      .primaryKey(fields: [primary.tenantId, primary.instanceId, primary.recordId])
    )
    
    model.fields(
      .field(primary.tenantId, is: .required, ofType: .string),
      .field(primary.instanceId, is: .required, ofType: .string),
      .field(primary.recordId, is: .required, ofType: .string),
      .field(primary.content, is: .optional, ofType: .string),
      .hasOne(primary.related, is: .optional, ofType: Related.self, associatedWith: Related.keys.primary, targetNames: [\\"primaryRelatedId\\"]),
      .field(primary.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(primary.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(primary.primaryRelatedId, is: .optional, ofType: .string)
    )
    }
    public class Path: ModelPath<Primary> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Primary: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension Primary.IdentifierProtocol {
  public static func identifier(tenantId: String,
      instanceId: String,
      recordId: String) -> Self {
    .make(fields:[(name: \\"tenantId\\", value: tenantId), (name: \\"instanceId\\", value: instanceId), (name: \\"recordId\\", value: recordId)])
  }
}
extension ModelPath where ModelType == Primary {
  public var tenantId: FieldPath<String>   {
      string(\\"tenantId\\") 
    }
  public var instanceId: FieldPath<String>   {
      string(\\"instanceId\\") 
    }
  public var recordId: FieldPath<String>   {
      string(\\"recordId\\") 
    }
  public var content: FieldPath<String>   {
      string(\\"content\\") 
    }
  public var related: ModelPath<Related>   {
      Related.Path(name: \\"related\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
  public var primaryRelatedId: FieldPath<String>   {
      string(\\"primaryRelatedId\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor custom references hasOne with sortKeyFields on primary key 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Related: Model {
  public let id: String
  public var content: String?
  public var primaryTenantId: String
  public var primaryInstanceId: String
  public var primaryRecordId: String
  internal var _primary: LazyReference<Primary>
  public var primary: Primary?   {
      get async throws { 
        try await _primary.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      content: String? = nil,
      primaryTenantId: String,
      primaryInstanceId: String,
      primaryRecordId: String,
      primary: Primary? = nil) {
    self.init(id: id,
      content: content,
      primaryTenantId: primaryTenantId,
      primaryInstanceId: primaryInstanceId,
      primaryRecordId: primaryRecordId,
      primary: primary,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      content: String? = nil,
      primaryTenantId: String,
      primaryInstanceId: String,
      primaryRecordId: String,
      primary: Primary? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.content = content
      self.primaryTenantId = primaryTenantId
      self.primaryInstanceId = primaryInstanceId
      self.primaryRecordId = primaryRecordId
      self._primary = LazyReference(primary)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
  public mutating func setPrimary(_ primary: Primary? = nil) {
    self._primary = LazyReference(primary)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      id = try values.decode(String.self, forKey: .id)
      content = try? values.decode(String?.self, forKey: .content)
      primaryTenantId = try values.decode(String.self, forKey: .primaryTenantId)
      primaryInstanceId = try values.decode(String.self, forKey: .primaryInstanceId)
      primaryRecordId = try values.decode(String.self, forKey: .primaryRecordId)
      _primary = try values.decodeIfPresent(LazyReference<Primary>.self, forKey: .primary) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(id, forKey: .id)
      try container.encode(content, forKey: .content)
      try container.encode(primaryTenantId, forKey: .primaryTenantId)
      try container.encode(primaryInstanceId, forKey: .primaryInstanceId)
      try container.encode(primaryRecordId, forKey: .primaryRecordId)
      try container.encode(_primary, forKey: .primary)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
  }
}"
`;

exports[`AppSyncSwiftVisitor custom references hasOne with sortKeyFields on primary key 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Related {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case primaryTenantId
    case primaryInstanceId
    case primaryRecordId
    case primary
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let related = Related.keys
    
    model.listPluralName = \\"Relateds\\"
    model.syncPluralName = \\"Relateds\\"
    
    model.attributes(
      .primaryKey(fields: [related.id])
    )
    
    model.fields(
      .field(related.id, is: .required, ofType: .string),
      .field(related.content, is: .optional, ofType: .string),
      .field(related.primaryTenantId, is: .required, ofType: .string),
      .field(related.primaryInstanceId, is: .required, ofType: .string),
      .field(related.primaryRecordId, is: .required, ofType: .string),
      .belongsTo(related.primary, is: .optional, ofType: Primary.self, targetNames: [\\"relatedPrimaryTenantId\\", \\"relatedPrimaryInstanceId\\", \\"relatedPrimaryRecordId\\"]),
      .field(related.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(related.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<Related> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Related: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == Related {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var content: FieldPath<String>   {
      string(\\"content\\") 
    }
  public var primaryTenantId: FieldPath<String>   {
      string(\\"primaryTenantId\\") 
    }
  public var primaryInstanceId: FieldPath<String>   {
      string(\\"primaryInstanceId\\") 
    }
  public var primaryRecordId: FieldPath<String>   {
      string(\\"primaryRecordId\\") 
    }
  public var primary: ModelPath<Primary>   {
      Primary.Path(name: \\"primary\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasMany/belongsTo 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct SqlPrimary: Model {
  public let id: Int
  public var content: String?
  public var related: List<SqlRelated>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: Int = UUID().uuidString,
      content: String? = nil,
      related: List<SqlRelated> = []) {
    self.init(id: id,
      content: content,
      related: related,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: Int = UUID().uuidString,
      content: String? = nil,
      related: List<SqlRelated> = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.content = content
      self.related = related
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasMany/belongsTo 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension SqlPrimary {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case related
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let sqlPrimary = SqlPrimary.keys
    
    model.listPluralName = \\"SqlPrimaries\\"
    model.syncPluralName = \\"SqlPrimaries\\"
    
    model.attributes(
      .index(fields: [\\"id\\"], name: nil),
      .primaryKey(fields: [sqlPrimary.id])
    )
    
    model.fields(
      .field(sqlPrimary.id, is: .required, ofType: .int),
      .field(sqlPrimary.content, is: .optional, ofType: .string),
      .hasMany(sqlPrimary.related, is: .optional, ofType: SqlRelated.self, associatedWith: SqlRelated.keys.primary),
      .field(sqlPrimary.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(sqlPrimary.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<SqlPrimary> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension SqlPrimary: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == SqlPrimary {
  public var id: FieldPath<Int>   {
      int(\\"id\\") 
    }
  public var content: FieldPath<String>   {
      string(\\"content\\") 
    }
  public var related: ModelPath<SqlRelated>   {
      SqlRelated.Path(name: \\"related\\", isCollection: true, parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasMany/belongsTo 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct SqlRelated: Model {
  public let id: Int
  public var content: String?
  public var primaryId: Int
  internal var _primary: LazyReference<SqlPrimary>
  public var primary: SqlPrimary?   {
      get async throws { 
        try await _primary.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: Int = UUID().uuidString,
      content: String? = nil,
      primaryId: Int,
      primary: SqlPrimary? = nil) {
    self.init(id: id,
      content: content,
      primaryId: primaryId,
      primary: primary,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: Int = UUID().uuidString,
      content: String? = nil,
      primaryId: Int,
      primary: SqlPrimary? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.content = content
      self.primaryId = primaryId
      self._primary = LazyReference(primary)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
  public mutating func setPrimary(_ primary: SqlPrimary? = nil) {
    self._primary = LazyReference(primary)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      id = try values.decode(Int.self, forKey: .id)
      content = try? values.decode(String?.self, forKey: .content)
      primaryId = try values.decode(Int.self, forKey: .primaryId)
      _primary = try values.decodeIfPresent(LazyReference<SqlPrimary>.self, forKey: .primary) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(id, forKey: .id)
      try container.encode(content, forKey: .content)
      try container.encode(primaryId, forKey: .primaryId)
      try container.encode(_primary, forKey: .primary)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
  }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasMany/belongsTo 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension SqlRelated {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case primaryId
    case primary
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let sqlRelated = SqlRelated.keys
    
    model.listPluralName = \\"SqlRelateds\\"
    model.syncPluralName = \\"SqlRelateds\\"
    
    model.attributes(
      .index(fields: [\\"id\\"], name: nil),
      .index(fields: [\\"primaryId\\"], name: \\"primary_id\\"),
      .primaryKey(fields: [sqlRelated.id])
    )
    
    model.fields(
      .field(sqlRelated.id, is: .required, ofType: .int),
      .field(sqlRelated.content, is: .optional, ofType: .string),
      .field(sqlRelated.primaryId, is: .required, ofType: .int),
      .belongsTo(sqlRelated.primary, is: .optional, ofType: SqlPrimary.self, targetNames: [\\"sqlPrimaryRelatedId\\"]),
      .field(sqlRelated.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(sqlRelated.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<SqlRelated> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension SqlRelated: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == SqlRelated {
  public var id: FieldPath<Int>   {
      int(\\"id\\") 
    }
  public var content: FieldPath<String>   {
      string(\\"content\\") 
    }
  public var primaryId: FieldPath<Int>   {
      int(\\"primaryId\\") 
    }
  public var primary: ModelPath<SqlPrimary>   {
      SqlPrimary.Path(name: \\"primary\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasOne and hasMany 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Primary: Model {
  public let id: String
  public var relatedMany: List<RelatedMany>?
  internal var _relatedOne: LazyReference<RelatedOne>
  public var relatedOne: RelatedOne?   {
      get async throws { 
        try await _relatedOne.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var primaryRelatedOneId: String?
  
  public init(id: String = UUID().uuidString,
      relatedMany: List<RelatedMany>? = [],
      relatedOne: RelatedOne? = nil,
      primaryRelatedOneId: String? = nil) {
    self.init(id: id,
      relatedMany: relatedMany,
      relatedOne: relatedOne,
      createdAt: nil,
      updatedAt: nil,
      primaryRelatedOneId: primaryRelatedOneId)
  }
  internal init(id: String = UUID().uuidString,
      relatedMany: List<RelatedMany>? = [],
      relatedOne: RelatedOne? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      primaryRelatedOneId: String? = nil) {
      self.id = id
      self.relatedMany = relatedMany
      self._relatedOne = LazyReference(relatedOne)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.primaryRelatedOneId = primaryRelatedOneId
  }
  public mutating func setRelatedOne(_ relatedOne: RelatedOne? = nil) {
    self._relatedOne = LazyReference(relatedOne)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      id = try values.decode(String.self, forKey: .id)
      relatedMany = try values.decodeIfPresent(List<RelatedMany>?.self, forKey: .relatedMany) ?? .init()
      _relatedOne = try values.decodeIfPresent(LazyReference<RelatedOne>.self, forKey: .relatedOne) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
      primaryRelatedOneId = try? values.decode(String?.self, forKey: .primaryRelatedOneId)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(id, forKey: .id)
      try container.encode(relatedMany, forKey: .relatedMany)
      try container.encode(_relatedOne, forKey: .relatedOne)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
      try container.encode(primaryRelatedOneId, forKey: .primaryRelatedOneId)
  }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasOne and hasMany 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Primary {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case relatedMany
    case relatedOne
    case createdAt
    case updatedAt
    case primaryRelatedOneId
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let primary = Primary.keys
    
    model.listPluralName = \\"Primaries\\"
    model.syncPluralName = \\"Primaries\\"
    
    model.attributes(
      .index(fields: [\\"id\\"], name: nil),
      .primaryKey(fields: [primary.id])
    )
    
    model.fields(
      .field(primary.id, is: .required, ofType: .string),
      .hasMany(primary.relatedMany, is: .optional, ofType: RelatedMany.self, associatedWith: RelatedMany.keys.primary),
      .hasOne(primary.relatedOne, is: .optional, ofType: RelatedOne.self, associatedWith: RelatedOne.keys.primary, targetNames: [\\"primaryRelatedOneId\\"]),
      .field(primary.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(primary.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(primary.primaryRelatedOneId, is: .optional, ofType: .string)
    )
    }
    public class Path: ModelPath<Primary> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Primary: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == Primary {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var relatedMany: ModelPath<RelatedMany>   {
      RelatedMany.Path(name: \\"relatedMany\\", isCollection: true, parent: self) 
    }
  public var relatedOne: ModelPath<RelatedOne>   {
      RelatedOne.Path(name: \\"relatedOne\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
  public var primaryRelatedOneId: FieldPath<String>   {
      string(\\"primaryRelatedOneId\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasOne and hasMany 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct RelatedMany: Model {
  public let id: String
  public var primaryId: String
  internal var _primary: LazyReference<Primary>
  public var primary: Primary?   {
      get async throws { 
        try await _primary.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      primaryId: String,
      primary: Primary? = nil) {
    self.init(id: id,
      primaryId: primaryId,
      primary: primary,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      primaryId: String,
      primary: Primary? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.primaryId = primaryId
      self._primary = LazyReference(primary)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
  public mutating func setPrimary(_ primary: Primary? = nil) {
    self._primary = LazyReference(primary)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      id = try values.decode(String.self, forKey: .id)
      primaryId = try values.decode(String.self, forKey: .primaryId)
      _primary = try values.decodeIfPresent(LazyReference<Primary>.self, forKey: .primary) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(id, forKey: .id)
      try container.encode(primaryId, forKey: .primaryId)
      try container.encode(_primary, forKey: .primary)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
  }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasOne and hasMany 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension RelatedMany {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case primaryId
    case primary
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let relatedMany = RelatedMany.keys
    
    model.listPluralName = \\"RelatedManies\\"
    model.syncPluralName = \\"RelatedManies\\"
    
    model.attributes(
      .index(fields: [\\"id\\"], name: nil),
      .primaryKey(fields: [relatedMany.id])
    )
    
    model.fields(
      .field(relatedMany.id, is: .required, ofType: .string),
      .field(relatedMany.primaryId, is: .required, ofType: .string),
      .belongsTo(relatedMany.primary, is: .optional, ofType: Primary.self, targetNames: [\\"primaryRelatedManyId\\"]),
      .field(relatedMany.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(relatedMany.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<RelatedMany> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension RelatedMany: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == RelatedMany {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var primaryId: FieldPath<String>   {
      string(\\"primaryId\\") 
    }
  public var primary: ModelPath<Primary>   {
      Primary.Path(name: \\"primary\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasOne and hasMany 5`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct RelatedOne: Model {
  public let id: String
  public var primaryId: String
  internal var _primary: LazyReference<Primary>
  public var primary: Primary?   {
      get async throws { 
        try await _primary.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      primaryId: String,
      primary: Primary? = nil) {
    self.init(id: id,
      primaryId: primaryId,
      primary: primary,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      primaryId: String,
      primary: Primary? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.primaryId = primaryId
      self._primary = LazyReference(primary)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
  public mutating func setPrimary(_ primary: Primary? = nil) {
    self._primary = LazyReference(primary)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      id = try values.decode(String.self, forKey: .id)
      primaryId = try values.decode(String.self, forKey: .primaryId)
      _primary = try values.decodeIfPresent(LazyReference<Primary>.self, forKey: .primary) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(id, forKey: .id)
      try container.encode(primaryId, forKey: .primaryId)
      try container.encode(_primary, forKey: .primary)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
  }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasOne and hasMany 6`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension RelatedOne {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case primaryId
    case primary
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let relatedOne = RelatedOne.keys
    
    model.listPluralName = \\"RelatedOnes\\"
    model.syncPluralName = \\"RelatedOnes\\"
    
    model.attributes(
      .index(fields: [\\"id\\"], name: nil),
      .primaryKey(fields: [relatedOne.id])
    )
    
    model.fields(
      .field(relatedOne.id, is: .required, ofType: .string),
      .field(relatedOne.primaryId, is: .required, ofType: .string),
      .belongsTo(relatedOne.primary, is: .optional, ofType: Primary.self, targetNames: [\\"relatedOnePrimaryId\\"]),
      .field(relatedOne.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(relatedOne.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<RelatedOne> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension RelatedOne: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == RelatedOne {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var primaryId: FieldPath<String>   {
      string(\\"primaryId\\") 
    }
  public var primary: ModelPath<Primary>   {
      Primary.Path(name: \\"primary\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasOne/belongsTo 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct SqlPrimary: Model {
  public let id: Int
  public var content: String?
  internal var _related: LazyReference<SqlRelated>
  public var related: SqlRelated?   {
      get async throws { 
        try await _related.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var sqlPrimaryRelatedId: Int?
  
  public init(id: Int = UUID().uuidString,
      content: String? = nil,
      related: SqlRelated? = nil,
      sqlPrimaryRelatedId: Int? = nil) {
    self.init(id: id,
      content: content,
      related: related,
      createdAt: nil,
      updatedAt: nil,
      sqlPrimaryRelatedId: sqlPrimaryRelatedId)
  }
  internal init(id: Int = UUID().uuidString,
      content: String? = nil,
      related: SqlRelated? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      sqlPrimaryRelatedId: Int? = nil) {
      self.id = id
      self.content = content
      self._related = LazyReference(related)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.sqlPrimaryRelatedId = sqlPrimaryRelatedId
  }
  public mutating func setRelated(_ related: SqlRelated? = nil) {
    self._related = LazyReference(related)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      id = try values.decode(Int.self, forKey: .id)
      content = try? values.decode(String?.self, forKey: .content)
      _related = try values.decodeIfPresent(LazyReference<SqlRelated>.self, forKey: .related) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
      sqlPrimaryRelatedId = try? values.decode(Int?.self, forKey: .sqlPrimaryRelatedId)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(id, forKey: .id)
      try container.encode(content, forKey: .content)
      try container.encode(_related, forKey: .related)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
      try container.encode(sqlPrimaryRelatedId, forKey: .sqlPrimaryRelatedId)
  }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasOne/belongsTo 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension SqlPrimary {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case related
    case createdAt
    case updatedAt
    case sqlPrimaryRelatedId
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let sqlPrimary = SqlPrimary.keys
    
    model.listPluralName = \\"SqlPrimaries\\"
    model.syncPluralName = \\"SqlPrimaries\\"
    
    model.attributes(
      .index(fields: [\\"id\\"], name: nil),
      .primaryKey(fields: [sqlPrimary.id])
    )
    
    model.fields(
      .field(sqlPrimary.id, is: .required, ofType: .int),
      .field(sqlPrimary.content, is: .optional, ofType: .string),
      .hasOne(sqlPrimary.related, is: .optional, ofType: SqlRelated.self, associatedWith: SqlRelated.keys.primary, targetNames: [\\"sqlPrimaryRelatedId\\"]),
      .field(sqlPrimary.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(sqlPrimary.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(sqlPrimary.sqlPrimaryRelatedId, is: .optional, ofType: .int)
    )
    }
    public class Path: ModelPath<SqlPrimary> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension SqlPrimary: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == SqlPrimary {
  public var id: FieldPath<Int>   {
      int(\\"id\\") 
    }
  public var content: FieldPath<String>   {
      string(\\"content\\") 
    }
  public var related: ModelPath<SqlRelated>   {
      SqlRelated.Path(name: \\"related\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
  public var sqlPrimaryRelatedId: FieldPath<Int>   {
      int(\\"sqlPrimaryRelatedId\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasOne/belongsTo 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct SqlRelated: Model {
  public let id: Int
  public var content: String?
  public var primaryId: Int
  internal var _primary: LazyReference<SqlPrimary>
  public var primary: SqlPrimary?   {
      get async throws { 
        try await _primary.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: Int = UUID().uuidString,
      content: String? = nil,
      primaryId: Int,
      primary: SqlPrimary? = nil) {
    self.init(id: id,
      content: content,
      primaryId: primaryId,
      primary: primary,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: Int = UUID().uuidString,
      content: String? = nil,
      primaryId: Int,
      primary: SqlPrimary? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.content = content
      self.primaryId = primaryId
      self._primary = LazyReference(primary)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
  public mutating func setPrimary(_ primary: SqlPrimary? = nil) {
    self._primary = LazyReference(primary)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      id = try values.decode(Int.self, forKey: .id)
      content = try? values.decode(String?.self, forKey: .content)
      primaryId = try values.decode(Int.self, forKey: .primaryId)
      _primary = try values.decodeIfPresent(LazyReference<SqlPrimary>.self, forKey: .primary) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(id, forKey: .id)
      try container.encode(content, forKey: .content)
      try container.encode(primaryId, forKey: .primaryId)
      try container.encode(_primary, forKey: .primary)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
  }
}"
`;

exports[`AppSyncSwiftVisitor custom references sets the association to the references field for hasOne/belongsTo 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension SqlRelated {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case primaryId
    case primary
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let sqlRelated = SqlRelated.keys
    
    model.listPluralName = \\"SqlRelateds\\"
    model.syncPluralName = \\"SqlRelateds\\"
    
    model.attributes(
      .index(fields: [\\"id\\"], name: nil),
      .index(fields: [\\"primaryId\\"], name: \\"primary_id\\"),
      .primaryKey(fields: [sqlRelated.id])
    )
    
    model.fields(
      .field(sqlRelated.id, is: .required, ofType: .int),
      .field(sqlRelated.content, is: .optional, ofType: .string),
      .field(sqlRelated.primaryId, is: .required, ofType: .int),
      .belongsTo(sqlRelated.primary, is: .optional, ofType: SqlPrimary.self, targetNames: [\\"sqlRelatedPrimaryId\\"]),
      .field(sqlRelated.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(sqlRelated.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<SqlRelated> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension SqlRelated: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == SqlRelated {
  public var id: FieldPath<Int>   {
      int(\\"id\\") 
    }
  public var content: FieldPath<String>   {
      string(\\"content\\") 
    }
  public var primaryId: FieldPath<Int>   {
      int(\\"primaryId\\") 
    }
  public var primary: ModelPath<SqlPrimary>   {
      SqlPrimary.Path(name: \\"primary\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;
