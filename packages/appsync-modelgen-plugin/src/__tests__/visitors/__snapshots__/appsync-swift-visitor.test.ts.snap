// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AppSyncSwiftVisitor Many To Many V2 Tests Should generate the intermediate model successfully 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation
"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate foreign key fields in hasMany uni relation for model with CPK 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post: Model {
  public let id: String
  public let title: String
  public var comments: List<Comment>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment>? = []) {
    self.init(id: id,
      title: title,
      comments: comments,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.comments = comments
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate foreign key fields in hasMany uni relation for model with CPK 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case comments
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post = Post.keys
    
    model.listPluralName = \\"Posts\\"
    model.syncPluralName = \\"Posts\\"
    
    model.attributes(
      .index(fields: [\\"id\\", \\"title\\"], name: nil),
      .primaryKey(fields: [post.id, post.title])
    )
    
    model.fields(
      .field(post.id, is: .required, ofType: .string),
      .field(post.title, is: .required, ofType: .string),
      .hasMany(post.comments, is: .optional, ofType: Comment.self, associatedWith: Comment.keys.postCommentsId),
      .field(post.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<Post> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Post: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension Post.IdentifierProtocol {
  public static func identifier(id: String,
      title: String) -> Self {
    .make(fields:[(name: \\"id\\", value: id), (name: \\"title\\", value: title)])
  }
}
extension ModelPath where ModelType == Post {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var title: FieldPath<String>   {
      string(\\"title\\") 
    }
  public var comments: ModelPath<Comment>   {
      Comment.Path(name: \\"comments\\", isCollection: true, parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate foreign key fields in hasMany uni relation for model with CPK 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Comment: Model {
  public let id: String
  public let content: String
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var postCommentsId: String?
  public var postCommentsTitle: String?
  
  public init(id: String = UUID().uuidString,
      content: String,
      postCommentsId: String? = nil,
      postCommentsTitle: String? = nil) {
    self.init(id: id,
      content: content,
      createdAt: nil,
      updatedAt: nil,
      postCommentsId: postCommentsId,
      postCommentsTitle: postCommentsTitle)
  }
  internal init(id: String = UUID().uuidString,
      content: String,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      postCommentsId: String? = nil,
      postCommentsTitle: String? = nil) {
      self.id = id
      self.content = content
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.postCommentsId = postCommentsId
      self.postCommentsTitle = postCommentsTitle
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate foreign key fields in hasMany uni relation for model with CPK 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Comment {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case createdAt
    case updatedAt
    case postCommentsId
    case postCommentsTitle
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let comment = Comment.keys
    
    model.listPluralName = \\"Comments\\"
    model.syncPluralName = \\"Comments\\"
    
    model.attributes(
      .index(fields: [\\"id\\", \\"content\\"], name: nil),
      .primaryKey(fields: [comment.id, comment.content])
    )
    
    model.fields(
      .field(comment.id, is: .required, ofType: .string),
      .field(comment.content, is: .required, ofType: .string),
      .field(comment.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment.postCommentsId, is: .optional, ofType: .string),
      .field(comment.postCommentsTitle, is: .optional, ofType: .string)
    )
    }
    public class Path: ModelPath<Comment> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Comment: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension Comment.IdentifierProtocol {
  public static func identifier(id: String,
      content: String) -> Self {
    .make(fields:[(name: \\"id\\", value: id), (name: \\"content\\", value: content)])
  }
}
extension ModelPath where ModelType == Comment {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var content: FieldPath<String>   {
      string(\\"content\\") 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
  public var postCommentsId: FieldPath<String>   {
      string(\\"postCommentsId\\") 
    }
  public var postCommentsTitle: FieldPath<String>   {
      string(\\"postCommentsTitle\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with a composite PK 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct ModelCompositePk: Model {
  public let id: String
  public let dob: Temporal.DateTime
  public var name: String?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      dob: Temporal.DateTime,
      name: String? = nil) {
    self.init(id: id,
      dob: dob,
      name: name,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      dob: Temporal.DateTime,
      name: String? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.dob = dob
      self.name = name
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with a composite PK 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension ModelCompositePk {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case dob
    case name
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let modelCompositePk = ModelCompositePk.keys
    
    model.listPluralName = \\"ModelCompositePks\\"
    model.syncPluralName = \\"ModelCompositePks\\"
    
    model.attributes(
      .index(fields: [\\"id\\", \\"dob\\"], name: nil),
      .primaryKey(fields: [modelCompositePk.id, modelCompositePk.dob])
    )
    
    model.fields(
      .field(modelCompositePk.id, is: .required, ofType: .string),
      .field(modelCompositePk.dob, is: .required, ofType: .dateTime),
      .field(modelCompositePk.name, is: .optional, ofType: .string),
      .field(modelCompositePk.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(modelCompositePk.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<ModelCompositePk> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension ModelCompositePk: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension ModelCompositePk.IdentifierProtocol {
  public static func identifier(id: String,
      dob: Temporal.DateTime) -> Self {
    .make(fields:[(name: \\"id\\", value: id), (name: \\"dob\\", value: dob)])
  }
}
extension ModelPath where ModelType == ModelCompositePk {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var dob: FieldPath<Temporal.DateTime>   {
      datetime(\\"dob\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with a custom PK 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct ModelExplicitCustomPk: Model {
  public let userId: String
  public var name: String?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(userId: String,
      name: String? = nil) {
    self.init(userId: userId,
      name: name,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(userId: String,
      name: String? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.userId = userId
      self.name = name
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with a custom PK 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension ModelExplicitCustomPk {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case userId
    case name
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let modelExplicitCustomPk = ModelExplicitCustomPk.keys
    
    model.listPluralName = \\"ModelExplicitCustomPks\\"
    model.syncPluralName = \\"ModelExplicitCustomPks\\"
    
    model.attributes(
      .index(fields: [\\"userId\\"], name: nil),
      .primaryKey(fields: [modelExplicitCustomPk.userId])
    )
    
    model.fields(
      .field(modelExplicitCustomPk.userId, is: .required, ofType: .string),
      .field(modelExplicitCustomPk.name, is: .optional, ofType: .string),
      .field(modelExplicitCustomPk.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(modelExplicitCustomPk.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<ModelExplicitCustomPk> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension ModelExplicitCustomPk: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension ModelExplicitCustomPk.IdentifierProtocol {
  public static func identifier(userId: String) -> Self {
    .make(fields:[(name: \\"userId\\", value: userId)])
  }
}
extension ModelPath where ModelType == ModelExplicitCustomPk {
  public var userId: FieldPath<String>   {
      string(\\"userId\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with explicit PK named id 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct ModelExplicitDefaultPk: Model {
  public let id: String
  public var name: String?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil) {
    self.init(id: id,
      name: name,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with explicit PK named id 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension ModelExplicitDefaultPk {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let modelExplicitDefaultPk = ModelExplicitDefaultPk.keys
    
    model.listPluralName = \\"ModelExplicitDefaultPks\\"
    model.syncPluralName = \\"ModelExplicitDefaultPks\\"
    
    model.attributes(
      .index(fields: [\\"id\\"], name: nil),
      .primaryKey(fields: [modelExplicitDefaultPk.id])
    )
    
    model.fields(
      .field(modelExplicitDefaultPk.id, is: .required, ofType: .string),
      .field(modelExplicitDefaultPk.name, is: .optional, ofType: .string),
      .field(modelExplicitDefaultPk.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(modelExplicitDefaultPk.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<ModelExplicitDefaultPk> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension ModelExplicitDefaultPk: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == ModelExplicitDefaultPk {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with implicit PK 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct ModelImplicitDefaultPk: Model {
  public let id: String
  public var name: String?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil) {
    self.init(id: id,
      name: name,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate model and metadata for a model with implicit PK 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension ModelImplicitDefaultPk {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let modelImplicitDefaultPk = ModelImplicitDefaultPk.keys
    
    model.listPluralName = \\"ModelImplicitDefaultPks\\"
    model.syncPluralName = \\"ModelImplicitDefaultPks\\"
    
    model.attributes(
      .primaryKey(fields: [modelImplicitDefaultPk.id])
    )
    
    model.fields(
      .field(modelImplicitDefaultPk.id, is: .required, ofType: .string),
      .field(modelImplicitDefaultPk.name, is: .optional, ofType: .string),
      .field(modelImplicitDefaultPk.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(modelImplicitDefaultPk.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<ModelImplicitDefaultPk> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension ModelImplicitDefaultPk: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias IdentifierProtocol = DefaultModelIdentifier<Self>
}
extension ModelPath where ModelType == ModelImplicitDefaultPk {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate targetNames in hasOne/belongsTo relation for models with a composite PK 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Project: Model {
  public let projectId: String
  public let name: String
  internal var _team: LazyReference<Team>
  public var team: Team?   {
      get async throws { 
        try await _team.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var projectTeamTeamId: String?
  public var projectTeamName: String?
  
  public init(projectId: String,
      name: String,
      team: Team? = nil,
      projectTeamTeamId: String? = nil,
      projectTeamName: String? = nil) {
    self.init(projectId: projectId,
      name: name,
      team: team,
      createdAt: nil,
      updatedAt: nil,
      projectTeamTeamId: projectTeamTeamId,
      projectTeamName: projectTeamName)
  }
  internal init(projectId: String,
      name: String,
      team: Team? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      projectTeamTeamId: String? = nil,
      projectTeamName: String? = nil) {
      self.projectId = projectId
      self.name = name
      self._team = LazyReference(team)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.projectTeamTeamId = projectTeamTeamId
      self.projectTeamName = projectTeamName
  }
  public mutating func setTeam(_ team: Team? = nil) {
    self._team = LazyReference(team)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      projectId = try values.decode(String.self, forKey: .projectId)
      name = try values.decode(String.self, forKey: .name)
      _team = try values.decodeIfPresent(LazyReference<Team>.self, forKey: .team) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
      projectTeamTeamId = try? values.decode(String?.self, forKey: .projectTeamTeamId)
      projectTeamName = try? values.decode(String?.self, forKey: .projectTeamName)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(projectId, forKey: .projectId)
      try container.encode(name, forKey: .name)
      try container.encode(_team, forKey: .team)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
      try container.encode(projectTeamTeamId, forKey: .projectTeamTeamId)
      try container.encode(projectTeamName, forKey: .projectTeamName)
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate targetNames in hasOne/belongsTo relation for models with a composite PK 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Project {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case projectId
    case name
    case team
    case createdAt
    case updatedAt
    case projectTeamTeamId
    case projectTeamName
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let project = Project.keys
    
    model.listPluralName = \\"Projects\\"
    model.syncPluralName = \\"Projects\\"
    
    model.attributes(
      .index(fields: [\\"projectId\\", \\"name\\"], name: nil),
      .primaryKey(fields: [project.projectId, project.name])
    )
    
    model.fields(
      .field(project.projectId, is: .required, ofType: .string),
      .field(project.name, is: .required, ofType: .string),
      .hasOne(project.team, is: .optional, ofType: Team.self, associatedWith: Team.keys.project, targetNames: [\\"projectTeamTeamId\\", \\"projectTeamName\\"]),
      .field(project.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project.projectTeamTeamId, is: .optional, ofType: .string),
      .field(project.projectTeamName, is: .optional, ofType: .string)
    )
    }
    public class Path: ModelPath<Project> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Project: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension Project.IdentifierProtocol {
  public static func identifier(projectId: String,
      name: String) -> Self {
    .make(fields:[(name: \\"projectId\\", value: projectId), (name: \\"name\\", value: name)])
  }
}
extension ModelPath where ModelType == Project {
  public var projectId: FieldPath<String>   {
      string(\\"projectId\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var team: ModelPath<Team>   {
      Team.Path(name: \\"team\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
  public var projectTeamTeamId: FieldPath<String>   {
      string(\\"projectTeamTeamId\\") 
    }
  public var projectTeamName: FieldPath<String>   {
      string(\\"projectTeamName\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate targetNames in hasOne/belongsTo relation for models with a composite PK 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Team: Model {
  public let teamId: String
  public let name: String
  internal var _project: LazyReference<Project>
  public var project: Project?   {
      get async throws { 
        try await _project.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(teamId: String,
      name: String,
      project: Project? = nil) {
    self.init(teamId: teamId,
      name: name,
      project: project,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(teamId: String,
      name: String,
      project: Project? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.teamId = teamId
      self.name = name
      self._project = LazyReference(project)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
  public mutating func setProject(_ project: Project? = nil) {
    self._project = LazyReference(project)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      teamId = try values.decode(String.self, forKey: .teamId)
      name = try values.decode(String.self, forKey: .name)
      _project = try values.decodeIfPresent(LazyReference<Project>.self, forKey: .project) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(teamId, forKey: .teamId)
      try container.encode(name, forKey: .name)
      try container.encode(_project, forKey: .project)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
  }
}"
`;

exports[`AppSyncSwiftVisitor Primary Key Tests Should generate targetNames in hasOne/belongsTo relation for models with a composite PK 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Team {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case teamId
    case name
    case project
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let team = Team.keys
    
    model.listPluralName = \\"Teams\\"
    model.syncPluralName = \\"Teams\\"
    
    model.attributes(
      .index(fields: [\\"teamId\\", \\"name\\"], name: nil),
      .primaryKey(fields: [team.teamId, team.name])
    )
    
    model.fields(
      .field(team.teamId, is: .required, ofType: .string),
      .field(team.name, is: .required, ofType: .string),
      .belongsTo(team.project, is: .optional, ofType: Project.self, targetNames: [\\"teamProjectProjectId\\", \\"teamProjectName\\"]),
      .field(team.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(team.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<Team> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}

extension Team: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Custom
  public typealias IdentifierProtocol = ModelIdentifier<Self, ModelIdentifierFormat.Custom>
}

extension Team.IdentifierProtocol {
  public static func identifier(teamId: String,
      name: String) -> Self {
    .make(fields:[(name: \\"teamId\\", value: teamId), (name: \\"name\\", value: name)])
  }
}
extension ModelPath where ModelType == Team {
  public var teamId: FieldPath<String>   {
      string(\\"teamId\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var project: ModelPath<Project>   {
      Project.Path(name: \\"project\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Should handle nullability of lists appropriately 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct ListContainer: Model {
  public let id: String
  public var name: String?
  public var list: [Int?]?
  public var requiredList: [String?]
  public var requiredListOfRequired: [StatusEnum]
  public var listOfRequired: [Bool]?
  public var requiredListOfRequiredDates: [Temporal.Date]
  public var listOfRequiredFloats: [Double]?
  public var requiredListOfCustomTypes: [CustomType?]
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil,
      list: [Int?]? = nil,
      requiredList: [String?] = [],
      requiredListOfRequired: [StatusEnum] = [],
      listOfRequired: [Bool]? = nil,
      requiredListOfRequiredDates: [Temporal.Date] = [],
      listOfRequiredFloats: [Double]? = nil,
      requiredListOfCustomTypes: [CustomType?] = []) {
    self.init(id: id,
      name: name,
      list: list,
      requiredList: requiredList,
      requiredListOfRequired: requiredListOfRequired,
      listOfRequired: listOfRequired,
      requiredListOfRequiredDates: requiredListOfRequiredDates,
      listOfRequiredFloats: listOfRequiredFloats,
      requiredListOfCustomTypes: requiredListOfCustomTypes,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      list: [Int?]? = nil,
      requiredList: [String?] = [],
      requiredListOfRequired: [StatusEnum] = [],
      listOfRequired: [Bool]? = nil,
      requiredListOfRequiredDates: [Temporal.Date] = [],
      listOfRequiredFloats: [Double]? = nil,
      requiredListOfCustomTypes: [CustomType?] = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.list = list
      self.requiredList = requiredList
      self.requiredListOfRequired = requiredListOfRequired
      self.listOfRequired = listOfRequired
      self.requiredListOfRequiredDates = requiredListOfRequiredDates
      self.listOfRequiredFloats = listOfRequiredFloats
      self.requiredListOfCustomTypes = requiredListOfCustomTypes
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Should handle nullability of lists appropriately 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension ListContainer {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case list
    case requiredList
    case requiredListOfRequired
    case listOfRequired
    case requiredListOfRequiredDates
    case listOfRequiredFloats
    case requiredListOfCustomTypes
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let listContainer = ListContainer.keys
    
    model.listPluralName = \\"ListContainers\\"
    model.syncPluralName = \\"ListContainers\\"
    
    model.fields(
      .id(),
      .field(listContainer.name, is: .optional, ofType: .string),
      .field(listContainer.list, is: .optional, ofType: .embeddedCollection(of: Int.self)),
      .field(listContainer.requiredList, is: .required, ofType: .embeddedCollection(of: String.self)),
      .field(listContainer.requiredListOfRequired, is: .required, ofType: .embeddedCollection(of: StatusEnum.self)),
      .field(listContainer.listOfRequired, is: .optional, ofType: .embeddedCollection(of: Bool.self)),
      .field(listContainer.requiredListOfRequiredDates, is: .required, ofType: .embeddedCollection(of: Temporal.Date.self)),
      .field(listContainer.listOfRequiredFloats, is: .optional, ofType: .embeddedCollection(of: Double.self)),
      .field(listContainer.requiredListOfCustomTypes, is: .required, ofType: .embeddedCollection(of: CustomType.self)),
      .field(listContainer.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(listContainer.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<ListContainer> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}
extension ModelPath where ModelType == ListContainer {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var name: FieldPath<String>   {
      string(\\"name\\") 
    }
  public var list: FieldPath<Int>   {
      int(\\"list\\") 
    }
  public var requiredList: FieldPath<String>   {
      string(\\"requiredList\\") 
    }
  public var listOfRequired: FieldPath<Bool>   {
      bool(\\"listOfRequired\\") 
    }
  public var requiredListOfRequiredDates: FieldPath<Temporal.Date>   {
      date(\\"requiredListOfRequiredDates\\") 
    }
  public var listOfRequiredFloats: FieldPath<Double>   {
      double(\\"listOfRequiredFloats\\") 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Should handle nullability of lists appropriately 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct CustomType: Embeddable {
  var name: String?
  var list: [Int?]?
  var requiredList: [String?]
  var requiredListOfRequired: [StatusEnum]
  var listOfRequired: [Bool]?
}"
`;

exports[`AppSyncSwiftVisitor Should render lists with HAS_MANY connection as optional fields 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Todo: Model {
  public let id: String
  public var title: String
  public var requiredListOfTasks: List<task>?
  public var listOfRequiredTasks: List<task>?
  public var listOfTasks: List<task>?
  public var requiredListOfRequiredTasks: List<task>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      requiredListOfTasks: List<task>? = [],
      listOfRequiredTasks: List<task> = [],
      listOfTasks: List<task>? = [],
      requiredListOfRequiredTasks: List<task> = []) {
    self.init(id: id,
      title: title,
      requiredListOfTasks: requiredListOfTasks,
      listOfRequiredTasks: listOfRequiredTasks,
      listOfTasks: listOfTasks,
      requiredListOfRequiredTasks: requiredListOfRequiredTasks,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      requiredListOfTasks: List<task>? = [],
      listOfRequiredTasks: List<task> = [],
      listOfTasks: List<task>? = [],
      requiredListOfRequiredTasks: List<task> = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.requiredListOfTasks = requiredListOfTasks
      self.listOfRequiredTasks = listOfRequiredTasks
      self.listOfTasks = listOfTasks
      self.requiredListOfRequiredTasks = requiredListOfRequiredTasks
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor Should render lists with HAS_MANY connection as optional fields 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Todo {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case requiredListOfTasks
    case listOfRequiredTasks
    case listOfTasks
    case requiredListOfRequiredTasks
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let todo = Todo.keys
    
    model.listPluralName = \\"Todos\\"
    model.syncPluralName = \\"Todos\\"
    
    model.fields(
      .id(),
      .field(todo.title, is: .required, ofType: .string),
      .hasMany(todo.requiredListOfTasks, is: .optional, ofType: task.self, associatedWith: task.keys.todo),
      .hasMany(todo.listOfRequiredTasks, is: .optional, ofType: task.self, associatedWith: task.keys.todo),
      .hasMany(todo.listOfTasks, is: .optional, ofType: task.self, associatedWith: task.keys.todo),
      .hasMany(todo.requiredListOfRequiredTasks, is: .optional, ofType: task.self, associatedWith: task.keys.todo),
      .field(todo.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(todo.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<Todo> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}
extension ModelPath where ModelType == Todo {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var title: FieldPath<String>   {
      string(\\"title\\") 
    }
  public var requiredListOfTasks: ModelPath<task>   {
      task.Path(name: \\"requiredListOfTasks\\", isCollection: true, parent: self) 
    }
  public var listOfRequiredTasks: ModelPath<task>   {
      task.Path(name: \\"listOfRequiredTasks\\", isCollection: true, parent: self) 
    }
  public var listOfTasks: ModelPath<task>   {
      task.Path(name: \\"listOfTasks\\", isCollection: true, parent: self) 
    }
  public var requiredListOfRequiredTasks: ModelPath<task>   {
      task.Path(name: \\"requiredListOfRequiredTasks\\", isCollection: true, parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;

exports[`AppSyncSwiftVisitor Should render lists with HAS_MANY connection as optional fields 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct task: Model {
  public let id: String
  public var title: String
  internal var _todo: LazyReference<Todo>
  public var todo: Todo?   {
      get async throws { 
        try await _todo.get()
      } 
    }
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      todo: Todo? = nil) {
    self.init(id: id,
      title: title,
      todo: todo,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      todo: Todo? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self._todo = LazyReference(todo)
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
  public mutating func setTodo(_ todo: Todo? = nil) {
    self._todo = LazyReference(todo)
  }
  public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: CodingKeys.self)
      id = try values.decode(String.self, forKey: .id)
      title = try values.decode(String.self, forKey: .title)
      _todo = try values.decodeIfPresent(LazyReference<Todo>.self, forKey: .todo) ?? LazyReference(identifiers: nil)
      createdAt = try? values.decode(Temporal.DateTime?.self, forKey: .createdAt)
      updatedAt = try? values.decode(Temporal.DateTime?.self, forKey: .updatedAt)
  }
  public func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)
      try container.encode(id, forKey: .id)
      try container.encode(title, forKey: .title)
      try container.encode(_todo, forKey: .todo)
      try container.encode(createdAt, forKey: .createdAt)
      try container.encode(updatedAt, forKey: .updatedAt)
  }
}"
`;

exports[`AppSyncSwiftVisitor Should render lists with HAS_MANY connection as optional fields 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension task {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case todo
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let task = task.keys
    
    model.listPluralName = \\"tasks\\"
    model.syncPluralName = \\"tasks\\"
    
    model.fields(
      .id(),
      .field(task.title, is: .required, ofType: .string),
      .belongsTo(task.todo, is: .optional, ofType: Todo.self, targetName: \\"taskTodoId\\"),
      .field(task.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(task.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
    public class Path: ModelPath<task> { }
    
    public static var rootPath: PropertyContainerPath? { Path() }
}
extension ModelPath where ModelType == task {
  public var id: FieldPath<String>   {
      string(\\"id\\") 
    }
  public var title: FieldPath<String>   {
      string(\\"title\\") 
    }
  public var todo: ModelPath<Todo>   {
      Todo.Path(name: \\"todo\\", parent: self) 
    }
  public var createdAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"createdAt\\") 
    }
  public var updatedAt: FieldPath<Temporal.DateTime>   {
      datetime(\\"updatedAt\\") 
    }
}"
`;
