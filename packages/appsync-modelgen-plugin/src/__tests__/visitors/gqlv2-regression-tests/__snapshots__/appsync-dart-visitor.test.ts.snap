// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final List<Comment>? _comments;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Comment>? get comments {
    return _comments;
  }
  
  const Post._internal({required this.id, required title, comments}): _title = title, _comments = comments;
  
  factory Post({String? id, required String title, List<Comment>? comments}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      comments: comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, List<Comment>? comments}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      comments: comments ?? this.comments);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'comments': _comments?.map((Comment? e) => e?.toJson()).toList()
  };

  static final QueryModelIdentifier<PostModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<PostModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Comment).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.COMMENTS,
      isRequired: false,
      ofModelName: (Comment).toString(),
      associatedKey: Comment.POST
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final String? _content;
  final Post? _post;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get content {
    try {
      return _content!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Post? get post {
    return _post;
  }
  
  const Comment._internal({required this.id, required content, post}): _content = content, _post = post;
  
  factory Comment({String? id, required String content, Post? post}) {
    return Comment._internal(
      id: id == null ? UUID.getUUID() : id,
      content: content,
      post: post);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
      id == other.id &&
      _content == other._content &&
      _post == other._post;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\" + \\", \\");
    buffer.write(\\"post=\\" + (_post != null ? _post!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment copyWith({String? id, String? content, Post? post}) {
    return Comment(
      id: id ?? this.id,
      content: content ?? this.content,
      post: post ?? this.post);
  }
  
  Comment.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _content = json['content'],
      _post = json['post']?['serializedData'] != null
        ? Post.fromJson(new Map<String, dynamic>.from(json['post']['serializedData']))
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'content': _content, 'post': _post?.toJson()
  };

  static final QueryModelIdentifier<CommentModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<CommentModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static final QueryField POST = QueryField(
    fieldName: \\"post\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Post).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"postID\\", \\"content\\"], name: \\"byPost\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.CONTENT,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Comment.POST,
      isRequired: false,
      targetName: \\"postID\\",
      ofModelName: (Post).toString()
    ));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();
  
  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on explicit hasOne belongs to relationship @belongsTo 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Project2 type in your schema. */
@immutable
class Project2 extends Model {
  static const classType = const _Project2ModelType();
  final String id;
  final String? _name;
  final Team2? _team;
  final String? _project2TeamId;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  Team2? get team {
    return _team;
  }
  
  String? get project2TeamId {
    return _project2TeamId;
  }
  
  const Project2._internal({required this.id, name, team, project2TeamId}): _name = name, _team = team, _project2TeamId = project2TeamId;
  
  factory Project2({String? id, String? name, Team2? team, String? project2TeamId}) {
    return Project2._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      team: team,
      project2TeamId: project2TeamId);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Project2 &&
      id == other.id &&
      _name == other._name &&
      _team == other._team &&
      _project2TeamId == other._project2TeamId;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Project2 {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"project2TeamId=\\" + \\"$_project2TeamId\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Project2 copyWith({String? id, String? name, Team2? team, String? project2TeamId}) {
    return Project2(
      id: id ?? this.id,
      name: name ?? this.name,
      team: team ?? this.team,
      project2TeamId: project2TeamId ?? this.project2TeamId);
  }
  
  Project2.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _team = json['team']?['serializedData'] != null
        ? Team2.fromJson(new Map<String, dynamic>.from(json['team']['serializedData']))
        : null,
      _project2TeamId = json['project2TeamId'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'team': _team?.toJson(), 'project2TeamId': _project2TeamId
  };

  static final QueryModelIdentifier<Project2ModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<Project2ModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField TEAM = QueryField(
    fieldName: \\"team\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Team2).toString()));
  static final QueryField PROJECT2TEAMID = QueryField(fieldName: \\"project2TeamId\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Project2\\";
    modelSchemaDefinition.pluralName = \\"Project2s\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project2.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasOne(
      key: Project2.TEAM,
      isRequired: false,
      ofModelName: (Team2).toString(),
      associatedKey: Team2.PROJECT
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project2.PROJECT2TEAMID,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _Project2ModelType extends ModelType<Project2> {
  const _Project2ModelType();
  
  @override
  Project2 fromJson(Map<String, dynamic> jsonData) {
    return Project2.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on explicit hasOne belongs to relationship @belongsTo 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Team2 type in your schema. */
@immutable
class Team2 extends Model {
  static const classType = const _Team2ModelType();
  final String id;
  final String? _name;
  final Project2? _project;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Project2? get project {
    return _project;
  }
  
  const Team2._internal({required this.id, required name, project}): _name = name, _project = project;
  
  factory Team2({String? id, required String name, Project2? project}) {
    return Team2._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      project: project);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Team2 &&
      id == other.id &&
      _name == other._name &&
      _project == other._project;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Team2 {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"project=\\" + (_project != null ? _project!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Team2 copyWith({String? id, String? name, Project2? project}) {
    return Team2(
      id: id ?? this.id,
      name: name ?? this.name,
      project: project ?? this.project);
  }
  
  Team2.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _project = json['project']?['serializedData'] != null
        ? Project2.fromJson(new Map<String, dynamic>.from(json['project']['serializedData']))
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'project': _project?.toJson()
  };

  static final QueryModelIdentifier<Team2ModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<Team2ModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField PROJECT = QueryField(
    fieldName: \\"project\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Project2).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Team2\\";
    modelSchemaDefinition.pluralName = \\"Team2s\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Team2.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Team2.PROJECT,
      isRequired: false,
      targetName: \\"projectID\\",
      ofModelName: (Project2).toString()
    ));
  });
}

class _Team2ModelType extends ModelType<Team2> {
  const _Team2ModelType();
  
  @override
  Team2 fromJson(Map<String, dynamic> jsonData) {
    return Team2.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Blog7V2 type in your schema. */
@immutable
class Blog7V2 extends Model {
  static const classType = const _Blog7V2ModelType();
  final String id;
  final String? _name;
  final List<Post7V2>? _posts;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Post7V2>? get posts {
    return _posts;
  }
  
  const Blog7V2._internal({required this.id, required name, posts}): _name = name, _posts = posts;
  
  factory Blog7V2({String? id, required String name, List<Post7V2>? posts}) {
    return Blog7V2._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      posts: posts != null ? List<Post7V2>.unmodifiable(posts) : posts);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Blog7V2 &&
      id == other.id &&
      _name == other._name &&
      DeepCollectionEquality().equals(_posts, other._posts);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Blog7V2 {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Blog7V2 copyWith({String? id, String? name, List<Post7V2>? posts}) {
    return Blog7V2(
      id: id ?? this.id,
      name: name ?? this.name,
      posts: posts ?? this.posts);
  }
  
  Blog7V2.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _posts = json['posts'] is List
        ? (json['posts'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Post7V2.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'posts': _posts?.map((Post7V2? e) => e?.toJson()).toList()
  };

  static final QueryModelIdentifier<Blog7V2ModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<Blog7V2ModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField POSTS = QueryField(
    fieldName: \\"posts\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Post7V2).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Blog7V2\\";
    modelSchemaDefinition.pluralName = \\"Blog7V2s\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Blog7V2.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Blog7V2.POSTS,
      isRequired: false,
      ofModelName: (Post7V2).toString(),
      associatedKey: Post7V2.BLOG
    ));
  });
}

class _Blog7V2ModelType extends ModelType<Blog7V2> {
  const _Blog7V2ModelType();
  
  @override
  Blog7V2 fromJson(Map<String, dynamic> jsonData) {
    return Blog7V2.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post7V2 type in your schema. */
@immutable
class Post7V2 extends Model {
  static const classType = const _Post7V2ModelType();
  final String id;
  final String? _title;
  final Blog7V2? _blog;
  final List<Comment7V2>? _comments;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Blog7V2? get blog {
    return _blog;
  }
  
  List<Comment7V2>? get comments {
    return _comments;
  }
  
  const Post7V2._internal({required this.id, required title, blog, comments}): _title = title, _blog = blog, _comments = comments;
  
  factory Post7V2({String? id, required String title, Blog7V2? blog, List<Comment7V2>? comments}) {
    return Post7V2._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      blog: blog,
      comments: comments != null ? List<Comment7V2>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post7V2 &&
      id == other.id &&
      _title == other._title &&
      _blog == other._blog &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post7V2 {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"blog=\\" + (_blog != null ? _blog!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post7V2 copyWith({String? id, String? title, Blog7V2? blog, List<Comment7V2>? comments}) {
    return Post7V2(
      id: id ?? this.id,
      title: title ?? this.title,
      blog: blog ?? this.blog,
      comments: comments ?? this.comments);
  }
  
  Post7V2.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _blog = json['blog']?['serializedData'] != null
        ? Blog7V2.fromJson(new Map<String, dynamic>.from(json['blog']['serializedData']))
        : null,
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment7V2.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'blog': _blog?.toJson(), 'comments': _comments?.map((Comment7V2? e) => e?.toJson()).toList()
  };

  static final QueryModelIdentifier<Post7V2ModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<Post7V2ModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField BLOG = QueryField(
    fieldName: \\"blog\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Blog7V2).toString()));
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Comment7V2).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post7V2\\";
    modelSchemaDefinition.pluralName = \\"Post7V2s\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post7V2.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Post7V2.BLOG,
      isRequired: false,
      targetName: \\"blog7V2PostsId\\",
      ofModelName: (Blog7V2).toString()
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post7V2.COMMENTS,
      isRequired: false,
      ofModelName: (Comment7V2).toString(),
      associatedKey: Comment7V2.POST
    ));
  });
}

class _Post7V2ModelType extends ModelType<Post7V2> {
  const _Post7V2ModelType();
  
  @override
  Post7V2 fromJson(Map<String, dynamic> jsonData) {
    return Post7V2.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 3`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Comment7V2 type in your schema. */
@immutable
class Comment7V2 extends Model {
  static const classType = const _Comment7V2ModelType();
  final String id;
  final String? _content;
  final Post7V2? _post;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get content {
    return _content;
  }
  
  Post7V2? get post {
    return _post;
  }
  
  const Comment7V2._internal({required this.id, content, post}): _content = content, _post = post;
  
  factory Comment7V2({String? id, String? content, Post7V2? post}) {
    return Comment7V2._internal(
      id: id == null ? UUID.getUUID() : id,
      content: content,
      post: post);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment7V2 &&
      id == other.id &&
      _content == other._content &&
      _post == other._post;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment7V2 {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\" + \\", \\");
    buffer.write(\\"post=\\" + (_post != null ? _post!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment7V2 copyWith({String? id, String? content, Post7V2? post}) {
    return Comment7V2(
      id: id ?? this.id,
      content: content ?? this.content,
      post: post ?? this.post);
  }
  
  Comment7V2.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _content = json['content'],
      _post = json['post']?['serializedData'] != null
        ? Post7V2.fromJson(new Map<String, dynamic>.from(json['post']['serializedData']))
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'content': _content, 'post': _post?.toJson()
  };

  static final QueryModelIdentifier<Comment7V2ModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<Comment7V2ModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static final QueryField POST = QueryField(
    fieldName: \\"post\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Post7V2).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment7V2\\";
    modelSchemaDefinition.pluralName = \\"Comment7V2s\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment7V2.CONTENT,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Comment7V2.POST,
      isRequired: false,
      targetName: \\"post7V2CommentsId\\",
      ofModelName: (Post7V2).toString()
    ));
  });
}

class _Comment7V2ModelType extends ModelType<Comment7V2> {
  const _Comment7V2ModelType();
  
  @override
  Comment7V2 fromJson(Map<String, dynamic> jsonData) {
    return Comment7V2.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on implicit hasOne belongs to relationship @belongsTo 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Project type in your schema. */
@immutable
class Project extends Model {
  static const classType = const _ProjectModelType();
  final String id;
  final String? _name;
  final Team? _team;
  final String? _projectTeamId;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  Team? get team {
    return _team;
  }
  
  String? get projectTeamId {
    return _projectTeamId;
  }
  
  const Project._internal({required this.id, name, team, projectTeamId}): _name = name, _team = team, _projectTeamId = projectTeamId;
  
  factory Project({String? id, String? name, Team? team, String? projectTeamId}) {
    return Project._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      team: team,
      projectTeamId: projectTeamId);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Project &&
      id == other.id &&
      _name == other._name &&
      _team == other._team &&
      _projectTeamId == other._projectTeamId;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Project {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"projectTeamId=\\" + \\"$_projectTeamId\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Project copyWith({String? id, String? name, Team? team, String? projectTeamId}) {
    return Project(
      id: id ?? this.id,
      name: name ?? this.name,
      team: team ?? this.team,
      projectTeamId: projectTeamId ?? this.projectTeamId);
  }
  
  Project.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _team = json['team']?['serializedData'] != null
        ? Team.fromJson(new Map<String, dynamic>.from(json['team']['serializedData']))
        : null,
      _projectTeamId = json['projectTeamId'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'team': _team?.toJson(), 'projectTeamId': _projectTeamId
  };

  static final QueryModelIdentifier<ProjectModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ProjectModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField TEAM = QueryField(
    fieldName: \\"team\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Team).toString()));
  static final QueryField PROJECTTEAMID = QueryField(fieldName: \\"projectTeamId\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Project\\";
    modelSchemaDefinition.pluralName = \\"Projects\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasOne(
      key: Project.TEAM,
      isRequired: false,
      ofModelName: (Team).toString(),
      associatedKey: Team.PROJECT
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project.PROJECTTEAMID,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _ProjectModelType extends ModelType<Project> {
  const _ProjectModelType();
  
  @override
  Project fromJson(Map<String, dynamic> jsonData) {
    return Project.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on implicit hasOne belongs to relationship @belongsTo 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Team type in your schema. */
@immutable
class Team extends Model {
  static const classType = const _TeamModelType();
  final String id;
  final String? _name;
  final Project? _project;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  Project? get project {
    return _project;
  }
  
  const Team._internal({required this.id, required name, project}): _name = name, _project = project;
  
  factory Team({String? id, required String name, Project? project}) {
    return Team._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      project: project);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Team &&
      id == other.id &&
      _name == other._name &&
      _project == other._project;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Team {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"project=\\" + (_project != null ? _project!.toString() : \\"null\\"));
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Team copyWith({String? id, String? name, Project? project}) {
    return Team(
      id: id ?? this.id,
      name: name ?? this.name,
      project: project ?? this.project);
  }
  
  Team.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _project = json['project']?['serializedData'] != null
        ? Project.fromJson(new Map<String, dynamic>.from(json['project']['serializedData']))
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'project': _project?.toJson()
  };

  static final QueryModelIdentifier<TeamModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<TeamModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField PROJECT = QueryField(
    fieldName: \\"project\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Project).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Team\\";
    modelSchemaDefinition.pluralName = \\"Teams\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Team.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.belongsTo(
      key: Team.PROJECT,
      isRequired: false,
      targetName: \\"teamProjectId\\",
      ofModelName: (Project).toString()
    ));
  });
}

class _TeamModelType extends ModelType<Team> {
  const _TeamModelType();
  
  @override
  Team fromJson(Map<String, dynamic> jsonData) {
    return Team.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on many to many relationship @manyToMany 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final String? _content;
  final List<PostTags>? _tags;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String? get content {
    return _content;
  }
  
  List<PostTags>? get tags {
    return _tags;
  }
  
  const Post._internal({required this.id, required title, content, tags}): _title = title, _content = content, _tags = tags;
  
  factory Post({String? id, required String title, String? content, List<PostTags>? tags}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      content: content,
      tags: tags != null ? List<PostTags>.unmodifiable(tags) : tags);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      _content == other._content &&
      DeepCollectionEquality().equals(_tags, other._tags);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\" + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, String? content, List<PostTags>? tags}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      content: content ?? this.content,
      tags: tags ?? this.tags);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _content = json['content'],
      _tags = json['tags'] is List
        ? (json['tags'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => PostTags.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'content': _content, 'tags': _tags?.map((PostTags? e) => e?.toJson()).toList()
  };

  static final QueryModelIdentifier<PostModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<PostModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static final QueryField TAGS = QueryField(
    fieldName: \\"tags\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (PostTags).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.CONTENT,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.TAGS,
      isRequired: false,
      ofModelName: (PostTags).toString(),
      associatedKey: PostTags.POST
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on many to many relationship @manyToMany 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Tag type in your schema. */
@immutable
class Tag extends Model {
  static const classType = const _TagModelType();
  final String id;
  final String? _label;
  final List<PostTags>? _posts;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get label {
    try {
      return _label!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<PostTags>? get posts {
    return _posts;
  }
  
  const Tag._internal({required this.id, required label, posts}): _label = label, _posts = posts;
  
  factory Tag({String? id, required String label, List<PostTags>? posts}) {
    return Tag._internal(
      id: id == null ? UUID.getUUID() : id,
      label: label,
      posts: posts != null ? List<PostTags>.unmodifiable(posts) : posts);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Tag &&
      id == other.id &&
      _label == other._label &&
      DeepCollectionEquality().equals(_posts, other._posts);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Tag {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"label=\\" + \\"$_label\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Tag copyWith({String? id, String? label, List<PostTags>? posts}) {
    return Tag(
      id: id ?? this.id,
      label: label ?? this.label,
      posts: posts ?? this.posts);
  }
  
  Tag.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _label = json['label'],
      _posts = json['posts'] is List
        ? (json['posts'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => PostTags.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'label': _label, 'posts': _posts?.map((PostTags? e) => e?.toJson()).toList()
  };

  static final QueryModelIdentifier<TagModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<TagModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField LABEL = QueryField(fieldName: \\"label\\");
  static final QueryField POSTS = QueryField(
    fieldName: \\"posts\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (PostTags).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Tag\\";
    modelSchemaDefinition.pluralName = \\"Tags\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Tag.LABEL,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Tag.POSTS,
      isRequired: false,
      ofModelName: (PostTags).toString(),
      associatedKey: PostTags.TAG
    ));
  });
}

class _TagModelType extends ModelType<Tag> {
  const _TagModelType();
  
  @override
  Tag fromJson(Map<String, dynamic> jsonData) {
    return Tag.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on record creation and updating timestamp 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Todo type in your schema. */
@immutable
class Todo extends Model {
  static const classType = const _TodoModelType();
  final String id;
  final String? _content;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get content {
    return _content;
  }
  
  const Todo._internal({required this.id, content}): _content = content;
  
  factory Todo({String? id, String? content}) {
    return Todo._internal(
      id: id == null ? UUID.getUUID() : id,
      content: content);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Todo &&
      id == other.id &&
      _content == other._content;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Todo {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Todo copyWith({String? id, String? content}) {
    return Todo(
      id: id ?? this.id,
      content: content ?? this.content);
  }
  
  Todo.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _content = json['content'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'content': _content
  };

  static final QueryModelIdentifier<TodoModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<TodoModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Todo\\";
    modelSchemaDefinition.pluralName = \\"Todos\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Todo.CONTENT,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _TodoModelType extends ModelType<Todo> {
  const _TodoModelType();
  
  @override
  Todo fromJson(Map<String, dynamic> jsonData) {
    return Todo.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on uni-directional explicit has many relationship @hasMany 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post2 type in your schema. */
@immutable
class Post2 extends Model {
  static const classType = const _Post2ModelType();
  final String id;
  final String? _title;
  final List<Comment2>? _comments;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Comment2>? get comments {
    return _comments;
  }
  
  const Post2._internal({required this.id, required title, comments}): _title = title, _comments = comments;
  
  factory Post2({String? id, required String title, List<Comment2>? comments}) {
    return Post2._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      comments: comments != null ? List<Comment2>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post2 &&
      id == other.id &&
      _title == other._title &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post2 {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post2 copyWith({String? id, String? title, List<Comment2>? comments}) {
    return Post2(
      id: id ?? this.id,
      title: title ?? this.title,
      comments: comments ?? this.comments);
  }
  
  Post2.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment2.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'comments': _comments?.map((Comment2? e) => e?.toJson()).toList()
  };

  static final QueryModelIdentifier<Post2ModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<Post2ModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Comment2).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post2\\";
    modelSchemaDefinition.pluralName = \\"Post2s\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post2.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post2.COMMENTS,
      isRequired: false,
      ofModelName: (Comment2).toString(),
      associatedKey: Comment2.POSTID
    ));
  });
}

class _Post2ModelType extends ModelType<Post2> {
  const _Post2ModelType();
  
  @override
  Post2 fromJson(Map<String, dynamic> jsonData) {
    return Post2.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on uni-directional explicit has many relationship @hasMany 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Comment2 type in your schema. */
@immutable
class Comment2 extends Model {
  static const classType = const _Comment2ModelType();
  final String id;
  final String? _postID;
  final String? _content;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get postID {
    try {
      return _postID!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get content {
    try {
      return _content!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Comment2._internal({required this.id, required postID, required content}): _postID = postID, _content = content;
  
  factory Comment2({String? id, required String postID, required String content}) {
    return Comment2._internal(
      id: id == null ? UUID.getUUID() : id,
      postID: postID,
      content: content);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment2 &&
      id == other.id &&
      _postID == other._postID &&
      _content == other._content;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment2 {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"postID=\\" + \\"$_postID\\" + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment2 copyWith({String? id, String? postID, String? content}) {
    return Comment2(
      id: id ?? this.id,
      postID: postID ?? this.postID,
      content: content ?? this.content);
  }
  
  Comment2.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _postID = json['postID'],
      _content = json['content'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'postID': _postID, 'content': _content
  };

  static final QueryModelIdentifier<Comment2ModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<Comment2ModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField POSTID = QueryField(fieldName: \\"postID\\");
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment2\\";
    modelSchemaDefinition.pluralName = \\"Comment2s\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"postID\\", \\"content\\"], name: \\"byPost\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment2.POSTID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment2.CONTENT,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _Comment2ModelType extends ModelType<Comment2> {
  const _Comment2ModelType();
  
  @override
  Comment2 fromJson(Map<String, dynamic> jsonData) {
    return Comment2.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on uni-directional explicit has one relationship @hasOne 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Project2 type in your schema. */
@immutable
class Project2 extends Model {
  static const classType = const _Project2ModelType();
  final String id;
  final String? _name;
  final String? _teamID;
  final Team2? _team;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  String? get teamID {
    return _teamID;
  }
  
  Team2? get team {
    return _team;
  }
  
  const Project2._internal({required this.id, name, teamID, team}): _name = name, _teamID = teamID, _team = team;
  
  factory Project2({String? id, String? name, String? teamID, Team2? team}) {
    return Project2._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      teamID: teamID,
      team: team);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Project2 &&
      id == other.id &&
      _name == other._name &&
      _teamID == other._teamID &&
      _team == other._team;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Project2 {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"teamID=\\" + \\"$_teamID\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Project2 copyWith({String? id, String? name, String? teamID, Team2? team}) {
    return Project2(
      id: id ?? this.id,
      name: name ?? this.name,
      teamID: teamID ?? this.teamID,
      team: team ?? this.team);
  }
  
  Project2.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _teamID = json['teamID'],
      _team = json['team']?['serializedData'] != null
        ? Team2.fromJson(new Map<String, dynamic>.from(json['team']['serializedData']))
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'teamID': _teamID, 'team': _team?.toJson()
  };

  static final QueryModelIdentifier<Project2ModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<Project2ModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField TEAMID = QueryField(fieldName: \\"teamID\\");
  static final QueryField TEAM = QueryField(
    fieldName: \\"team\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Team2).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Project2\\";
    modelSchemaDefinition.pluralName = \\"Project2s\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project2.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project2.TEAMID,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasOne(
      key: Project2.TEAM,
      isRequired: false,
      ofModelName: (Team2).toString(),
      associatedKey: Team2.ID
    ));
  });
}

class _Project2ModelType extends ModelType<Project2> {
  const _Project2ModelType();
  
  @override
  Project2 fromJson(Map<String, dynamic> jsonData) {
    return Project2.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on uni-directional explicit has one relationship @hasOne 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Team2 type in your schema. */
@immutable
class Team2 extends Model {
  static const classType = const _Team2ModelType();
  final String id;
  final String? _name;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Team2._internal({required this.id, required name}): _name = name;
  
  factory Team2({String? id, required String name}) {
    return Team2._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Team2 &&
      id == other.id &&
      _name == other._name;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Team2 {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Team2 copyWith({String? id, String? name}) {
    return Team2(
      id: id ?? this.id,
      name: name ?? this.name);
  }
  
  Team2.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name
  };

  static final QueryModelIdentifier<Team2ModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<Team2ModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Team2\\";
    modelSchemaDefinition.pluralName = \\"Team2s\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Team2.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _Team2ModelType extends ModelType<Team2> {
  const _Team2ModelType();
  
  @override
  Team2 fromJson(Map<String, dynamic> jsonData) {
    return Team2.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on uni-directional implicit has many relationship @hasMany 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Post type in your schema. */
@immutable
class Post extends Model {
  static const classType = const _PostModelType();
  final String id;
  final String? _title;
  final List<Comment>? _comments;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get title {
    try {
      return _title!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  List<Comment>? get comments {
    return _comments;
  }
  
  const Post._internal({required this.id, required title, comments}): _title = title, _comments = comments;
  
  factory Post({String? id, required String title, List<Comment>? comments}) {
    return Post._internal(
      id: id == null ? UUID.getUUID() : id,
      title: title,
      comments: comments != null ? List<Comment>.unmodifiable(comments) : comments);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Post &&
      id == other.id &&
      _title == other._title &&
      DeepCollectionEquality().equals(_comments, other._comments);
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Post {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"title=\\" + \\"$_title\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Post copyWith({String? id, String? title, List<Comment>? comments}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      comments: comments ?? this.comments);
  }
  
  Post.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _title = json['title'],
      _comments = json['comments'] is List
        ? (json['comments'] as List)
          .where((e) => e?['serializedData'] != null)
          .map((e) => Comment.fromJson(new Map<String, dynamic>.from(e['serializedData'])))
          .toList()
        : null;
  
  Map<String, dynamic> toJson() => {
    'id': id, 'title': _title, 'comments': _comments?.map((Comment? e) => e?.toJson()).toList()
  };

  static final QueryModelIdentifier<PostModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<PostModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField TITLE = QueryField(fieldName: \\"title\\");
  static final QueryField COMMENTS = QueryField(
    fieldName: \\"comments\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Comment).toString()));
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Post\\";
    modelSchemaDefinition.pluralName = \\"Posts\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Post.TITLE,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasMany(
      key: Post.COMMENTS,
      isRequired: false,
      ofModelName: (Comment).toString(),
      associatedKey: Comment.POSTCOMMENTSID
    ));
  });
}

class _PostModelType extends ModelType<Post> {
  const _PostModelType();
  
  @override
  Post fromJson(Map<String, dynamic> jsonData) {
    return Post.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on uni-directional implicit has many relationship @hasMany 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Comment type in your schema. */
@immutable
class Comment extends Model {
  static const classType = const _CommentModelType();
  final String id;
  final String? _content;
  final String? _postCommentsId;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get content {
    try {
      return _content!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String? get postCommentsId {
    return _postCommentsId;
  }
  
  const Comment._internal({required this.id, required content, postCommentsId}): _content = content, _postCommentsId = postCommentsId;
  
  factory Comment({String? id, required String content, String? postCommentsId}) {
    return Comment._internal(
      id: id == null ? UUID.getUUID() : id,
      content: content,
      postCommentsId: postCommentsId);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Comment &&
      id == other.id &&
      _content == other._content &&
      _postCommentsId == other._postCommentsId;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Comment {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\" + \\", \\");
    buffer.write(\\"postCommentsId=\\" + \\"$_postCommentsId\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Comment copyWith({String? id, String? content, String? postCommentsId}) {
    return Comment(
      id: id ?? this.id,
      content: content ?? this.content,
      postCommentsId: postCommentsId ?? this.postCommentsId);
  }
  
  Comment.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _content = json['content'],
      _postCommentsId = json['postCommentsId'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'content': _content, 'postCommentsId': _postCommentsId
  };

  static final QueryModelIdentifier<CommentModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<CommentModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static final QueryField POSTCOMMENTSID = QueryField(fieldName: \\"postCommentsId\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Comment\\";
    modelSchemaDefinition.pluralName = \\"Comments\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.CONTENT,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Comment.POSTCOMMENTSID,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CommentModelType extends ModelType<Comment> {
  const _CommentModelType();
  
  @override
  Comment fromJson(Map<String, dynamic> jsonData) {
    return Comment.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on uni-directional implicit has one relationship @hasOne 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'ModelProvider.dart';
import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Project type in your schema. */
@immutable
class Project extends Model {
  static const classType = const _ProjectModelType();
  final String id;
  final String? _name;
  final Team? _team;
  final String? _projectTeamId;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String? get name {
    return _name;
  }
  
  Team? get team {
    return _team;
  }
  
  String? get projectTeamId {
    return _projectTeamId;
  }
  
  const Project._internal({required this.id, name, team, projectTeamId}): _name = name, _team = team, _projectTeamId = projectTeamId;
  
  factory Project({String? id, String? name, Team? team, String? projectTeamId}) {
    return Project._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      team: team,
      projectTeamId: projectTeamId);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Project &&
      id == other.id &&
      _name == other._name &&
      _team == other._team &&
      _projectTeamId == other._projectTeamId;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Project {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"projectTeamId=\\" + \\"$_projectTeamId\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Project copyWith({String? id, String? name, Team? team, String? projectTeamId}) {
    return Project(
      id: id ?? this.id,
      name: name ?? this.name,
      team: team ?? this.team,
      projectTeamId: projectTeamId ?? this.projectTeamId);
  }
  
  Project.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _team = json['team']?['serializedData'] != null
        ? Team.fromJson(new Map<String, dynamic>.from(json['team']['serializedData']))
        : null,
      _projectTeamId = json['projectTeamId'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'team': _team?.toJson(), 'projectTeamId': _projectTeamId
  };

  static final QueryModelIdentifier<ProjectModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ProjectModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField TEAM = QueryField(
    fieldName: \\"team\\",
    fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (Team).toString()));
  static final QueryField PROJECTTEAMID = QueryField(fieldName: \\"projectTeamId\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Project\\";
    modelSchemaDefinition.pluralName = \\"Projects\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project.NAME,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.hasOne(
      key: Project.TEAM,
      isRequired: false,
      ofModelName: (Team).toString(),
      associatedKey: Team.ID
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Project.PROJECTTEAMID,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _ProjectModelType extends ModelType<Project> {
  const _ProjectModelType();
  
  @override
  Project fromJson(Map<String, dynamic> jsonData) {
    return Project.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works on uni-directional implicit has one relationship @hasOne 2`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Team type in your schema. */
@immutable
class Team extends Model {
  static const classType = const _TeamModelType();
  final String id;
  final String? _name;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Team._internal({required this.id, required name}): _name = name;
  
  factory Team({String? id, required String name}) {
    return Team._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Team &&
      id == other.id &&
      _name == other._name;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Team {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Team copyWith({String? id, String? name}) {
    return Team(
      id: id ?? this.id,
      name: name ?? this.name);
  }
  
  Team.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name
  };

  static final QueryModelIdentifier<TeamModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<TeamModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Team\\";
    modelSchemaDefinition.pluralName = \\"Teams\\";
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Team.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _TeamModelType extends ModelType<Team> {
  const _TeamModelType();
  
  @override
  Team fromJson(Map<String, dynamic> jsonData) {
    return Team.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests Works when configuring a secondary index 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the Customer type in your schema. */
@immutable
class Customer extends Model {
  static const classType = const _CustomerModelType();
  final String id;
  final String? _name;
  final String? _phoneNumber;
  final String? _accountRepresentativeID;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String? get phoneNumber {
    return _phoneNumber;
  }
  
  String get accountRepresentativeID {
    try {
      return _accountRepresentativeID!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const Customer._internal({required this.id, required name, phoneNumber, required accountRepresentativeID}): _name = name, _phoneNumber = phoneNumber, _accountRepresentativeID = accountRepresentativeID;
  
  factory Customer({String? id, required String name, String? phoneNumber, required String accountRepresentativeID}) {
    return Customer._internal(
      id: id == null ? UUID.getUUID() : id,
      name: name,
      phoneNumber: phoneNumber,
      accountRepresentativeID: accountRepresentativeID);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Customer &&
      id == other.id &&
      _name == other._name &&
      _phoneNumber == other._phoneNumber &&
      _accountRepresentativeID == other._accountRepresentativeID;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"Customer {\\");
    buffer.write(\\"id=\\" + \\"$id\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"phoneNumber=\\" + \\"$_phoneNumber\\" + \\", \\");
    buffer.write(\\"accountRepresentativeID=\\" + \\"$_accountRepresentativeID\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  Customer copyWith({String? id, String? name, String? phoneNumber, String? accountRepresentativeID}) {
    return Customer(
      id: id ?? this.id,
      name: name ?? this.name,
      phoneNumber: phoneNumber ?? this.phoneNumber,
      accountRepresentativeID: accountRepresentativeID ?? this.accountRepresentativeID);
  }
  
  Customer.fromJson(Map<String, dynamic> json)  
    : id = json['id'],
      _name = json['name'],
      _phoneNumber = json['phoneNumber'],
      _accountRepresentativeID = json['accountRepresentativeID'];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'name': _name, 'phoneNumber': _phoneNumber, 'accountRepresentativeID': _accountRepresentativeID
  };

  static final QueryModelIdentifier<CustomerModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<CustomerModelIdentifier>();
  static final QueryField ID = QueryField(fieldName: \\"id\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField PHONENUMBER = QueryField(fieldName: \\"phoneNumber\\");
  static final QueryField ACCOUNTREPRESENTATIVEID = QueryField(fieldName: \\"accountRepresentativeID\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"Customer\\";
    modelSchemaDefinition.pluralName = \\"Customers\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"accountRepresentativeID\\"], name: \\"byRepresentative\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.id());
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Customer.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Customer.PHONENUMBER,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: Customer.ACCOUNTREPRESENTATIVEID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _CustomerModelType extends ModelType<Customer> {
  const _CustomerModelType();
  
  @override
  Customer fromJson(Map<String, dynamic> jsonData) {
    return Customer.fromJson(jsonData);
  }
}"
`;

exports[`AppSyncDartVisitor - GQLv2 Regression Tests model indexes should correct indexes for @primaryKey and @index directive 1`] = `
"/*
* Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the \\"License\\").
* You may not use this file except in compliance with the License.
* A copy of the License is located at
*
*  http://aws.amazon.com/apache2.0
*
* or in the \\"license\\" file accompanying this file. This file is distributed
* on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
* express or implied. See the License for the specific language governing
* permissions and limitations under the License.
*/

// NOTE: This file is generated and may not follow lint rules defined in your app
// Generated files can be excluded from analysis in analysis_options.yaml
// For more info, see: https://dart.dev/guides/language/analysis-options#excluding-code-from-analysis

// ignore_for_file: public_member_api_docs, annotate_overrides, dead_code, dead_codepublic_member_api_docs, depend_on_referenced_packages, file_names, library_private_types_in_public_api, no_leading_underscores_for_library_prefixes, no_leading_underscores_for_local_identifiers, non_constant_identifier_names, null_check_on_nullable_type_parameter, prefer_adjacent_string_concatenation, prefer_const_constructors, prefer_if_null_operators, prefer_interpolation_to_compose_strings, slash_for_doc_comments, sort_child_properties_last, unnecessary_const, unnecessary_constructor_name, unnecessary_late, unnecessary_new, unnecessary_null_aware_assignments, unnecessary_nullable_for_final_variable_declarations, unnecessary_string_interpolations, use_build_context_synchronously

import 'package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface.dart';
import 'package:flutter/foundation.dart';


/** This is an auto generated class representing the ModelWithPrimaryKey type in your schema. */
@immutable
class ModelWithPrimaryKey extends Model {
  static const classType = const _ModelWithPrimaryKeyModelType();
  final String? _productID;
  final String? _name;
  final String? _content;
  final String? _albumID;
  final String? _categoryID;

  @override
  getInstanceType() => classType;
  
  @override
  String getId() {
    return id;
  }
  
  String get productID {
    try {
      return _productID!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get name {
    try {
      return _name!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String? get content {
    return _content;
  }
  
  String get albumID {
    try {
      return _albumID!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  String get categoryID {
    try {
      return _categoryID!;
    } catch(e) {
      throw new DataStoreException(
          DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage,
          recoverySuggestion:
            DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion,
          underlyingException: e.toString()
          );
    }
  }
  
  const ModelWithPrimaryKey._internal({required productID, required name, content, required albumID, required categoryID}): _productID = productID, _name = name, _content = content, _albumID = albumID, _categoryID = categoryID;
  
  factory ModelWithPrimaryKey({required String productID, required String name, String? content, required String albumID, required String categoryID}) {
    return ModelWithPrimaryKey._internal(
      productID: productID,
      name: name,
      content: content,
      albumID: albumID,
      categoryID: categoryID);
  }
  
  bool equals(Object other) {
    return this == other;
  }
  
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ModelWithPrimaryKey &&
      _productID == other._productID &&
      _name == other._name &&
      _content == other._content &&
      _albumID == other._albumID &&
      _categoryID == other._categoryID;
  }
  
  @override
  int get hashCode => toString().hashCode;
  
  @override
  String toString() {
    var buffer = new StringBuffer();
    
    buffer.write(\\"ModelWithPrimaryKey {\\");
    buffer.write(\\"productID=\\" + \\"$_productID\\" + \\", \\");
    buffer.write(\\"name=\\" + \\"$_name\\" + \\", \\");
    buffer.write(\\"content=\\" + \\"$_content\\" + \\", \\");
    buffer.write(\\"albumID=\\" + \\"$_albumID\\" + \\", \\");
    buffer.write(\\"categoryID=\\" + \\"$_categoryID\\");
    buffer.write(\\"}\\");
    
    return buffer.toString();
  }
  
  ModelWithPrimaryKey copyWith({String? productID, String? name, String? content, String? albumID, String? categoryID}) {
    return ModelWithPrimaryKey(
      productID: productID ?? this.productID,
      name: name ?? this.name,
      content: content ?? this.content,
      albumID: albumID ?? this.albumID,
      categoryID: categoryID ?? this.categoryID);
  }
  
  ModelWithPrimaryKey.fromJson(Map<String, dynamic> json)  
    : _productID = json['productID'],
      _name = json['name'],
      _content = json['content'],
      _albumID = json['albumID'],
      _categoryID = json['categoryID'];
  
  Map<String, dynamic> toJson() => {
    'productID': _productID, 'name': _name, 'content': _content, 'albumID': _albumID, 'categoryID': _categoryID
  };

  static final QueryModelIdentifier<ModelWithPrimaryKeyModelIdentifier> MODEL_IDENTIFIER = QueryModelIdentifier<ModelWithPrimaryKeyModelIdentifier>();
  static final QueryField PRODUCTID = QueryField(fieldName: \\"productID\\");
  static final QueryField NAME = QueryField(fieldName: \\"name\\");
  static final QueryField CONTENT = QueryField(fieldName: \\"content\\");
  static final QueryField ALBUMID = QueryField(fieldName: \\"albumID\\");
  static final QueryField CATEGORYID = QueryField(fieldName: \\"categoryID\\");
  static var schema = Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {
    modelSchemaDefinition.name = \\"ModelWithPrimaryKey\\";
    modelSchemaDefinition.pluralName = \\"ModelWithPrimaryKeys\\";
    
    modelSchemaDefinition.indexes = [
      ModelIndex(fields: const [\\"productID\\"], name: null),
      ModelIndex(fields: const [\\"albumID\\", \\"name\\"], name: \\"byAlbum\\"),
      ModelIndex(fields: const [\\"categoryID\\", \\"name\\", \\"content\\"], name: \\"byCategory\\")
    ];
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithPrimaryKey.PRODUCTID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithPrimaryKey.NAME,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithPrimaryKey.CONTENT,
      isRequired: false,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithPrimaryKey.ALBUMID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
    
    modelSchemaDefinition.addField(ModelFieldDefinition.field(
      key: ModelWithPrimaryKey.CATEGORYID,
      isRequired: true,
      ofType: ModelFieldType(ModelFieldTypeEnum.string)
    ));
  });
}

class _ModelWithPrimaryKeyModelType extends ModelType<ModelWithPrimaryKey> {
  const _ModelWithPrimaryKeyModelType();
  
  @override
  ModelWithPrimaryKey fromJson(Map<String, dynamic> jsonData) {
    return ModelWithPrimaryKey.fromJson(jsonData);
  }
}"
`;
