// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post: Model {
  public let id: String
  public var title: String
  public var comments: List<Comment>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment>? = []) {
    self.init(id: id,
      title: title,
      comments: comments,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.comments = comments
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case comments
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post = Post.keys
    
    model.pluralName = \\"Posts\\"
    
    model.attributes(
      .primaryKey(fields: [post.id])
    )
    
    model.fields(
      .field(post.id, is: .required, ofType: .string),
      .field(post.title, is: .required, ofType: .string),
      .hasMany(post.comments, is: .optional, ofType: Comment.self, associatedWith: Comment.keys.post),
      .field(post.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Post: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Comment: Model {
  public let id: String
  public var content: String
  public var post: Post?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      content: String,
      post: Post? = nil) {
    self.init(id: id,
      content: content,
      post: post,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      content: String,
      post: Post? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.content = content
      self.post = post
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Comment {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case post
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let comment = Comment.keys
    
    model.pluralName = \\"Comments\\"
    
    model.attributes(
      .index(fields: [\\"postID\\", \\"content\\"], name: \\"byPost\\"),
      .primaryKey(fields: [comment.id])
    )
    
    model.fields(
      .field(comment.id, is: .required, ofType: .string),
      .field(comment.content, is: .required, ofType: .string),
      .belongsTo(comment.post, is: .optional, ofType: Post.self, targetName: \\"postID\\"),
      .field(comment.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Comment: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasOne belongs to relationship @belongsTo 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Project2: Model {
  public let id: String
  public var name: String?
  public var team: Team2?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var project2TeamId: String?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil,
      team: Team2? = nil,
      project2TeamId: String? = nil) {
    self.init(id: id,
      name: name,
      team: team,
      createdAt: nil,
      updatedAt: nil,
      project2TeamId: project2TeamId)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      team: Team2? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      project2TeamId: String? = nil) {
      self.id = id
      self.name = name
      self.team = team
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.project2TeamId = project2TeamId
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasOne belongs to relationship @belongsTo 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Project2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case team
    case createdAt
    case updatedAt
    case project2TeamId
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let project2 = Project2.keys
    
    model.pluralName = \\"Project2s\\"
    
    model.attributes(
      .primaryKey(fields: [project2.id])
    )
    
    model.fields(
      .field(project2.id, is: .required, ofType: .string),
      .field(project2.name, is: .optional, ofType: .string),
      .hasOne(project2.team, is: .optional, ofType: Team2.self, associatedWith: Team2.keys.project, targetName: \\"project2TeamId\\"),
      .field(project2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project2.project2TeamId, is: .optional, ofType: .string)
    )
    }
}

extension Project2: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasOne belongs to relationship @belongsTo 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Team2: Model {
  public let id: String
  public var name: String
  public var project: Project2?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String,
      project: Project2? = nil) {
    self.init(id: id,
      name: name,
      project: project,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String,
      project: Project2? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.project = project
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasOne belongs to relationship @belongsTo 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Team2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case project
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let team2 = Team2.keys
    
    model.pluralName = \\"Team2s\\"
    
    model.attributes(
      .primaryKey(fields: [team2.id])
    )
    
    model.fields(
      .field(team2.id, is: .required, ofType: .string),
      .field(team2.name, is: .required, ofType: .string),
      .belongsTo(team2.project, is: .optional, ofType: Project2.self, targetName: \\"projectID\\"),
      .field(team2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(team2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Team2: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Blog7V2: Model {
  public let id: String
  public var name: String
  public var posts: List<Post7V2>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String,
      posts: List<Post7V2>? = []) {
    self.init(id: id,
      name: name,
      posts: posts,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String,
      posts: List<Post7V2>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.posts = posts
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Blog7V2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case posts
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let blog7V2 = Blog7V2.keys
    
    model.pluralName = \\"Blog7V2s\\"
    
    model.attributes(
      .primaryKey(fields: [blog7V2.id])
    )
    
    model.fields(
      .field(blog7V2.id, is: .required, ofType: .string),
      .field(blog7V2.name, is: .required, ofType: .string),
      .hasMany(blog7V2.posts, is: .optional, ofType: Post7V2.self, associatedWith: Post7V2.keys.blog),
      .field(blog7V2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(blog7V2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Blog7V2: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post7V2: Model {
  public let id: String
  public var title: String
  public var blog: Blog7V2?
  public var comments: List<Comment7V2>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      blog: Blog7V2? = nil,
      comments: List<Comment7V2>? = []) {
    self.init(id: id,
      title: title,
      blog: blog,
      comments: comments,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      blog: Blog7V2? = nil,
      comments: List<Comment7V2>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.blog = blog
      self.comments = comments
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post7V2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case blog
    case comments
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post7V2 = Post7V2.keys
    
    model.pluralName = \\"Post7V2s\\"
    
    model.attributes(
      .primaryKey(fields: [post7V2.id])
    )
    
    model.fields(
      .field(post7V2.id, is: .required, ofType: .string),
      .field(post7V2.title, is: .required, ofType: .string),
      .belongsTo(post7V2.blog, is: .optional, ofType: Blog7V2.self, targetName: \\"blog7V2PostsId\\"),
      .hasMany(post7V2.comments, is: .optional, ofType: Comment7V2.self, associatedWith: Comment7V2.keys.post),
      .field(post7V2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post7V2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Post7V2: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 5`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Comment7V2: Model {
  public let id: String
  public var content: String?
  public var post: Post7V2?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      content: String? = nil,
      post: Post7V2? = nil) {
    self.init(id: id,
      content: content,
      post: post,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      content: String? = nil,
      post: Post7V2? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.content = content
      self.post = post
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 6`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Comment7V2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case post
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let comment7V2 = Comment7V2.keys
    
    model.pluralName = \\"Comment7V2s\\"
    
    model.attributes(
      .primaryKey(fields: [comment7V2.id])
    )
    
    model.fields(
      .field(comment7V2.id, is: .required, ofType: .string),
      .field(comment7V2.content, is: .optional, ofType: .string),
      .belongsTo(comment7V2.post, is: .optional, ofType: Post7V2.self, targetName: \\"post7V2CommentsId\\"),
      .field(comment7V2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment7V2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Comment7V2: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasOne belongs to relationship @belongsTo 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Project: Model {
  public let id: String
  public var name: String?
  public var team: Team?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var projectTeamId: String?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil,
      team: Team? = nil,
      projectTeamId: String? = nil) {
    self.init(id: id,
      name: name,
      team: team,
      createdAt: nil,
      updatedAt: nil,
      projectTeamId: projectTeamId)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      team: Team? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      projectTeamId: String? = nil) {
      self.id = id
      self.name = name
      self.team = team
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.projectTeamId = projectTeamId
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasOne belongs to relationship @belongsTo 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Project {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case team
    case createdAt
    case updatedAt
    case projectTeamId
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let project = Project.keys
    
    model.pluralName = \\"Projects\\"
    
    model.attributes(
      .primaryKey(fields: [project.id])
    )
    
    model.fields(
      .field(project.id, is: .required, ofType: .string),
      .field(project.name, is: .optional, ofType: .string),
      .hasOne(project.team, is: .optional, ofType: Team.self, associatedWith: Team.keys.project, targetName: \\"projectTeamId\\"),
      .field(project.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project.projectTeamId, is: .optional, ofType: .string)
    )
    }
}

extension Project: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasOne belongs to relationship @belongsTo 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Team: Model {
  public let id: String
  public var name: String
  public var project: Project?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String,
      project: Project? = nil) {
    self.init(id: id,
      name: name,
      project: project,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String,
      project: Project? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.project = project
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasOne belongs to relationship @belongsTo 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Team {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case project
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let team = Team.keys
    
    model.pluralName = \\"Teams\\"
    
    model.attributes(
      .primaryKey(fields: [team.id])
    )
    
    model.fields(
      .field(team.id, is: .required, ofType: .string),
      .field(team.name, is: .required, ofType: .string),
      .belongsTo(team.project, is: .optional, ofType: Project.self, targetName: \\"teamProjectId\\"),
      .field(team.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(team.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Team: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on many to many relationship @manyToMany 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post: Model {
  public let id: String
  public var title: String
  public var content: String?
  public var tags: List<PostTags>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      content: String? = nil,
      tags: List<PostTags>? = []) {
    self.init(id: id,
      title: title,
      content: content,
      tags: tags,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      content: String? = nil,
      tags: List<PostTags>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.content = content
      self.tags = tags
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on many to many relationship @manyToMany 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case content
    case tags
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post = Post.keys
    
    model.pluralName = \\"Posts\\"
    
    model.attributes(
      .primaryKey(fields: [post.id])
    )
    
    model.fields(
      .field(post.id, is: .required, ofType: .string),
      .field(post.title, is: .required, ofType: .string),
      .field(post.content, is: .optional, ofType: .string),
      .hasMany(post.tags, is: .optional, ofType: PostTags.self, associatedWith: PostTags.keys.post),
      .field(post.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Post: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on many to many relationship @manyToMany 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Tag: Model {
  public let id: String
  public var label: String
  public var posts: List<PostTags>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      label: String,
      posts: List<PostTags>? = []) {
    self.init(id: id,
      label: label,
      posts: posts,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      label: String,
      posts: List<PostTags>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.label = label
      self.posts = posts
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on many to many relationship @manyToMany 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Tag {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case label
    case posts
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let tag = Tag.keys
    
    model.pluralName = \\"Tags\\"
    
    model.attributes(
      .primaryKey(fields: [tag.id])
    )
    
    model.fields(
      .field(tag.id, is: .required, ofType: .string),
      .field(tag.label, is: .required, ofType: .string),
      .hasMany(tag.posts, is: .optional, ofType: PostTags.self, associatedWith: PostTags.keys.tag),
      .field(tag.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(tag.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Tag: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on record creation and updating timestamp 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Todo: Model {
  public let id: String
  public var content: String?
  public var createdOn: Temporal.DateTime?
  public var updatedOn: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      content: String? = nil) {
    self.init(id: id,
      content: content,
      createdOn: nil,
      updatedOn: nil)
  }
  internal init(id: String = UUID().uuidString,
      content: String? = nil,
      createdOn: Temporal.DateTime? = nil,
      updatedOn: Temporal.DateTime? = nil) {
      self.id = id
      self.content = content
      self.createdOn = createdOn
      self.updatedOn = updatedOn
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on record creation and updating timestamp 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Todo {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case createdOn
    case updatedOn
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let todo = Todo.keys
    
    model.pluralName = \\"Todos\\"
    
    model.attributes(
      .primaryKey(fields: [todo.id])
    )
    
    model.fields(
      .field(todo.id, is: .required, ofType: .string),
      .field(todo.content, is: .optional, ofType: .string),
      .field(todo.createdOn, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(todo.updatedOn, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Todo: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has many relationship @hasMany 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post2: Model {
  public let id: String
  public var title: String
  public var comments: List<Comment2>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment2>? = []) {
    self.init(id: id,
      title: title,
      comments: comments,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment2>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.comments = comments
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has many relationship @hasMany 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case comments
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post2 = Post2.keys
    
    model.pluralName = \\"Post2s\\"
    
    model.attributes(
      .primaryKey(fields: [post2.id])
    )
    
    model.fields(
      .field(post2.id, is: .required, ofType: .string),
      .field(post2.title, is: .required, ofType: .string),
      .hasMany(post2.comments, is: .optional, ofType: Comment2.self, associatedWith: Comment2.keys.postID),
      .field(post2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Post2: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has many relationship @hasMany 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Comment2: Model {
  public let id: String
  public var postID: String
  public var content: String
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      postID: String,
      content: String) {
    self.init(id: id,
      postID: postID,
      content: content,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      postID: String,
      content: String,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.postID = postID
      self.content = content
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has many relationship @hasMany 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Comment2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case postID
    case content
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let comment2 = Comment2.keys
    
    model.pluralName = \\"Comment2s\\"
    
    model.attributes(
      .index(fields: [\\"postID\\", \\"content\\"], name: \\"byPost\\"),
      .primaryKey(fields: [comment2.id])
    )
    
    model.fields(
      .field(comment2.id, is: .required, ofType: .string),
      .field(comment2.postID, is: .required, ofType: .string),
      .field(comment2.content, is: .required, ofType: .string),
      .field(comment2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Comment2: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has one relationship @hasOne 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Project2: Model {
  public let id: String
  public var name: String?
  public var teamID: String?
  public var team: Team2?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil,
      teamID: String? = nil,
      team: Team2? = nil) {
    self.init(id: id,
      name: name,
      teamID: teamID,
      team: team,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      teamID: String? = nil,
      team: Team2? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.teamID = teamID
      self.team = team
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has one relationship @hasOne 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Project2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case teamID
    case team
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let project2 = Project2.keys
    
    model.pluralName = \\"Project2s\\"
    
    model.attributes(
      .primaryKey(fields: [project2.id])
    )
    
    model.fields(
      .field(project2.id, is: .required, ofType: .string),
      .field(project2.name, is: .optional, ofType: .string),
      .field(project2.teamID, is: .optional, ofType: .string),
      .hasOne(project2.team, is: .optional, ofType: Team2.self, associatedWith: Team2.keys.id, targetName: \\"teamID\\"),
      .field(project2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Project2: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has one relationship @hasOne 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Team2: Model {
  public let id: String
  public var name: String
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String) {
    self.init(id: id,
      name: name,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has one relationship @hasOne 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Team2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let team2 = Team2.keys
    
    model.pluralName = \\"Team2s\\"
    
    model.attributes(
      .primaryKey(fields: [team2.id])
    )
    
    model.fields(
      .field(team2.id, is: .required, ofType: .string),
      .field(team2.name, is: .required, ofType: .string),
      .field(team2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(team2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Team2: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has many relationship @hasMany 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post: Model {
  public let id: String
  public var title: String
  public var comments: List<Comment>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment>? = []) {
    self.init(id: id,
      title: title,
      comments: comments,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.comments = comments
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has many relationship @hasMany 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case comments
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post = Post.keys
    
    model.pluralName = \\"Posts\\"
    
    model.attributes(
      .primaryKey(fields: [post.id])
    )
    
    model.fields(
      .field(post.id, is: .required, ofType: .string),
      .field(post.title, is: .required, ofType: .string),
      .hasMany(post.comments, is: .optional, ofType: Comment.self, associatedWith: Comment.keys.postCommentsId),
      .field(post.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Post: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has many relationship @hasMany 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Comment: Model {
  public let id: String
  public var content: String
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var postCommentsId: String?
  
  public init(id: String = UUID().uuidString,
      content: String,
      postCommentsId: String? = nil) {
    self.init(id: id,
      content: content,
      createdAt: nil,
      updatedAt: nil,
      postCommentsId: postCommentsId)
  }
  internal init(id: String = UUID().uuidString,
      content: String,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      postCommentsId: String? = nil) {
      self.id = id
      self.content = content
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.postCommentsId = postCommentsId
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has many relationship @hasMany 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Comment {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case createdAt
    case updatedAt
    case postCommentsId
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let comment = Comment.keys
    
    model.pluralName = \\"Comments\\"
    
    model.attributes(
      .primaryKey(fields: [comment.id])
    )
    
    model.fields(
      .field(comment.id, is: .required, ofType: .string),
      .field(comment.content, is: .required, ofType: .string),
      .field(comment.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment.postCommentsId, is: .optional, ofType: .string)
    )
    }
}

extension Comment: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has one relationship @hasOne 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Project: Model {
  public let id: String
  public var name: String?
  public var team: Team?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var projectTeamId: String?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil,
      team: Team? = nil,
      projectTeamId: String? = nil) {
    self.init(id: id,
      name: name,
      team: team,
      createdAt: nil,
      updatedAt: nil,
      projectTeamId: projectTeamId)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      team: Team? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      projectTeamId: String? = nil) {
      self.id = id
      self.name = name
      self.team = team
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.projectTeamId = projectTeamId
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has one relationship @hasOne 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Project {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case team
    case createdAt
    case updatedAt
    case projectTeamId
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let project = Project.keys
    
    model.pluralName = \\"Projects\\"
    
    model.attributes(
      .primaryKey(fields: [project.id])
    )
    
    model.fields(
      .field(project.id, is: .required, ofType: .string),
      .field(project.name, is: .optional, ofType: .string),
      .hasOne(project.team, is: .optional, ofType: Team.self, associatedWith: Team.keys.id, targetName: \\"projectTeamId\\"),
      .field(project.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project.projectTeamId, is: .optional, ofType: .string)
    )
    }
}

extension Project: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has one relationship @hasOne 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Team: Model {
  public let id: String
  public var name: String
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String) {
    self.init(id: id,
      name: name,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has one relationship @hasOne 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Team {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let team = Team.keys
    
    model.pluralName = \\"Teams\\"
    
    model.attributes(
      .primaryKey(fields: [team.id])
    )
    
    model.fields(
      .field(team.id, is: .required, ofType: .string),
      .field(team.name, is: .required, ofType: .string),
      .field(team.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(team.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Team: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works when configuring a secondary index 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Customer: Model {
  public let id: String
  public var name: String
  public var phoneNumber: String?
  public var accountRepresentativeID: String
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String,
      phoneNumber: String? = nil,
      accountRepresentativeID: String) {
    self.init(id: id,
      name: name,
      phoneNumber: phoneNumber,
      accountRepresentativeID: accountRepresentativeID,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String,
      phoneNumber: String? = nil,
      accountRepresentativeID: String,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.phoneNumber = phoneNumber
      self.accountRepresentativeID = accountRepresentativeID
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works when configuring a secondary index 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Customer {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case phoneNumber
    case accountRepresentativeID
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let customer = Customer.keys
    
    model.pluralName = \\"Customers\\"
    
    model.attributes(
      .index(fields: [\\"accountRepresentativeID\\"], name: \\"byRepresentative\\"),
      .primaryKey(fields: [customer.id])
    )
    
    model.fields(
      .field(customer.id, is: .required, ofType: .string),
      .field(customer.name, is: .required, ofType: .string),
      .field(customer.phoneNumber, is: .optional, ofType: .string),
      .field(customer.accountRepresentativeID, is: .required, ofType: .string),
      .field(customer.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(customer.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}

extension Customer: ModelIdentifiable {
  public typealias IdentifierFormat = ModelIdentifierFormat.Default
  public typealias Identifier = DefaultModelIdentifier<Self>
}"
`;
