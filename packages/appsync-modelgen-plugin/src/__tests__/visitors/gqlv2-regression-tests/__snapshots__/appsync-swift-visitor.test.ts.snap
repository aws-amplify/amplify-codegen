// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo (required associations) 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post3: Model {
  public let id: String
  public var title: String
  public var comments: List<Comment3>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment3>? = []) {
    self.init(id: id,
      title: title,
      comments: comments,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment3>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.comments = comments
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo (required associations) 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post3 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case comments
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post3 = Post3.keys
    
    model.listPluralName = \\"Post3s\\"
    model.syncPluralName = \\"Post3s\\"
    
    model.fields(
      .id(),
      .field(post3.title, is: .required, ofType: .string),
      .hasMany(post3.comments, is: .optional, ofType: Comment3.self, associatedWith: Comment3.keys.post),
      .field(post3.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post3.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo (required associations) 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Comment3: Model {
  public let id: String
  public var content: String
  public var post: Post3
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      content: String,
      post: Post3) {
    self.init(id: id,
      content: content,
      post: post,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      content: String,
      post: Post3,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.content = content
      self.post = post
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo (required associations) 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Comment3 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case post
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let comment3 = Comment3.keys
    
    model.listPluralName = \\"Comment3s\\"
    model.syncPluralName = \\"Comment3s\\"
    
    model.attributes(
      .index(fields: [\\"postID\\", \\"content\\"], name: \\"byPost\\")
    )
    
    model.fields(
      .id(),
      .field(comment3.content, is: .required, ofType: .string),
      .belongsTo(comment3.post, is: .required, ofType: Post3.self, targetName: \\"postID\\"),
      .field(comment3.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment3.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post: Model {
  public let id: String
  public var title: String
  public var comments: List<Comment>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment>? = []) {
    self.init(id: id,
      title: title,
      comments: comments,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.comments = comments
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case comments
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post = Post.keys
    
    model.listPluralName = \\"Posts\\"
    model.syncPluralName = \\"Posts\\"
    
    model.fields(
      .id(),
      .field(post.title, is: .required, ofType: .string),
      .hasMany(post.comments, is: .optional, ofType: Comment.self, associatedWith: Comment.keys.post),
      .field(post.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Comment: Model {
  public let id: String
  public var content: String
  public var post: Post?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      content: String,
      post: Post? = nil) {
    self.init(id: id,
      content: content,
      post: post,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      content: String,
      post: Post? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.content = content
      self.post = post
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasMany belongs to relationship @belongsTo 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Comment {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case post
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let comment = Comment.keys
    
    model.listPluralName = \\"Comments\\"
    model.syncPluralName = \\"Comments\\"
    
    model.attributes(
      .index(fields: [\\"postID\\", \\"content\\"], name: \\"byPost\\")
    )
    
    model.fields(
      .id(),
      .field(comment.content, is: .required, ofType: .string),
      .belongsTo(comment.post, is: .optional, ofType: Post.self, targetName: \\"postID\\"),
      .field(comment.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasOne belongs to relationship @belongsTo 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Project2: Model {
  public let id: String
  public var name: String?
  public var team: Team2?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var project2TeamId: String?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil,
      team: Team2? = nil,
      project2TeamId: String? = nil) {
    self.init(id: id,
      name: name,
      team: team,
      createdAt: nil,
      updatedAt: nil,
      project2TeamId: project2TeamId)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      team: Team2? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      project2TeamId: String? = nil) {
      self.id = id
      self.name = name
      self.team = team
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.project2TeamId = project2TeamId
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasOne belongs to relationship @belongsTo 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Project2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case team
    case createdAt
    case updatedAt
    case project2TeamId
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let project2 = Project2.keys
    
    model.listPluralName = \\"Project2s\\"
    model.syncPluralName = \\"Project2s\\"
    
    model.fields(
      .id(),
      .field(project2.name, is: .optional, ofType: .string),
      .hasOne(project2.team, is: .optional, ofType: Team2.self, associatedWith: Team2.keys.project, targetName: \\"project2TeamId\\"),
      .field(project2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project2.project2TeamId, is: .optional, ofType: .string)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasOne belongs to relationship @belongsTo 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Team2: Model {
  public let id: String
  public var name: String
  public var project: Project2?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String,
      project: Project2? = nil) {
    self.init(id: id,
      name: name,
      project: project,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String,
      project: Project2? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.project = project
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on explicit hasOne belongs to relationship @belongsTo 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Team2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case project
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let team2 = Team2.keys
    
    model.listPluralName = \\"Team2s\\"
    model.syncPluralName = \\"Team2s\\"
    
    model.fields(
      .id(),
      .field(team2.name, is: .required, ofType: .string),
      .belongsTo(team2.project, is: .optional, ofType: Project2.self, targetName: \\"projectID\\"),
      .field(team2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(team2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Blog7V2: Model {
  public let id: String
  public var name: String
  public var posts: List<Post7V2>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String,
      posts: List<Post7V2>? = []) {
    self.init(id: id,
      name: name,
      posts: posts,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String,
      posts: List<Post7V2>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.posts = posts
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Blog7V2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case posts
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let blog7V2 = Blog7V2.keys
    
    model.listPluralName = \\"Blog7V2s\\"
    model.syncPluralName = \\"Blog7V2s\\"
    
    model.fields(
      .id(),
      .field(blog7V2.name, is: .required, ofType: .string),
      .hasMany(blog7V2.posts, is: .optional, ofType: Post7V2.self, associatedWith: Post7V2.keys.blog),
      .field(blog7V2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(blog7V2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post7V2: Model {
  public let id: String
  public var title: String
  public var blog: Blog7V2?
  public var comments: List<Comment7V2>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      blog: Blog7V2? = nil,
      comments: List<Comment7V2>? = []) {
    self.init(id: id,
      title: title,
      blog: blog,
      comments: comments,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      blog: Blog7V2? = nil,
      comments: List<Comment7V2>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.blog = blog
      self.comments = comments
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post7V2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case blog
    case comments
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post7V2 = Post7V2.keys
    
    model.listPluralName = \\"Post7V2s\\"
    model.syncPluralName = \\"Post7V2s\\"
    
    model.fields(
      .id(),
      .field(post7V2.title, is: .required, ofType: .string),
      .belongsTo(post7V2.blog, is: .optional, ofType: Blog7V2.self, targetName: \\"blog7V2PostsId\\"),
      .hasMany(post7V2.comments, is: .optional, ofType: Comment7V2.self, associatedWith: Comment7V2.keys.post),
      .field(post7V2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post7V2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 5`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Comment7V2: Model {
  public let id: String
  public var content: String?
  public var post: Post7V2?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      content: String? = nil,
      post: Post7V2? = nil) {
    self.init(id: id,
      content: content,
      post: post,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      content: String? = nil,
      post: Post7V2? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.content = content
      self.post = post
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (extended) 6`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Comment7V2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case post
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let comment7V2 = Comment7V2.keys
    
    model.listPluralName = \\"Comment7V2s\\"
    model.syncPluralName = \\"Comment7V2s\\"
    
    model.fields(
      .id(),
      .field(comment7V2.content, is: .optional, ofType: .string),
      .belongsTo(comment7V2.post, is: .optional, ofType: Post7V2.self, targetName: \\"post7V2CommentsId\\"),
      .field(comment7V2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment7V2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (required associations) 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Blog8V2: Model {
  public let id: String
  public var name: String
  public var posts: List<Post8V2>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String,
      posts: List<Post8V2>? = []) {
    self.init(id: id,
      name: name,
      posts: posts,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String,
      posts: List<Post8V2>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.posts = posts
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (required associations) 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Blog8V2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case posts
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let blog8V2 = Blog8V2.keys
    
    model.listPluralName = \\"Blog8V2s\\"
    model.syncPluralName = \\"Blog8V2s\\"
    
    model.fields(
      .id(),
      .field(blog8V2.name, is: .required, ofType: .string),
      .hasMany(blog8V2.posts, is: .optional, ofType: Post8V2.self, associatedWith: Post8V2.keys.blog),
      .field(blog8V2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(blog8V2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (required associations) 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post8V2: Model {
  public let id: String
  public var title: String
  public var blog: Blog8V2
  public var comments: List<Comment8V2>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      blog: Blog8V2,
      comments: List<Comment8V2>? = []) {
    self.init(id: id,
      title: title,
      blog: blog,
      comments: comments,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      blog: Blog8V2,
      comments: List<Comment8V2>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.blog = blog
      self.comments = comments
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (required associations) 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post8V2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case blog
    case comments
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post8V2 = Post8V2.keys
    
    model.listPluralName = \\"Post8V2s\\"
    model.syncPluralName = \\"Post8V2s\\"
    
    model.fields(
      .id(),
      .field(post8V2.title, is: .required, ofType: .string),
      .belongsTo(post8V2.blog, is: .required, ofType: Blog8V2.self, targetName: \\"blog8V2PostsId\\"),
      .hasMany(post8V2.comments, is: .optional, ofType: Comment8V2.self, associatedWith: Comment8V2.keys.post),
      .field(post8V2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post8V2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (required associations) 5`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Comment8V2: Model {
  public let id: String
  public var content: String?
  public var post: Post8V2
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      content: String? = nil,
      post: Post8V2) {
    self.init(id: id,
      content: content,
      post: post,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      content: String? = nil,
      post: Post8V2,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.content = content
      self.post = post
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasMany belongs to relationship @belongsTo (required associations) 6`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Comment8V2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case post
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let comment8V2 = Comment8V2.keys
    
    model.listPluralName = \\"Comment8V2s\\"
    model.syncPluralName = \\"Comment8V2s\\"
    
    model.fields(
      .id(),
      .field(comment8V2.content, is: .optional, ofType: .string),
      .belongsTo(comment8V2.post, is: .required, ofType: Post8V2.self, targetName: \\"post8V2CommentsId\\"),
      .field(comment8V2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment8V2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasOne belongs to relationship @belongsTo 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Project: Model {
  public let id: String
  public var name: String?
  public var team: Team?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var projectTeamId: String?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil,
      team: Team? = nil,
      projectTeamId: String? = nil) {
    self.init(id: id,
      name: name,
      team: team,
      createdAt: nil,
      updatedAt: nil,
      projectTeamId: projectTeamId)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      team: Team? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      projectTeamId: String? = nil) {
      self.id = id
      self.name = name
      self.team = team
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.projectTeamId = projectTeamId
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasOne belongs to relationship @belongsTo 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Project {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case team
    case createdAt
    case updatedAt
    case projectTeamId
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let project = Project.keys
    
    model.listPluralName = \\"Projects\\"
    model.syncPluralName = \\"Projects\\"
    
    model.fields(
      .id(),
      .field(project.name, is: .optional, ofType: .string),
      .hasOne(project.team, is: .optional, ofType: Team.self, associatedWith: Team.keys.project, targetName: \\"projectTeamId\\"),
      .field(project.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project.projectTeamId, is: .optional, ofType: .string)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasOne belongs to relationship @belongsTo 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Team: Model {
  public let id: String
  public var name: String
  public var project: Project?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String,
      project: Project? = nil) {
    self.init(id: id,
      name: name,
      project: project,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String,
      project: Project? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.project = project
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on implicit hasOne belongs to relationship @belongsTo 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Team {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case project
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let team = Team.keys
    
    model.listPluralName = \\"Teams\\"
    model.syncPluralName = \\"Teams\\"
    
    model.fields(
      .id(),
      .field(team.name, is: .required, ofType: .string),
      .belongsTo(team.project, is: .optional, ofType: Project.self, targetName: \\"teamProjectId\\"),
      .field(team.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(team.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on many to many relationship @manyToMany 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post: Model {
  public let id: String
  public var title: String
  public var content: String?
  public var tags: List<PostTags>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      content: String? = nil,
      tags: List<PostTags>? = []) {
    self.init(id: id,
      title: title,
      content: content,
      tags: tags,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      content: String? = nil,
      tags: List<PostTags>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.content = content
      self.tags = tags
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on many to many relationship @manyToMany 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case content
    case tags
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post = Post.keys
    
    model.listPluralName = \\"Posts\\"
    model.syncPluralName = \\"Posts\\"
    
    model.fields(
      .id(),
      .field(post.title, is: .required, ofType: .string),
      .field(post.content, is: .optional, ofType: .string),
      .hasMany(post.tags, is: .optional, ofType: PostTags.self, associatedWith: PostTags.keys.post),
      .field(post.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on many to many relationship @manyToMany 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Tag: Model {
  public let id: String
  public var label: String
  public var posts: List<PostTags>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      label: String,
      posts: List<PostTags>? = []) {
    self.init(id: id,
      label: label,
      posts: posts,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      label: String,
      posts: List<PostTags>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.label = label
      self.posts = posts
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on many to many relationship @manyToMany 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Tag {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case label
    case posts
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let tag = Tag.keys
    
    model.listPluralName = \\"Tags\\"
    model.syncPluralName = \\"Tags\\"
    
    model.fields(
      .id(),
      .field(tag.label, is: .required, ofType: .string),
      .hasMany(tag.posts, is: .optional, ofType: PostTags.self, associatedWith: PostTags.keys.tag),
      .field(tag.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(tag.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on record creation and updating timestamp 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Todo: Model {
  public let id: String
  public var content: String?
  public var createdOn: Temporal.DateTime?
  public var updatedOn: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      content: String? = nil) {
    self.init(id: id,
      content: content,
      createdOn: nil,
      updatedOn: nil)
  }
  internal init(id: String = UUID().uuidString,
      content: String? = nil,
      createdOn: Temporal.DateTime? = nil,
      updatedOn: Temporal.DateTime? = nil) {
      self.id = id
      self.content = content
      self.createdOn = createdOn
      self.updatedOn = updatedOn
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on record creation and updating timestamp 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Todo {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case createdOn
    case updatedOn
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let todo = Todo.keys
    
    model.listPluralName = \\"Todos\\"
    model.syncPluralName = \\"Todos\\"
    
    model.fields(
      .id(),
      .field(todo.content, is: .optional, ofType: .string),
      .field(todo.createdOn, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(todo.updatedOn, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has many relationship @hasMany 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post2: Model {
  public let id: String
  public var title: String
  public var comments: List<Comment2>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment2>? = []) {
    self.init(id: id,
      title: title,
      comments: comments,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment2>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.comments = comments
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has many relationship @hasMany 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case comments
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post2 = Post2.keys
    
    model.listPluralName = \\"Post2s\\"
    model.syncPluralName = \\"Post2s\\"
    
    model.fields(
      .id(),
      .field(post2.title, is: .required, ofType: .string),
      .hasMany(post2.comments, is: .optional, ofType: Comment2.self, associatedWith: Comment2.keys.postID),
      .field(post2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has many relationship @hasMany 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Comment2: Model {
  public let id: String
  public var postID: String
  public var content: String
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      postID: String,
      content: String) {
    self.init(id: id,
      postID: postID,
      content: content,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      postID: String,
      content: String,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.postID = postID
      self.content = content
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has many relationship @hasMany 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Comment2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case postID
    case content
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let comment2 = Comment2.keys
    
    model.listPluralName = \\"Comment2s\\"
    model.syncPluralName = \\"Comment2s\\"
    
    model.attributes(
      .index(fields: [\\"postID\\", \\"content\\"], name: \\"byPost\\")
    )
    
    model.fields(
      .id(),
      .field(comment2.postID, is: .required, ofType: .string),
      .field(comment2.content, is: .required, ofType: .string),
      .field(comment2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has one relationship @hasOne 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Project2: Model {
  public let id: String
  public var name: String?
  public var teamID: String?
  public var team: Team2?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil,
      teamID: String? = nil,
      team: Team2? = nil) {
    self.init(id: id,
      name: name,
      teamID: teamID,
      team: team,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      teamID: String? = nil,
      team: Team2? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.teamID = teamID
      self.team = team
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has one relationship @hasOne 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Project2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case teamID
    case team
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let project2 = Project2.keys
    
    model.listPluralName = \\"Project2s\\"
    model.syncPluralName = \\"Project2s\\"
    
    model.fields(
      .id(),
      .field(project2.name, is: .optional, ofType: .string),
      .field(project2.teamID, is: .optional, ofType: .string),
      .hasOne(project2.team, is: .optional, ofType: Team2.self, associatedWith: Team2.keys.id, targetName: \\"teamID\\"),
      .field(project2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has one relationship @hasOne 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Team2: Model {
  public let id: String
  public var name: String
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String) {
    self.init(id: id,
      name: name,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional explicit has one relationship @hasOne 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Team2 {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let team2 = Team2.keys
    
    model.listPluralName = \\"Team2s\\"
    model.syncPluralName = \\"Team2s\\"
    
    model.fields(
      .id(),
      .field(team2.name, is: .required, ofType: .string),
      .field(team2.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(team2.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has many relationship @hasMany 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Post: Model {
  public let id: String
  public var title: String
  public var comments: List<Comment>?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment>? = []) {
    self.init(id: id,
      title: title,
      comments: comments,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      title: String,
      comments: List<Comment>? = [],
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.title = title
      self.comments = comments
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has many relationship @hasMany 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Post {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case title
    case comments
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let post = Post.keys
    
    model.listPluralName = \\"Posts\\"
    model.syncPluralName = \\"Posts\\"
    
    model.fields(
      .id(),
      .field(post.title, is: .required, ofType: .string),
      .hasMany(post.comments, is: .optional, ofType: Comment.self, associatedWith: Comment.keys.postCommentsId),
      .field(post.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(post.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has many relationship @hasMany 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Comment: Model {
  public let id: String
  public var content: String
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var postCommentsId: String?
  
  public init(id: String = UUID().uuidString,
      content: String,
      postCommentsId: String? = nil) {
    self.init(id: id,
      content: content,
      createdAt: nil,
      updatedAt: nil,
      postCommentsId: postCommentsId)
  }
  internal init(id: String = UUID().uuidString,
      content: String,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      postCommentsId: String? = nil) {
      self.id = id
      self.content = content
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.postCommentsId = postCommentsId
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has many relationship @hasMany 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Comment {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case content
    case createdAt
    case updatedAt
    case postCommentsId
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let comment = Comment.keys
    
    model.listPluralName = \\"Comments\\"
    model.syncPluralName = \\"Comments\\"
    
    model.fields(
      .id(),
      .field(comment.content, is: .required, ofType: .string),
      .field(comment.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(comment.postCommentsId, is: .optional, ofType: .string)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has one relationship @hasOne 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Project: Model {
  public let id: String
  public var name: String?
  public var team: Team?
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  public var projectTeamId: String?
  
  public init(id: String = UUID().uuidString,
      name: String? = nil,
      team: Team? = nil,
      projectTeamId: String? = nil) {
    self.init(id: id,
      name: name,
      team: team,
      createdAt: nil,
      updatedAt: nil,
      projectTeamId: projectTeamId)
  }
  internal init(id: String = UUID().uuidString,
      name: String? = nil,
      team: Team? = nil,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil,
      projectTeamId: String? = nil) {
      self.id = id
      self.name = name
      self.team = team
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.projectTeamId = projectTeamId
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has one relationship @hasOne 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Project {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case team
    case createdAt
    case updatedAt
    case projectTeamId
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let project = Project.keys
    
    model.listPluralName = \\"Projects\\"
    model.syncPluralName = \\"Projects\\"
    
    model.fields(
      .id(),
      .field(project.name, is: .optional, ofType: .string),
      .hasOne(project.team, is: .optional, ofType: Team.self, associatedWith: Team.keys.id, targetName: \\"projectTeamId\\"),
      .field(project.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(project.projectTeamId, is: .optional, ofType: .string)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has one relationship @hasOne 3`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Team: Model {
  public let id: String
  public var name: String
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String) {
    self.init(id: id,
      name: name,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works on uni-directional implicit has one relationship @hasOne 4`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Team {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let team = Team.keys
    
    model.listPluralName = \\"Teams\\"
    model.syncPluralName = \\"Teams\\"
    
    model.fields(
      .id(),
      .field(team.name, is: .required, ofType: .string),
      .field(team.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(team.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works when configuring a secondary index 1`] = `
"// swiftlint:disable all
import Amplify
import Foundation

public struct Customer: Model {
  public let id: String
  public var name: String
  public var phoneNumber: String?
  public var accountRepresentativeID: String
  public var createdAt: Temporal.DateTime?
  public var updatedAt: Temporal.DateTime?
  
  public init(id: String = UUID().uuidString,
      name: String,
      phoneNumber: String? = nil,
      accountRepresentativeID: String) {
    self.init(id: id,
      name: name,
      phoneNumber: phoneNumber,
      accountRepresentativeID: accountRepresentativeID,
      createdAt: nil,
      updatedAt: nil)
  }
  internal init(id: String = UUID().uuidString,
      name: String,
      phoneNumber: String? = nil,
      accountRepresentativeID: String,
      createdAt: Temporal.DateTime? = nil,
      updatedAt: Temporal.DateTime? = nil) {
      self.id = id
      self.name = name
      self.phoneNumber = phoneNumber
      self.accountRepresentativeID = accountRepresentativeID
      self.createdAt = createdAt
      self.updatedAt = updatedAt
  }
}"
`;

exports[`AppSyncSwiftVisitor - GQLv2 Regression Tests Works when configuring a secondary index 2`] = `
"// swiftlint:disable all
import Amplify
import Foundation

extension Customer {
  // MARK: - CodingKeys 
   public enum CodingKeys: String, ModelKey {
    case id
    case name
    case phoneNumber
    case accountRepresentativeID
    case createdAt
    case updatedAt
  }
  
  public static let keys = CodingKeys.self
  //  MARK: - ModelSchema 
  
  public static let schema = defineSchema { model in
    let customer = Customer.keys
    
    model.listPluralName = \\"Customers\\"
    model.syncPluralName = \\"Customers\\"
    
    model.attributes(
      .index(fields: [\\"accountRepresentativeID\\"], name: \\"byRepresentative\\")
    )
    
    model.fields(
      .id(),
      .field(customer.name, is: .required, ofType: .string),
      .field(customer.phoneNumber, is: .optional, ofType: .string),
      .field(customer.accountRepresentativeID, is: .required, ofType: .string),
      .field(customer.createdAt, is: .optional, isReadOnly: true, ofType: .dateTime),
      .field(customer.updatedAt, is: .optional, isReadOnly: true, ofType: .dateTime)
    )
    }
}"
`;
